1.gaia小组件
 # 微件化
 # cli（脚手架）
 通过oclif框架搭建
  ## gaia dev
  	 运行时命令，设置端口，开启热更新
  	 ### 热更新
		内部实现主要使用了webpack、express、websocket，使用express启动本地服务，当浏览器访问资源时对此做响应，服务端和客户端使用websocket实现长连接webpack，监听源文件的变化，即当开发者保存文件时触发webpack的重新编译。每次编译都会生成hash值、已改动模块的json文件、已改动模块代码的js文件，编译完成后通过socket向客户端推送当前编译的hash戳，客户端的websocket监听到有文件改动推送过来的hash戳，会和上一次对比，一致则走缓存，不一致则通过ajax和jsonp（获取的代码可以直接执行)向服务端获取最新资源，hotApply使用__webpack_require__
		去替换有修改的内容实现局部刷新。

		附：为什么更新模块的代码不直接在第三步通过 websocket 发送到浏览器端，而是通过 jsonp 来获取呢？

		我的理解是，功能块的解耦，各个模块各司其职，dev-server/client 只负责消息的传递而不负责新模块的获取，而这些工作应该有 HMR runtime 来完成，HMR runtime 才应该是获取新代码的地方。再就是因为不使用 webpack-dev-server 的前提，使用 webpack-hot-middleware 和 webpack 配合也可以完成模块热更新流程，在使用 webpack-hot-middleware 中有件有意思的事，它没有使用 websocket，而是使用的 EventSource。综上所述，HMR 的工作流中，不应该把新模块代码放在 websocket 消息中。

  ## gaia init
  	 读文件：
  	 1.从cdn获取静态模版压缩包。（或者也可以使用npm包的方式）
  	 2.根据输入获取小组件名称，作者，标识。
  	 写文件：
  	 1.将获取到的信息组成配置，结合模版生成基础文件写入。

  ## gaia release
  	 1.检查一系列版本，输入作者信息。
  	 2.项目按照system的格式进行打包，编译，然后npm发布。
  	 3.将编译完后的文件上传至cdn，获取cdn链接。
  	 4.将cdn链接、版本通过接口传给后端。
 # systemJs
  ## qiankun中自己往window上面挂载了system


 # 弊端
 	无法进行按需加载、首屏资源加载优化、css 独立打包等优化措施

	## 样式隔离问题
 	single-spa 没有做这部分的工作。一个大型的系统会有很的微应用组成，怎么保证这些微应用之间的样式互不影响？微应用和主应用之间的样式互不影响？这时只能通过约定命名规范来实现，比如应用样式以自己的应用名称开头，以应用名构造一个独立的命名空间，这个方式新系统还好说，如果是一个已有的系统，这个改造工作量可不小。

 	## JS 隔离
 	JS 全局对象污染是一个很常见的现象，比如：微应用 A 在全局对象上添加了一个自己特有的属性，window.A，这时候切换到微应用 B，这时候如何保证 window 对象是干净的呢？

 	## 资源预加载
 	通过fetch进行资源的预加载, 下次加载时可以直接

 	## 应用间通信
 	通过组件props的形式进行通信，或者使用window，localstorage

2.阶段汇总报告、表扬榜

3.日常迭代维护
白话：b端系统中最多的就是表格和表单，表格和表单中又有很多的字段，公司中不同的部门，会展示不同的字段。每次有新增字段的需求，都需要针对这两大场景。我们
#重构学员花名册、crm线索系统
 ## gaia的c端

 ## 

