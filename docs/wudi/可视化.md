# HTML5 Canvas 

---

## 一、canvas 简介

`<canvas>` 是 `HTML5` 新增的，一个可以使用脚本(通常为 `JavaScript`) 在其中绘制图像的 `HTML` 元素。它可以用来制作照片集或者制作简单(也不是那么简单)的动画，甚至可以进行实时视频处理和渲染。

它最初由苹果内部使用自己 `MacOS X WebKit` 推出，供应用程序使用像仪表盘的构件和 `Safari` 浏览器使用。后来，有人通过 `Gecko` 内核的浏览器 (尤其是 `Mozilla`和`Firefox`)，`Opera` 和 `Chrome` 和超文本网络应用技术工作组建议为下一代的网络技术使用该元素。

`Canvas` 是由 `HTML` 代码配合高度和宽度属性而定义出的可绘制区域。`JavaScript` 代码可以访问该区域，类似于其他通用的二维 `API`，通过一套完整的绘图函数来动态生成图形。

 Mozilla 程序从 Gecko 1.8 (Firefox 1.5) 开始支持 `<canvas>`, Internet Explorer 从 IE9 开始 `<canvas>` 。Chrome 和 Opera 9+ 也支持 `<canvas>`。

___

## 二、Canvas基本使用

```
<canvas id="tutorial" width="300" height="300"></canvas>
```

### 2.1 `<canvas>` 元素

`<canvas>` 看起来和 `<img>` 标签一样，只是 `<canvas>` 只有两个可选的属性 `width、heigth` 属性，而没有 `src、alt` 属性。

如果不给 `<canvas>` 设置 `widht、height` 属性时，则默认 `width`为300、`height` 为 150，单位都是 `px`。也可以使用 `css` 属性来设置宽高，但是如宽高属性和初始比例不一致，他会出现扭曲。所以，建议永远不要使用 `css` 属性来设置 `<canvas>` 的宽高。

**替换内容**

由于某些较老的浏览器（尤其是 IE9 之前的 IE 浏览器）或者浏览器不支持 HTML 元素 `<canvas>`，在这些浏览器上你应该总是能展示替代内容。

支持 `<canvas>` 的浏览器会只渲染 `<canvas>` 标签，而忽略其中的替代内容。不支持 `<canvas>` 的浏览器则 会直接渲染替代内容。

用文本替换：

```html
<canvas>
    你的浏览器不支持 canvas，请升级你的浏览器。
</canvas>
```

用 `<img>` 替换：

```html
<canvas>
    <img src="./美女.jpg" alt=""> 
</canvas>
```

结束标签 `</canvas>` 不可省略。

与 `<img>` 元素不同，`<canvas>` 元素需要结束标签(`</canvas>`)。如果结束标签不存在，则文档的其余部分会被认为是替代内容，将不会显示出来。

### 2.2 渲染上下文(Thre Rending Context)

`<canvas>` 会创建一个固定大小的画布，会公开一个或多个**渲染上下文**(画笔)，使用**渲染上下文**来绘制和处理要展示的内容。

 我们重点研究 2D 渲染上下文。 其他的上下文我们暂不研究，比如， WebGL 使用了基于 OpenGL ES的3D 上下文 ("experimental-webgl") 。

```js
var canvas = document.getElementById('tutorial');
//获得 2d 上下文对象
var ctx = canvas.getContext('2d');
```

### 2.3 检测支持性

```js
var canvas = document.getElementById('tutorial');

if (canvas.getContext){
  var ctx = canvas.getContext('2d');
  // drawing code here
} else {
  // canvas-unsupported code here
}
```

### 2.4 代码模板

```js
<canvas id="tutorial" width="300" height="300"></canvas>
<script type="text/javascript">
function draw(){
    var canvas = document.getElementById('tutorial');
    if(!canvas.getContext) return;
      var ctx = canvas.getContext("2d");
      //开始代码
    
}
draw();
</script>
```



### 2.5 一个简单的例子

以下实例绘制两个长方形：



```html
<canvas id="tutorial" width="300" height="300"></canvas>
<script type="text/javascript">
function draw(){
    var canvas = document.getElementById('tutorial');
    if(!canvas.getContext) return;
    var ctx = canvas.getContext("2d");
    ctx.fillStyle = "rgb(200,0,0)";
      //绘制矩形
    ctx.fillRect (10, 10, 55, 50);
 
    ctx.fillStyle = "rgba(0, 0, 200, 0.5)";
    ctx.fillRect (30, 30, 55, 50);
}
draw();
</script>
```



___

## 三、绘制形状

### 3.1 栅格 `(grid)` 和坐标空间

如下图所示，`canvas` 元素默认被网格所覆盖。通常来说网格中的一个单元相当于 `canvas` 元素中的一像素。栅格的起点为左上角，坐标为 (0,0) 。所有元素的位置都相对于原点来定位。所以图中蓝色方形左上角的坐标为距离左边（X 轴）x 像素，距离上边（Y 轴）y 像素，坐标为 (x,y)。

后面我们会涉及到坐标原点的平移、网格的旋转以及缩放等。

![](https://www.runoob.com/wp-content/uploads/2018/12/Canvas_default_grid.png)

### 3.2 绘制矩形

`<canvas>` 只支持一种原生的图形绘制：**矩形**。所有其他图形都至少需要生成一种路径 (`path`)。不过，我们拥有众多路径生成的方法让复杂图形的绘制成为了可能。

canvast 提供了三种方法绘制矩形：

-   1、fillRect(x, y, width, height)：绘制一个填充的矩形。
-   2、strokeRect(x, y, width, height)：绘制一个矩形的边框。
-   3、clearRect(x, y, widh, height)：清除指定的矩形区域，然后这块区域会变的完全透明。

**说明：**这 3 个方法具有相同的参数。

-   **x, y**：指的是矩形的左上角的坐标。(相对于canvas的坐标原点)
-   **width, height**：指的是绘制的矩形的宽和高。

```js
function draw(){
    var canvas = document.getElementById('tutorial');
    if(!canvas.getContext) return;
    var ctx = canvas.getContext("2d");
    ctx.fillRect(10, 10, 100, 50);     // 绘制矩形，填充的默认颜色为黑色
    ctx.strokeRect(10, 70, 100, 50);   // 绘制矩形边框
    
}
draw();
```

![](https://www.runoob.com/wp-content/uploads/2018/12/2400420933-5b74dd8f80306_articlex.png)

`ctx.clearRect(15, 15, 50, 25);`

![](https://www.runoob.com/wp-content/uploads/2018/12/2347163070-5b74dd8f813a6_articlex.png)

___

## 四、绘制路径 (`path`)

图形的基本元素是路径。

路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。

一个路径，甚至一个子路径，都是闭合的。

使用路径绘制图形需要一些额外的步骤：

1.  创建路径起始点
2.  调用绘制方法去绘制出路径
3.  把路径封闭
4.  一旦路径生成，通过描边或填充路径区域来渲染图形。

下面是需要用到的方法：

1. `beginPath()`

   新建一条路径，路径一旦创建成功，图形绘制命令被指向到路径上生成路径

2. `moveTo(x, y)`

   把画笔移动到指定的坐标`(x, y)`。相当于设置路径的起始点坐标。

3. `closePath()`

   闭合路径之后，图形绘制命令又重新指向到上下文中

4. `stroke()`

   通过线条来绘制图形轮廓

5. `fill()`

   通过填充路径的内容区域生成实心的图形

### 4.1 绘制线段

```js
function draw(){
    var canvas = document.getElementById('tutorial');
    if (!canvas.getContext) return;
    var ctx = canvas.getContext("2d");
    ctx.beginPath(); //新建一条path
    ctx.moveTo(50, 50); //把画笔移动到指定的坐标
    ctx.lineTo(200, 50);  //绘制一条从当前位置到指定坐标(200, 50)的直线.
    //闭合路径。会拉一条从当前点到path起始点的直线。如果当前点与起始点重合，则什么都不做
    ctx.closePath();
    ctx.stroke(); //绘制路径。
}
draw();
```



### 4.2 绘制三角形边框

```js
function draw(){
    var canvas = document.getElementById('tutorial');
    if (!canvas.getContext) return;
    var ctx = canvas.getContext("2d");
    ctx.beginPath();
    ctx.moveTo(50, 50);
    ctx.lineTo(200, 50);
    ctx.lineTo(200, 200);
      ctx.closePath(); //虽然我们只绘制了两条线段，但是closePath会closePath，仍然是一个3角形
    ctx.stroke(); //描边。stroke不会自动closePath()
}
draw();
```

![](https://www.runoob.com/wp-content/uploads/2018/12/2106846415-5b74dd8f67000_articlex.png)

### 4.3 填充三角形

```js
function draw(){
    var canvas = document.getElementById('tutorial');
    if (!canvas.getContext) return;
    var ctx = canvas.getContext("2d");
    ctx.beginPath();
    ctx.moveTo(50, 50);
    ctx.lineTo(200, 50);
    ctx.lineTo(200, 200);
   
    ctx.fill(); //填充闭合区域。如果path没有闭合，则fill()会自动闭合路径。
}
draw();
```

![](https://www.runoob.com/wp-content/uploads/2018/12/3457015746-5b74dd8f72860_articlex.png)

### 4.4 绘制圆弧

有两个方法可以绘制圆弧：

1、arc(x, y, r, startAngle, endAngle, anticlockwise): 以`(x, y)` 为圆心，以`r` 为半径，从 `startAngle` 弧度开始到`endAngle`弧度结束。`anticlosewise` 是布尔值，`true` 表示逆时针，`false` 表示顺时针(默认是顺时针)。

注意：

1. 这里的度数都是弧度。

2. `0` 弧度是指的 `x` 轴正方向。

   ```
   radians=(Math.PI/180)*degrees   //角度转换成弧度
   ```

2、arcTo(x1, y1, x2, y2, radius): 根据给定的控制点和半径画一段圆弧，最后再以直线连接两个控制点。

#### 圆弧案例 1

```js
function draw(){
    var canvas = document.getElementById('tutorial');
    if (!canvas.getContext) return;
    var ctx = canvas.getContext("2d");
    ctx.beginPath();
    ctx.arc(50, 50, 40, 0, Math.PI / 2, false);
    ctx.stroke();
}
draw();
```

![](https://www.runoob.com/wp-content/uploads/2018/12/3832141455-5b74dd8f658df_articlex.png)

#### 圆弧案例 2

```js
function draw(){
    var canvas = document.getElementById('tutorial');
    if (!canvas.getContext) return;
    var ctx = canvas.getContext("2d");
    ctx.beginPath();
    ctx.arc(50, 50, 40, 0, Math.PI / 2, false);
    ctx.stroke();
 
    ctx.beginPath();
    ctx.arc(150, 50, 40, 0, -Math.PI / 2, true);
    ctx.closePath();
    ctx.stroke();
 
    ctx.beginPath();
    ctx.arc(50, 150, 40, -Math.PI / 2, Math.PI / 2, false);
    ctx.fill();
 
    ctx.beginPath();
    ctx.arc(150, 150, 40, 0, Math.PI, false);
    ctx.fill();
 
}
draw();
```

![](https://www.runoob.com/wp-content/uploads/2018/12/2218794221-5b74dd8f43f98_articlex.png)

#### 圆弧案例 3

```js
function draw(){
    var canvas = document.getElementById('tutorial');
    if (!canvas.getContext) return;
    var ctx = canvas.getContext("2d");
    ctx.beginPath();
    ctx.moveTo(50, 50);
      //参数1、2：控制点1坐标   参数3、4：控制点2坐标  参数4：圆弧半径
    ctx.arcTo(200, 50, 200, 200, 100);
    ctx.lineTo(200, 200)
    ctx.stroke();
    
    ctx.beginPath();
    ctx.rect(50, 50, 10, 10);
    ctx.rect(200, 50, 10, 10)
    ctx.rect(200, 200, 10, 10)
    ctx.fill()
}
draw();
```

![](https://www.runoob.com/wp-content/uploads/2018/12/3556678928-5b74dd8f1bd2a_articlex.png)

`arcTo` 方法的说明：

这个方法可以这样理解。绘制的弧形是由两条切线所决定。

第 1 条切线：起始点和控制点1决定的直线。

第 2 条切线：控制点1 和控制点2决定的直线。

**其实绘制的圆弧就是与这两条直线相切的圆弧。**

### 4.5 绘制贝塞尔曲线

**4.5.1 什么是贝塞尔曲线**



贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。

一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋，我们在绘图工具上看到的钢笔工具就是来做这种矢量曲线的。

贝塞尔曲线是计算机图形学中相当重要的参数曲线，在一些比较成熟的位图软件中也有贝塞尔曲线工具如 PhotoShop 等。在 Flash4 中还没有完整的曲线工具，而在 Flash5 里面已经提供出贝塞尔曲线工具。

贝塞尔曲线于 1962，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。贝塞尔曲线最初由Paul de Casteljau 于 1959 年运用 de Casteljau 演算法开发，以稳定数值的方法求出贝兹曲线。

一次贝塞尔曲线其实是一条直线

![](https://www.runoob.com/wp-content/uploads/2018/12/240px-b_1_big.gif)

二次贝塞尔曲线

![](https://www.runoob.com/wp-content/uploads/2018/12/b_2_big.gif)

![](https://www.runoob.com/wp-content/uploads/2018/12/1544764428-5713-240px-BC3A9zier-2-big.svg-.png)

三次贝塞尔曲线

![](https://www.runoob.com/wp-content/uploads/2018/12/b_3_big.gif)

![](https://www.runoob.com/wp-content/uploads/2018/12/1544764428-2467-240px-BC3A9zier-3-big.svg-.png)

**4.5.2 绘制贝塞尔曲线**

绘制二次贝塞尔曲线:

```
quadraticCurveTo(cp1x, cp1y, x, y)
```

说明：

-    参数 1 和 2：控制点坐标
-    参数 3 和 4：结束点坐标

```js
function draw(){
    var canvas = document.getElementById('tutorial');
    if (!canvas.getContext) return;
    var ctx = canvas.getContext("2d");
    ctx.beginPath();
    ctx.moveTo(10, 200); //起始点
    var cp1x = 40, cp1y = 100;  //控制点
    var x = 200, y = 200; // 结束点
    //绘制二次贝塞尔曲线
    ctx.quadraticCurveTo(cp1x, cp1y, x, y);
    ctx.stroke();
 
    ctx.beginPath();
    ctx.rect(10, 200, 10, 10);
    ctx.rect(cp1x, cp1y, 10, 10);
    ctx.rect(x, y, 10, 10);
    ctx.fill();
 
}
draw();
```

![](https://www.runoob.com/wp-content/uploads/2018/12/274915666-5b74dd8ecb2e2_articlex.png)

绘制三次贝塞尔曲线:

```
bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)
```

说明：

-    参数 1 和 2：控制点 1 的坐标
-    参数 3 和 4：控制点 2 的坐标
-    参数 5 和 6：结束点的坐标

```js
function draw(){
    var canvas = document.getElementById('tutorial');
    if (!canvas.getContext) return;
    var ctx = canvas.getContext("2d");
    ctx.beginPath();
    ctx.moveTo(40, 200); //起始点
    var cp1x = 20, cp1y = 100;  //控制点1
    var cp2x = 100, cp2y = 120;  //控制点2
    var x = 200, y = 200; // 结束点
    //绘制二次贝塞尔曲线
    ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    ctx.stroke();
 
    ctx.beginPath();
    ctx.rect(40, 200, 10, 10);
    ctx.rect(cp1x, cp1y, 10, 10);
    ctx.rect(cp2x, cp2y, 10, 10);
    ctx.rect(x, y, 10, 10);
    ctx.fill();
 
}
draw();
```

![](https://www.runoob.com/wp-content/uploads/2018/12/3947786617-5b74dd8ec8678_articlex.png)

___

## 五、添加样式和颜色

 在前面的绘制矩形章节中，只用到了默认的线条和颜色。

 如果想要给图形上色，有两个重要的属性可以做到。

1.  `fillStyle = color` 设置图形的填充颜色

2.  `strokeStyle = color` 设置图形轮廓的颜色

**备注：**

-   1\. color 可以是表示 css 颜色值的字符串、渐变对象或者图案对象。
-   2\. 默认情况下，线条和填充颜色都是黑色。
-   3\. 一旦您设置了 strokeStyle 或者 fillStyle 的值，那么这个新值就会成为新绘制的图形的默认值。如果你要给每个图形上不同的颜色，你需要重新设置 fillStyle 或 strokeStyle 的值。

### fillStyle

```js
function draw(){
  var canvas = document.getElementById('tutorial');
  if (!canvas.getContext) return;
  var ctx = canvas.getContext("2d");
  for (var i = 0; i < 6; i++){
    for (var j = 0; j < 6; j++){
      ctx.fillStyle = 'rgb(' + Math.floor(255 - 42.5 * i) + ',' +
        Math.floor(255 - 42.5 * j) + ',0)';
      ctx.fillRect(j * 50, i * 50, 50, 50);
    }
  }
}
draw();
```

![](https://www.runoob.com/wp-content/uploads/2018/12/2505008676-5b74dd8ebad41_articlex.png)

### strokeStyle

```js
function draw(){
    var canvas = document.getElementById('tutorial');
    if (!canvas.getContext) return;
    var ctx = canvas.getContext("2d");
    for (var i = 0; i < 6; i++){
        for (var j = 0; j < 6; j++){
            ctx.strokeStyle = `rgb(${randomInt(0, 255)},${randomInt(0, 255)},${randomInt(0, 255)})`;
            ctx.strokeRect(j * 50, i * 50, 40, 40);
        }
    }
}
draw();
/**
 返回随机的 [from, to] 之间的整数(包括from，也包括to)
 */
function randomInt(from, to){
    return parseInt(Math.random() * (to - from + 1) + from);
}
```

![](https://www.runoob.com/wp-content/uploads/2018/12/3288535670-5b74dd8ea12d9_articlex.png)

### Transparency(透明度)

**globalAlpha = transparencyValue**: 这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。

 **globalAlpha** 属性在需要绘制大量拥有相同透明度的图形时候相当高效。不过，我认为使用rgba()设置透明度更加好一些。

### 1、line style

线宽。只能是正值。默认是 1.0。

起始点和终点的连线为中心，**上下各占线宽的一半**。

```js
ctx.beginPath();
ctx.moveTo(10, 10);
ctx.lineTo(100, 10);
ctx.lineWidth = 10;
ctx.stroke();
 
ctx.beginPath();
ctx.moveTo(110, 10);
ctx.lineTo(160, 10)
ctx.lineWidth = 20;
ctx.stroke()
```

![](https://www.runoob.com/wp-content/uploads/2018/12/3410060825-5b74dd8ea12d9_articlex.png)

### 2\. lineCap = type

线条末端样式。

共有 3 个值：

1. `butt`：线段末端以方形结束

2. `round`：线段末端以圆形结束

3. `square`：线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域。

   ```js
   var lineCaps = ["butt", "round", "square"];
    
   for (var i = 0; i < 3; i++){
       ctx.beginPath();
       ctx.moveTo(20 + 30 * i, 30);
       ctx.lineTo(20 + 30 * i, 100);
       ctx.lineWidth = 20;
       ctx.lineCap = lineCaps[i];
       ctx.stroke();
   }
    
   ctx.beginPath();
   ctx.moveTo(0, 30);
   ctx.lineTo(300, 30);
    
   ctx.moveTo(0, 100);
   ctx.lineTo(300, 100)
    
   ctx.strokeStyle = "red";
   ctx.lineWidth = 1;
   ctx.stroke();
   ```

   ![](https://www.runoob.com/wp-content/uploads/2018/12/3380216230-5b74dd8e97e85_articlex.png)

   ### 3\. lineJoin = type

   同一个 path 内，设定线条与线条间接合处的样式。

   共有 3 个值 `round`, `bevel` 和 `miter`：

   1. `round` 通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状。 圆角的半径是线段的宽度。

   2. `bevel` 在相连部分的末端填充一个额外的以三角形为底的区域， 每个部分都有各自独立的矩形拐角。

   3. `miter`(默认) 通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域。

      ```js
      function draw(){
          var canvas = document.getElementById('tutorial');
          if (!canvas.getContext) return;
          var ctx = canvas.getContext("2d");
       
          var lineJoin = ['round', 'bevel', 'miter'];
          ctx.lineWidth = 20;
       
          for (var i = 0; i < lineJoin.length; i++){
              ctx.lineJoin = lineJoin[i];
              ctx.beginPath();
              ctx.moveTo(50, 50 + i * 50);
              ctx.lineTo(100, 100 + i * 50);
              ctx.lineTo(150, 50 + i * 50);
              ctx.lineTo(200, 100 + i * 50);
              ctx.lineTo(250, 50 + i * 50);
              ctx.stroke();
          }
       
      }
      draw();
      ```

      

   ![](https://www.runoob.com/wp-content/uploads/2018/12/1584506777-5b74dd8e82768_articlex.png)

   ### 4\. 虚线

   用 `setLineDash` 方法和 `lineDashOffset` 属性来制定虚线样式。 `setLineDash` 方法接受一个数组，来指定线段与间隙的交替；`lineDashOffset`属性设置起始偏移量。

   ```js
   function draw(){
       var canvas = document.getElementById('tutorial');
       if (!canvas.getContext) return;
       var ctx = canvas.getContext("2d");
    
       ctx.setLineDash([20, 5]);  // [实线长度, 间隙长度]
       ctx.lineDashOffset = -0;
       ctx.strokeRect(50, 50, 210, 210);
   }
   draw();
   ```

   ![](https://www.runoob.com/wp-content/uploads/2018/12/2805401035-5b74dd8e6833c_articlex.png)

   **备注**： getLineDash() 返回一个包含当前虚线样式，长度为非负偶数的数组。

   ___

   ## 六、绘制文本

   ### 绘制文本的两个方法

   canvas 提供了两种方法来渲染文本:

   1. `fillText(text, x, y [, maxWidth])` 在指定的 (x,y) 位置填充指定的文本，绘制的最大宽度是可选的。

   2. `strokeText(text, x, y [, maxWidth])` 在指定的 (x,y) 位置绘制文本边框，绘制的最大宽度是可选的。

      ```js
      var ctx;
      function draw(){
          var canvas = document.getElementById('tutorial');
          if (!canvas.getContext) return;
          ctx = canvas.getContext("2d");
          ctx.font = "100px sans-serif"
          ctx.fillText("天若有情", 10, 100);
          ctx.strokeText("天若有情", 10, 200)
      }
      draw();
      ```

      

   ![](https://www.runoob.com/wp-content/uploads/2018/12/404304980-5b74dd8e7499e_articlex.png)

   ### 给文本添加样式

   1.  `font = value` 当前我们用来绘制文本的样式。这个字符串使用和 `CSS font` 属性相同的语法。 默认的字体是 `10px sans-serif`。

   2.  `textAlign = value` 文本对齐选项。 可选的值包括：`start`, `end`, `left`, `right` or `center`。 默认值是 `start`。

   3.  `textBaseline = value` 基线对齐选项，可选的值包括：`top`, `hanging`, `middle`, `alphabetic`, `ideographic`, `bottom`。默认值是 `alphabetic。`。

   4.  `direction = value` 文本方向。可能的值包括：`ltr`, `rtl`, `inherit`。默认值是 `inherit`。

   ___

   ## 七、绘制图片

    我们也可以在 `canvas` 上直接绘制图片。

   ### 7.1 由零开始创建图片

   var img = new Image(); img.src = 'myImage.png';

   脚本执行后图片开始装载。

   **绘制 `img`**

   ```
   // 参数 1：要绘制的 img  
   // 参数 2、3：绘制的 img 在 canvas 中的坐标
   ctx.drawImage(img,0,0); 
   ```

   **注意**：考虑到图片是从网络加载，如果 `drawImage` 的时候图片还没有完全加载完成，则什么都不做，个别浏览器会抛异常。所以我们应该保证在 `img` 绘制完成之后再 `drawImage`。

   ```
   var img = new Image();   // 创建img元素
   img.onload = function(){
       ctx.drawImage(img, 0, 0)
   }
   img.src = 'myImage.png'; // 设置图片源地址
   ```

   

   ### 7.2 绘制 `img` 标签元素中的图片

   `img` 可以 `new` 也可以来源于我们页面的 `<img>`标签。

   ```js
   <img src="./美女.jpg" alt="" width="300"><br>
   <canvas id="tutorial" width="600" height="400"></canvas>
   function draw(){
       var canvas = document.getElementById('tutorial');
       if (!canvas.getContext) return;
       var ctx = canvas.getContext("2d");
       var img = document.querySelector("img");
       ctx.drawImage(img, 0, 0);
   }
   document.querySelector("img").onclick = function (){
       draw();
   }
   ```

   第一张图片就是页面中的 `<img>` 标签：

   ![](https://www.runoob.com/wp-content/uploads/2018/12/2255709523-5b74dd8eb033e_articlex.png)

   ### 7.3 缩放图片

   `drawImage()` 也可以再添加两个参数：

   ```
   drawImage(image, x, y, width, height)
   ```

   这个方法多了 2 个参数：`width` 和 `height`，这两个参数用来控制 当像 canvas 画入时应该缩放的大小。

   ```
   ctx.drawImage(img, 0, 0, 400, 200)
   ```

   ![](https://www.runoob.com/wp-content/uploads/2018/12/327614951-5b74dd8e71ab1_articlex.png)

   ### 7.4 切片(slice)

   ```
   drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
   ```

   第一个参数和其它的是相同的，都是一个图像或者另一个 canvas 的引用。

   其他 8 个参数：

   前 4 个是定义图像源的切片位置和大小，后 4 个则是定义切片的目标显示位置和大小。

   ![](https://www.runoob.com/wp-content/uploads/2018/12/2106688680-54566fa3d81dc_articlex.jpeg)

   ___

   ## 八、状态的保存和恢复

   `Saving and restoring state` 是绘制复杂图形时必不可少的操作。

   `save()` 和 `restore()`

   `save` 和 `restore` 方法是用来保存和恢复 `canvas` 状态的，都没有参数。

   `Canvas` 的状态就是当前画面应用的所有样式和变形的一个快照。

   1、关于 save() ：Canvas状态存储在栈中，每当save()方法被调用后，当前的状态就被推送到栈中保存。

   一个绘画状态包括：

   - 当前应用的变形（即移动，旋转和缩放）

   - `strokeStyle`, `fillStyle`, `globalAlpha`, `lineWidth`, `lineCap`, `lineJoin`, `miterLimit`, `shadowOffsetX`, `shadowOffsetY`, `shadowBlur`, `shadowColor`, `globalCompositeOperation 的值`

   - 当前的裁切路径（`clipping path`）

       

     可以调用任意多次 `save`方法(类似数组的 `push()`)。

   **可以调用任意多次 `save`方法**(类似数组的`push()`)。

   2、关于restore()：每一次调用 restore 方法，上一个保存的状态就从栈中弹出，所有设定都恢复(类似数组的 `pop()`)。

   ```js
   var ctx;
   function draw(){
       var canvas = document.getElementById('tutorial');
       if (!canvas.getContext) return;
       var ctx = canvas.getContext("2d");
    
       ctx.fillRect(0, 0, 150, 150);   // 使用默认设置绘制一个矩形
       ctx.save();                  // 保存默认状态
    
       ctx.fillStyle = 'red'       // 在原有配置基础上对颜色做改变
       ctx.fillRect(15, 15, 120, 120); // 使用新的设置绘制一个矩形
    
       ctx.save();                  // 保存当前状态
       ctx.fillStyle = '#FFF'       // 再次改变颜色配置
       ctx.fillRect(30, 30, 90, 90);   // 使用新的配置绘制一个矩形
    
       ctx.restore();               // 重新加载之前的颜色状态
       ctx.fillRect(45, 45, 60, 60);   // 使用上一次的配置绘制一个矩形
    
       ctx.restore();               // 加载默认颜色配置
       ctx.fillRect(60, 60, 30, 30);   // 使用加载的配置绘制一个矩形
   }
   draw();
   ```

   

   ___

   ## 九、变形

   ### 9.1 translate

   `translate(x, y)`

   用来移动 `canvas` 的**原点**到指定的位置

   `translate` 方法接受两个参数。`x` 是左右偏移量，`y` 是上下偏移量，如右图所示。

   在做变形之前先保存状态是一个良好的习惯。大多数情况下，调用 `restore` 方法比手动恢复原先的状态要简单得多。又如果你是在一个循环中做位移但没有保存和恢复 `canvas` 的状态，很可能到最后会发现怎么有些东西不见了，那是因为它很可能已经超出 `canvas` 范围以外了。

    注意：`translate` 移动的是 `canvas` 的坐标原点(坐标变换)。

   ![](https://www.runoob.com/wp-content/uploads/2018/12/829832336-5b74dd8e3ad9a_articlex.png)

   ```js
   var ctx;
   function draw(){
       var canvas = document.getElementById('tutorial1');
       if (!canvas.getContext) return;
       var ctx = canvas.getContext("2d");
       ctx.save(); //保存坐原点平移之前的状态
       ctx.translate(100, 100);
       ctx.strokeRect(0, 0, 100, 100)
       ctx.restore(); //恢复到最初状态
       ctx.translate(220, 220);
       ctx.fillRect(0, 0, 100, 100)
   }
   draw();
   ```

   ![](https://www.runoob.com/wp-content/uploads/2018/12/1230266743-5b74dd8e3b0ce_articlex.png)

   ### 9.2 rotate

   ```js
   rotate(angle)
   ```

   

   旋转坐标轴。

   

   这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。

    旋转的中心是坐标原点。

   ![](https://www.runoob.com/wp-content/uploads/2018/12/3322150878-5b74dd8e2b6a4_articlex.png)

   ```js
   var ctx;
   function draw(){
     var canvas = document.getElementById('tutorial1');
     if (!canvas.getContext) return;
     var ctx = canvas.getContext("2d");
    
     ctx.fillStyle = "red";
     ctx.save();
    
     ctx.translate(100, 100);
     ctx.rotate(Math.PI / 180 * 45);
     ctx.fillStyle = "blue";
     ctx.fillRect(0, 0, 100, 100);
     ctx.restore();
    
     ctx.save();
     ctx.translate(0, 0);
     ctx.fillRect(0, 0, 50, 50)
     ctx.restore();
   }
   draw();
   ```

   ![](https://www.runoob.com/wp-content/uploads/2018/12/1819968878-5b74dd8e1e770_articlex.png)

   ### 9.3 scale

   ```
   scale(x, y)
   ```

   我们用它来增减图形在 `canvas` 中的像素数目，对形状，位图进行缩小或者放大。

   `scale`方法接受两个参数。`x,y` 分别是横轴和纵轴的缩放因子，它们都必须是正值。值比 1.0 小表示缩 小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有。

    默认情况下，`canvas` 的 1 单位就是 1 个像素。举例说，如果我们设置缩放因子是 0.5，1 个单位就变成对应 0.5 个像素，这样绘制出来的形状就会是原先的一半。同理，设置为 2.0 时，1 个单位就对应变成了 2 像素，绘制的结果就是图形放大了 2 倍。

   ### 9.4 transform (变形矩阵)

   ```
   transform(a, b, c, d, e, f)
   ```

   ![](https://www.runoob.com/wp-content/uploads/2018/12/2958376259-5b74dd8e15192_articlex.png)

   -   a (m11): Horizontal scaling.
   -   b (m12): Horizontal skewing.
   -   c (m21): Vertical skewing.
   -   d (m22): Vertical scaling.
   -   e (dx): Horizontal moving.
   -   f (dy): Vertical moving.

   ```js
   var ctx;
   function draw(){
       var canvas = document.getElementById('tutorial1');
       if (!canvas.getContext) return;
       var ctx = canvas.getContext("2d");
       ctx.transform(1, 1, 0, 1, 0, 0);
       ctx.fillRect(0, 0, 100, 100);
   }
   draw();
   ```

   ![](https://www.runoob.com/wp-content/uploads/2018/12/489430190-5b74dd8e17ad2_articlex.png)

   ___

   ## 十、合成

   

   在前面的所有例子中、，我们总是将一个图形画在另一个之上，对于其他更多的情况，仅仅这样是远远不够的。比如，对合成的图形来说，绘制顺序会有限制。不过，我们可以利用 globalCompositeOperation 属性来改变这种状况。

   ```
   globalCompositeOperation = type
   ```

   ```js
   var ctx;
   function draw(){
       var canvas = document.getElementById('tutorial1');
       if (!canvas.getContext) return;
       var ctx = canvas.getContext("2d");
    
       ctx.fillStyle = "blue";
       ctx.fillRect(0, 0, 200, 200);
    
       ctx.globalCompositeOperation = "source-over"; //全局合成操作
       ctx.fillStyle = "red";
       ctx.fillRect(100, 100, 200, 200);
   }
   draw();
   ```

   **注**：下面的展示中，蓝色是原有的，红色是新的。

   type 是下面 13 种字符串值之一：

   1、这是默认设置，新图像会覆盖在原有图像。

   ![](https://www.runoob.com/wp-content/uploads/2018/12/1858023544-5b74dd8e0813d.png)

   2\. source-in

   仅仅会出现新图像与原来图像重叠的部分，其他区域都变成透明的。(包括其他的老图像区域也会透明)

   ![](https://www.runoob.com/wp-content/uploads/2018/12/2183873141-5b74dd8e02a4a_articlex.png)

   ### 3\. source-out

   仅仅显示新图像与老图像没有重叠的部分，其余部分全部透明。(老图像也不显示)

   ![](https://www.runoob.com/wp-content/uploads/2018/12/2402253130-5b74dd8dd7621_articlex.png)

   ### 4\. source-atop

   新图像仅仅显示与老图像重叠区域。老图像仍然可以显示。

   ![](https://www.runoob.com/wp-content/uploads/2018/12/1206278247-5b74dd8dd9036_articlex.png)

   ### 5\. destination-over

   新图像会在老图像的下面。

   ![](https://www.runoob.com/wp-content/uploads/2018/12/2492190378-5b74dd8dca608_articlex.png)

   ### 6\. destination-in

   仅仅新老图像重叠部分的老图像被显示，其他区域全部透明。

   ![](https://www.runoob.com/wp-content/uploads/2018/12/284693590-5b74dd8dc7f3e_articlex.png)

   ### 7\. destination-out

   仅仅老图像与新图像没有重叠的部分。 注意显示的是老图像的部分区域。

   ![](https://www.runoob.com/wp-content/uploads/2018/12/1921976761-5b74dd8daba2d_articlex.png)

   ### 8\. destination-atop

   老图像仅仅仅仅显示重叠部分，新图像会显示在老图像的下面。

   ![](https://www.runoob.com/wp-content/uploads/2018/12/4055109887-5b74dd8db283c_articlex.png)

   ### 9\. lighter

   新老图像都显示，但是重叠区域的颜色做加处理。

   ![](https://www.runoob.com/wp-content/uploads/2018/12/1200224117-5b74dd8d9453e_articlex.png)

   ### 10\. darken

   保留重叠部分最黑的像素。(每个颜色位进行比较，得到最小的)

   ```
   blue: #0000ff
   red: #ff0000
   ```

   所以重叠部分的颜色：#000000。

   ![](https://www.runoob.com/wp-content/uploads/2018/12/3835256030-5b74dd8d92ba5_articlex.png)

   ### 11\. lighten

   保证重叠部分最量的像素。(每个颜色位进行比较，得到最大的)

   ```
   blue: #0000ff
   red: #ff0000
   ```

   所以重叠部分的颜色：#ff00ff。

   ![](https://www.runoob.com/wp-content/uploads/2018/12/1617768463-5b74dd8d99843_articlex.png)

   ### 12\. xor

   重叠部分会变成透明。

   ![](https://www.runoob.com/wp-content/uploads/2018/12/2521026104-5b74dd8d6abd6_articlex.png)

   ### 13\. copy

   只有新图像会被保留，其余的全部被清除(边透明)。

   ![](https://www.runoob.com/wp-content/uploads/2018/12/2454891415-5b74dd8d67aec_articlex.png)

   ___

   ## 十一、裁剪路径

   ```
   clip()
   ```

   

   把已经创建的路径转换成裁剪路径。

   

   裁剪路径的作用是遮罩。只显示裁剪路径内的区域，裁剪路径外的区域会被隐藏。

   

   **注意：**clip() 只能遮罩在这个方法调用之后绘制的图像，如果是 clip() 方法调用之前绘制的图像，则无法实现遮罩。

   ![](https://www.runoob.com/wp-content/uploads/2018/12/2023283460-5b74dd8d67aec_articlex.png)

   ```js
   var ctx;
   function draw(){
       var canvas = document.getElementById('tutorial1');
       if (!canvas.getContext) return;
       var ctx = canvas.getContext("2d");
    
       ctx.beginPath();
       ctx.arc(20,20, 100, 0, Math.PI * 2);
       ctx.clip();
    
       ctx.fillStyle = "pink";
       ctx.fillRect(20, 20, 100,100);
   }
   draw();
   ```

   

   ___

   ## 十二、动画

   ### 动画的基本步骤

   1.  **清空 `canvas`** 再绘制每一帧动画之前，需要清空所有。清空所有最简单的做法就是 `clearRect()` 方法。

   2.  **保存 `canvas` 状态** 如果在绘制的过程中会更改 `canvas` 的状态(颜色、移动了坐标原点等),又在绘制每一帧时都是原始状态的话，则最好保存下 `canvas` 的状态

   3.  **绘制动画图形**这一步才是真正的绘制动画帧

   4.  **恢复 `canvas` 状态**如果你前面保存了 `canvas` 状态，则应该在绘制完成一帧之后恢复 `canvas` 状态。

   ## 控制动画

   我们可用通过 `canvas` 的方法或者自定义的方法把图像会知道到 `canvas` 上。正常情况，我们能看到绘制的结果是在脚本执行结束之后。例如，我们不可能在一个 `for` 循环内部完成动画。

   也就是，为了执行动画，我们需要一些可以定时执行重绘的方法。

   一般用到下面三个方法：

   1.  `setInterval()`
   2.  `setTimeout()`
   3.  `requestAnimationFrame()`

   ## 案例1：太阳系

   ```js
   let sun;
   let earth;
   let moon;
   let ctx;
   function init(){
       sun = new Image();
       earth = new Image();
       moon = new Image();
       sun.src = "sun.png";
       earth.src = "earth.png";
       moon.src = "moon.png";
    
       let canvas = document.querySelector("#solar");
       ctx = canvas.getContext("2d");
    
       sun.onload = function (){
           draw()
       }
    
   }
   init();
   function draw(){
       ctx.clearRect(0, 0, 300, 300); //清空所有的内容
       /*绘制 太阳*/
       ctx.drawImage(sun, 0, 0, 300, 300);
    
       ctx.save();
       ctx.translate(150, 150);
    
       //绘制earth轨道
       ctx.beginPath();
       ctx.strokeStyle = "rgba(255,255,0,0.5)";
       ctx.arc(0, 0, 100, 0, 2 * Math.PI)
       ctx.stroke()
    
       let time = new Date();
       //绘制地球
       ctx.rotate(2 * Math.PI / 60 * time.getSeconds() + 2 * Math.PI / 60000 * time.getMilliseconds())
       ctx.translate(100, 0);
       ctx.drawImage(earth, -12, -12)
    
       //绘制月球轨道
       ctx.beginPath();
       ctx.strokeStyle = "rgba(255,255,255,.3)";
       ctx.arc(0, 0, 40, 0, 2 * Math.PI);
       ctx.stroke();
    
       //绘制月球
       ctx.rotate(2 * Math.PI / 6 * time.getSeconds() + 2 * Math.PI / 6000 * time.getMilliseconds());
       ctx.translate(40, 0);
       ctx.drawImage(moon, -3.5, -3.5);
       ctx.restore();
    
       requestAnimationFrame(draw);
   }
   ```

   ![](https://www.runoob.com/wp-content/uploads/2018/12/796853783-5b74dd8f41e21_articlex.gif)

   ## 案例2：模拟时钟

   ```html
   <!DOCTYPE html>
   <html>
   <head>
   <meta charset="utf-8">
   <title>菜鸟教程(runoob.com)</title>
   <style>
   	body {
   		padding: 0;
   		margin: 0;
   		background-color: rgba(0, 0, 0, 0.1)
   	}
   
   	canvas {
   		display: block;
   		margin: 200px auto;
   	}
   </style>
   </head>
   <body>
   <canvas id="solar" width="300" height="300"></canvas>
   <script>
   init();
   
   function init(){
       let canvas = document.querySelector("#solar");
       let ctx = canvas.getContext("2d");
       draw(ctx);
   }
   
   function draw(ctx){
       requestAnimationFrame(function step(){
           drawDial(ctx); //绘制表盘
           drawAllHands(ctx); //绘制时分秒针
           requestAnimationFrame(step);
       });
   }
   /*绘制时分秒针*/
   function drawAllHands(ctx){
       let time = new Date();
   
       let s = time.getSeconds();
       let m = time.getMinutes();
       let h = time.getHours();
   
       let pi = Math.PI;
       let secondAngle = pi / 180 * 6 * s;  //计算出来s针的弧度
       let minuteAngle = pi / 180 * 6 * m + secondAngle / 60;  //计算出来分针的弧度
       let hourAngle = pi / 180 * 30 * h + minuteAngle / 12;  //计算出来时针的弧度
   
       drawHand(hourAngle, 60, 6, "red", ctx);  //绘制时针
       drawHand(minuteAngle, 106, 4, "green", ctx);  //绘制分针
       drawHand(secondAngle, 129, 2, "blue", ctx);  //绘制秒针
   }
   /*绘制时针、或分针、或秒针
    * 参数1：要绘制的针的角度
    * 参数2：要绘制的针的长度
    * 参数3：要绘制的针的宽度
    * 参数4：要绘制的针的颜色
    * 参数4：ctx
    * */
   function drawHand(angle, len, width, color, ctx){
       ctx.save();
       ctx.translate(150, 150); //把坐标轴的远点平移到原来的中心
       ctx.rotate(-Math.PI / 2 + angle);  //旋转坐标轴。 x轴就是针的角度
       ctx.beginPath();
       ctx.moveTo(-4, 0);
       ctx.lineTo(len, 0);  // 沿着x轴绘制针
       ctx.lineWidth = width;
       ctx.strokeStyle = color;
       ctx.lineCap = "round";
       ctx.stroke();
       ctx.closePath();
       ctx.restore();
   }
   
   /*绘制表盘*/
   function drawDial(ctx){
       let pi = Math.PI;
   
       ctx.clearRect(0, 0, 300, 300); //清除所有内容
       ctx.save();
   
       ctx.translate(150, 150); //一定坐标原点到原来的中心
       ctx.beginPath();
       ctx.arc(0, 0, 148, 0, 2 * pi); //绘制圆周
       ctx.stroke();
       ctx.closePath();
   
       for (let i = 0; i < 60; i++){//绘制刻度。
           ctx.save();
           ctx.rotate(-pi / 2 + i * pi / 30);  //旋转坐标轴。坐标轴x的正方形从 向上开始算起
           ctx.beginPath();
           ctx.moveTo(110, 0);
           ctx.lineTo(140, 0);
           ctx.lineWidth = i % 5 ? 2 : 4;
           ctx.strokeStyle = i % 5 ? "blue" : "red";
           ctx.stroke();
           ctx.closePath();
           ctx.restore();
       }
       ctx.restore();
   }
   </script>
   </body>
   </html>
   ```

   

   [尝试一下 »](https://www.runoob.com/try/try.php?filename=html5-canvas-intro3)

   ![](https://www.runoob.com/wp-content/uploads/2018/12/2372262871-5b74dd8da51e5_articlex.gif)

   

# SVG 入门指南

## SVG 简介

SVG，即可缩放矢量图形(Scalable Vector Graphics)，是一种 XML 应用，可以以一种简洁、可移植的形式表示图形信息。目前，人们对 SVG 越来越感兴趣。大多数现代浏览器都能显示 SVG 图形，并且大多数矢量绘图软件都能导出 SVG 图形。SVG 主要可以概括为以下几点：

-   SVG 指可伸缩矢量图形
-   SVG 用来定义网络的基于矢量的图形
-   SVG 使用 XML 格式定义图形
-   SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失
-   SVG 是万维网联盟的标准
-   SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体

#### SVG 的应用

1.  图表视图(echart)、地图视图(WEB-GIS)
2.  形象(AI)的全网应用
3.  UI 产品的设计
4.  SVG 动画

#### SVG 浏览器的兼容情况

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed27765d2c93b~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

#### SVG 与 Canvas 区别

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed278c08595bb~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

## 图形系统

计算机中描述图形信息的两大系统是栅格图形和矢量图形。

#### 栅格图形

在栅格图形系统中，图像被表示为图片元素或者像素的长方形数组如下图片所示。每个像素用其 RGB 颜色值或者颜色表内的索引表示。这一系列也称为 **位图**，通过以某种压缩格式存储。由于大多数现代显示设备也是栅格设备，显示图像时仅需要一个阅读器将位图解压并将它传输到屏幕上。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed27bb9749f54~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

#### 矢量图形

矢量图是基于数学的描述，如下图的多啦A梦，他的头是一条怎么样的贝塞尔曲线，它的参数是什么及用什么颜色来填充贝塞尔曲线，通过这种方式描述图片就是**矢量图形**。

想象一下在一张绘图纸上作图的过程，栅格图形的工作就像是描述哪个方格应该填充什么颜色，而矢量图形的工作则像是描述要绘制从某个点到另一个点的直线或曲线。

## 创建 SVG 图像

#### SVG 文档基本结构

如下所示，是一个 SVG 文档结构：

```
<svg width='140' height='170' xmlns='http://wwww.w3.org/2000/svg'>
  <title>Cat</title>
  <desc>Stick Figure of Cat</desc>
  <!-- 在这里绘制图像 -->
</svg>
```

根元素 `<svg>` 以像素为单位定义了整个图像的 `width` 和 `height`，还通过 `xmlns` 属性定义了 **SVG** 的命名空间。`<title>` 元素的内容可以被阅读器显示在标题栏上或者是作为鼠标指针指向图像时的提示， `<desc>` 元素允许咱们为图像定义完整的描述信息。

#### 基本形状和属性

**基本图形**

`<rect>`、`<circle>`、`<ellipse>`、`<line>`、`<polyline>`、`<polygon>`

**基本属性**

`fill`、`stroke`、`stroke-width`、`transform`

#### 基本形状 --- 圆形

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed27eb8768295~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

咱们可以通过 `<circle>` 元素来绘制猫的脸部。元素属性的中心点 `x` 坐标和 `y` 坐标以为半径。`点(0,0)` 为图像左上角。水平向右移动时 `x` 坐标增大，垂直向下移动时 `y` 坐标增大。为了避免一些误会，API 语义就很明确了，点 `(cx, cy)` 就表示圆心的位置，`r` 表示圆的半径。

绘图的颜色是表现的一部分，表现信息包含在 `style` 属性中，这里的轮廓颜色为黑色，填充颜色为 `none` 以使猫的脸部透明。

```
<svg width='140' heiight='170' xmlns='http://wwww.w3.org/2000/svg'>
  <title>Cat</title>
  <desc>Stick Figure of Cat</desc>
  <!-- 在这里绘制图像 -->
  <circle cx='70' cy='95' r='50' style='stroke:black; fill:none'></circle>
</svg>      
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed286810de3de~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

#### 指定样式的属性

接着在添加两个圆表示两个眼睛。上面的 `stroke` 与 `fill` 是写在 `style` 里面的，但是 **SVG** 也允许咱们使用单独的属性，而不用全部写在 `style` 内，如下所示：

```
<svg width='140' heiight='170' xmlns='http://wwww.w3.org/2000/svg'>
  <title>Cat</title>
  <desc>Stick Figure of Cat</desc>
  <!-- 在这里绘制图像 -->
  <circle cx='70' cy='95' r='50' style='stroke:black; fill:none'></circle>
  <circle cx='55' cy='80' r='5' stroke='black' fill='#3339933'></circle>
  <circle cx='85' cy='80' r='5' stroke='black' fill='#3339933'></circle>
</svg>
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed28862ce8167~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

#### 图形对象分组

接着使用两个 `<line>` 元素在猫的右脸上添加胡须，先看下线的示意图：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed289d6d4a4f5~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

这很好理解，就不多说了。 这里我们需要把胡须作为一个部件，并包装在分组元素 `<g>` (后面会讲)里面，然后给下 `id` ，如下所示：

```
<svg width='140' heiight='170' xmlns='http://wwww.w3.org/2000/svg'>
  <title>Cat</title>
  <desc>Stick Figure of Cat</desc>
  <!-- 在这里绘制图像 -->
  <circle cx='70' cy='95' r='50' style='stroke:black; fill:none'></circle>
  <circle cx='55' cy='80' r='5' stroke='black' fill='#3339933'></circle>
  <circle cx='85' cy='80' r='5' stroke='black' fill='#3339933'></circle>
  <g id='whiskers'>
    <line x1='75' y1='95' x2='135' y2='85' style='stroke:black'></line>
    <line x1='75' y1='95' x2='135' y2='105' style='stroke:black'></line>
  </g>
</svg>
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed28b7dba6f69~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

#### 图形对象分组

接着使用 `<use>` 复用胡须分组并将它变换(transfrom) 为左侧胡须，如下图所示，首先在 `scale` 变换中对 `x` 坐标乘以 `-1`，翻转坐标系统。这意味原始坐标系统中的点`(75, 95)` 现在位于 `(-75, 95)`。接着通过 `translate` 向左平移调整对应的位置。

```
<svg width='140' heiight='170' xmlns='http://wwww.w3.org/2000/svg'>
  <title>Cat</title>
  <desc>Stick Figure of Cat</desc>
  <!-- 在这里绘制图像 -->
  <circle cx='70' cy='95' r='50' style='stroke:black; fill:none'></circle>
  <circle cx='55' cy='80' r='5' stroke='black' fill='#3339933'></circle>
  <circle cx='85' cy='80' r='5' stroke='black' fill='#3339933'></circle>
  <g id='whiskers'>
    <line x1='75' y1='95' x2='135' y2='85' style='stroke:black'></line>
    <line x1='75' y1='95' x2='135' y2='105' style='stroke:black'></line>
  </g>
  <use xlink:href="#whiskers" transform='scale(-1 1) translate(-140 0)' ></use>
</svg>
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed28cfcc50cba~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

#### 其他基本图形

如下图所示，咱们使用 `<polyline>` 元素构建嘴和耳朵，它接受一对 `x` 和 `y` 坐标为 `points` 属性的值。你可以使用空格或者逗号分隔这些数值。

```
<svg width='140' heiight='170' xmlns='http://wwww.w3.org/2000/svg'>
  <title>Cat</title>
  <desc>Stick Figure of Cat</desc>
  <!-- 在这里绘制图像 -->
  <circle cx='70' cy='95' r='50' style='stroke:black; fill:none'></circle>
  <circle cx='55' cy='80' r='5' stroke='black' fill='#3339933'></circle>
  <circle cx='85' cy='80' r='5' stroke='black' fill='#3339933'></circle>
  <g id='whiskers'>
    <line x1='75' y1='95' x2='135' y2='85' style='stroke:black'></line>
    <line x1='75' y1='95' x2='135' y2='105' style='stroke:black'></line>
  </g>
  <use xlink:href="#whiskers" transform='scale(-1 1) translate(-140 0)' ></use>
  <!-- 耳朵 -->
  <polyline points='108 62,90 10, 70 45, 50, 10, 32, 62'
    style='stroke:black; fill:none' />
  <!-- 嘴 -->
  <polyline points='35 110,45 120, 95 120, 105, 110'
    style='stroke:black; fill:none'/>
</svg>
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed28e769acd01~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

#### 路径

所有的基本形状都是通用的 `<path>` 元素的快捷写法。接着使用 `<path>` 元素为猫添加鼻子。如下所示的代码，翻译过来就是 "移动到坐标`(75, 90)`。绘制一条到坐标`(65,90)` 的直线。然后以 `x` 半径为 `5`、`y` 半径为 `10` 绘制一个椭圆，最后回到坐标 `(75, 90)` 处"

```
<svg width='140' heiight='170' xmlns='http://wwww.w3.org/2000/svg'>
  <title>Cat</title>
  <desc>Stick Figure of Cat</desc>
  <!-- 在这里绘制图像 -->
  <circle cx='70' cy='95' r='50' style='stroke:black; fill:none'></circle>
  <circle cx='55' cy='80' r='5' stroke='black' fill='#3339933'></circle>
  <circle cx='85' cy='80' r='5' stroke='black' fill='#3339933'></circle>
  <g id='whiskers'>
    <line x1='75' y1='95' x2='135' y2='85' style='stroke:black'></line>
    <line x1='75' y1='95' x2='135' y2='105' style='stroke:black'></line>
  </g>
  <use xlink:href="#whiskers" transform='scale(-1 1) translate(-140 0)' ></use>
  <!-- 耳朵 -->
  <polyline points='108 62,90 10, 70 45, 50, 10, 32, 62'
    style='stroke:black; fill:none' />
  <!-- 嘴 -->
  <polyline points='35 110,45 120, 95 120, 105, 110'
    style='stroke:black; fill:none'/>
  <!-- 鼻子 -->
  <path d='M 75 90 L 65 90 A 5 10 0 0 0 75 90'
    style='stroke:black; fill:#ffcccc'
  />
</svg>
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed28ff8730118~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

#### 路径

由于这只是一个简单的图形，用户可能看不出这是一只猫，所以咱们可以使用 元素添加一些文本注释。在 元素中，x 和 y 属性用于指定文本的位置，如下所示：

```
<svg width='140' height='170' 
  xmlns='http://wwww.w3.org/2000/svg'
  xmlns:xlink='http://wwww.w3.org/1999/xlink'>
  <title>Cat</title>
  <desc>Stick Figure of Cat</desc>
  <!-- 在这里绘制图像 -->
  <circle cx='70' cy='95' r='50' style='stroke:black; fill:none'></circle>
  <circle cx='55' cy='80' r='5' stroke='black' fill='#3339933'></circle>
  <circle cx='85' cy='80' r='5' stroke='black' fill='#3339933'></circle>
  <g id='whiskers'>
    <line x1='75' y1='95' x2='135' y2='85' style='stroke:black'></line>
    <line x1='75' y1='95' x2='135' y2='105' style='stroke:black'></line>
  </g>
  <use xlink:href="#whiskers" transform='scale(-1 1) translate(-140 0)' ></use>
  <!-- 耳朵 -->
  <polyline points='108 62,90 10, 70 45, 50, 10, 32, 62'
    style='stroke:black; fill:none' />
  <!-- 嘴 -->
  <polyline points='35 110,45 120, 95 120, 105, 110'
    style='stroke:black; fill:none'/>
  <!-- 鼻子 -->
  <path d='M 75 90 L 65 90 A 5 10 0 0 0 75 90'
    style='stroke:black; fill:#ffcccc'
  />
  <text x="60" y="165" style='font-family:sans-serif;font-size: 14pt;
    stroke:none; fill: black;
  '>Cat</text>
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed291a099f5db~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

如果看不懂代码，没关系，后面几章节会深入这些基本及属性。

## 在网页中使用 SVG

SVG 是一种图件格式，因此可以使用与其他图像类型相同的方式包含在 HTML 页面中。具体可以采用两种方法：将图像包含在 `<img>` 元素内（当图像是页面的基本组成部分时，推荐这种方式）；或者将图像作为另一个元素的 CSS 样式属性插入(当图像主要用来装饰时，推荐这种方式)。

#### 在  元素内包含 SVG

在 `<img>` 元素内包含 SVG 图像非常简单，只需设置 `src` 指向 SVG 文件位置即可。如下:

```
<img src='cat.svg' alt=''/>
```

#### 在 CSS 中包含 SVG

可以使用 background-image 属性来显示 SVG，如果没有固有尺寸， SVG 会被缩放为元素高度和宽度的 100%，如下所示：

```
div.background-cat {
  background-image: url('cat.svg');
  background-size: 100% 100%;
}
```

#### 使用 object 标签引入 SVG （不推荐）

`<object>` 元素的 `type` 属性表示要嵌入的文件类型。这个属性应该是一个有效的网络媒体类型(通常被称为 MIME 类型)。对于 `SVG`，使用 `type='image/svg+xml'`。如下所示：

```
<object data='cat.svg' type='image/svg+xml' 
  width='100' height='100'/>
```

#### 在网页中直接使用 SVG 标签

直接引用 svg 定即可，如下所示：

```
<svg width='140' heiight='170' xmlns='http://wwww.w3.org/2000/svg'>
  <title>Cat</title>
  <desc>Stick Figure of Cat</desc>
  <!-- 在这里绘制图像 -->
  <circle cx='70' cy='95' r='50' style='stroke:black; fill:none'></circle>
</svg>    
```

## SVG 的视窗，视野和全局（世界）

**视窗**

SVG的属性`width`、`height`来控制视窗的大小，也称为`SVG`容器

**世界**

SVG里面的代码，就是对SVG世界的定义

**视野**

世界是无穷大的，视野是观察世界的一个矩形区域。如下图所示

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed294c0a9ce99~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

世界不可变，而视野是可以改变的。在SVG中，提供了`viewBox`和`preserveAspectRatio`属性来控制视野。

## 线段

SVG 可以使用 元素画出一条直线，使用只需要指定线段的起(x1, y1)止(x2, y2)点。

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed29657c76845~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

```
<svg width='140' height='170' xmlns='http://wwww.w3.org/2000/svg'>
  <line x1='0' y1='0' x2='100' y2='100' style='stroke:black'/>
</svg>
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed297600c0c86~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

## 笔画的特性

线段可以看作画面上画出来的笔画。笔画的尺寸、颜色和风格都会影响线段的表现。这些特性都可以在 `style` 属性指定。

#### stroke-width

`stroke-width` 是设置线段的粗细，如下所示：

```
<svg width='140' height='170' xmlns='http://wwww.w3.org/2000/svg'>
  <line x1='0' y1='0' x2='100' y2='100' style='stroke-width:10;stroke:black'/>
</svg>
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed298ed67cb37~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

#### 笔画的颜色和透明度

可以通过以下几种方式指定笔画颜色：

-   基本颜色关键字： aqua、black、blue、fuchsia、gray、green 等
-   由 6 位十六进制指定的颜色，形式为 `#rrggbb`，其中 `rr` 表示红色, `gg` 表示绿色, `bb` 表示蓝色，它们的范围都是 `00--ff`
-   由 3 位十六进制指定的颜色，形式为 `#rgb`，其中 `r` 表示红色，`g` 表示绿色, `b` 表示蓝色，它们的范围都是 `0-f` 。
-   通过 `rgb()` 形式指定的 `rgb` 颜色值，每个值的取值范围都是整数 `0-255` 或者百分比 `0 - 100%`
-   currentColor 关键字，表示当前元素应用的 CSS 属性 color 的值。color 是用来给 HTML 的文本设置颜色的，会被子元素继承，但对 SVG 没有直接效果。

线段都是实线，咱们也可以使用 `stroke-opacity` 来控制线的透明度，取值范围和 CSS 一样 `0.0-1.0`,来几个例子演示一下：

来几个例子演示一下：

```
<svg width='140' height='170' xmlns='http://wwww.w3.org/2000/svg'>
  <!-- 红色 -->
  <line x1='10' y1='10' x2='50' y2='10' style='stroke-width:5;stroke:red'/>
  <!-- 谈绿色 -->
  <line x1='10' y1='20' x2='50' y2='20' style='stroke-width:5;stroke:#9f9f;stroke-opacity: 0.2' />
  <!-- 橘色 -->
  <line x1='10' y1='40' x2='50' y2='40' style='stroke-width:5;stroke:rgb(255,128,64);stroke-opacity: 0.5' />
  <!-- 深紫色 -->
  <line x1='10' y1='50' x2='50' y2='50' style='stroke-width:5;stroke:rgb(60%,20%,60%);stroke-opacity: 0.8' />
</svg>
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed29b2aaa1260~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

> 如果不指定笔画颜色的话，将看不到任何线，因为 stroke 属性的默认值是 none

#### stroke-dasharray 属性

有时咱们需要点线和虚线，刚需要使用 stroke-dasharray 属性，它的值由一列数字构成，代表线的长度和空隙的长度，数字之间用逗号或空格隔开。数字的个数应该为偶数，但如果是奇数，则 SVG 会重复几次，让总数为偶数。

```
<svg width='200' height='200' xmlns='http://wwww.w3.org/2000/svg'>
  <!-- 9个像素的虚线，5个像素的空隙 -->
  <line x1='10' y1='10' x2='100' y2='10'
    style='stroke-dasharray:9, 5; stroke: black; stroke-width:2'
  />
  <!-- 5个像素的虚线，3个像素的空隙 ,9个像素的虚线，2个像素的空隙 -->
  <line x1='10' y1='30' x2='100' y2='30'
    style='stroke-dasharray:9, 5, 9, 2; stroke: black; stroke-width:2' />
  <!-- 复制奇数个数 -->
  <line x1='10' y1='50' x2='100' y2='50'
    style='stroke-dasharray:9, 3, 5; stroke: black; stroke-width:2' />
</svg>
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed29dd79e7831~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

## 矩形

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed29f2e8b317f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

矩形是最简单基本形状，只需要其左上角 `x` 和 `y` 坐标以及它的宽度(`width`)和高度(`height`)，如果想要指定圆角，可以指定 `rx`(x方向的圆角半径)，该最大值是矩形宽度的一半，同理，`ry`(y 方向的圆角半径)，该最大值是矩形高度的一半。如果只指定了 `rx` 和 `ry` 中的一个值，则认为它们相等，矩形内部还可以使用 `fill` 属性来填充颜色，默认为黑色，用 stroke 来绘制边框，默认透明。来几个例子看看。

```
<svg width='300' height='500' xmlns='http://wwww.w3.org/2000/svg'>
  <!-- 内部填充为黑色，不绘制边框 -->
  <rect x='10' y='10' width='30' height='50'/>
  <!-- 内部填充为蓝色，绘制较粗，半透明红色边框-->
  <rect x='50' y='10' width='30' height='50'
    style='fill: #0000ff;stroke: red;stroke-width: 7; stroke-opacity: .5'/>
  <!-- rx 和 ry 相等，逐渐增大-->
  <rect x='10' y='70' rx='2' ry='2' width='20' height='40' 
    style='stroke:black; fill:none'/>ry5'
  <!-- rx 和 ry 相等，逐渐增大-->
  <rect x='50' y='70' rx='5'  width='20' height='40' 
    style='stroke:black; fill:none' />
  <!-- rx 和 ry 不相等 -->
  <rect x='10' y='130' rx='10' ry='5' width='20' height='40' style='stroke:black; fill:none' />
  <rect x='50' y='130' rx='10' ry='5' width='10' height='40' style='stroke:black; fill:none' />
</svg>
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed2a09f32d6e0~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

## 圆和椭圆

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed2a2d8a6dc87~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed2a428829678~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

画一个圆，需要使用 `<circle>` 元素，并指定圆心的 `x` 和 `y` 坐标(`cx/cy`) 以及半径(`r`)。和矩形一样，不指定 fill 和 stroke 时，圆会使用黑色填充并且没有轮廓线。

```
<svg width='300' height='500' xmlns='http://wwww.w3.org/2000/svg'>
  <circle cx='30' cy='30' r='20' style='stroke:black; fill:none'/>
  <circle cx='80' cy='30' r='20' style='stroke-width:5;stroke:black; fill:none' />

  <ellipse cx='30' cy='80' rx='10' ry='20'
    style='stroke:black; fill:none'
  />
  <ellipse cx='80' cy='80' rx='20' ry='10'
    style='stroke:black; fill:none'
  />
</svg>
```

对于椭圆来说，除了指定圆心和坐标外，还需要同时指定 `x` 方向的半径和 `y` 方向的半径，属性分为是 `rx` 和 `ry`。对于圆和椭圆来说，如果省略 `cx` 或者 `cy` ，则默认为 `0`，如果半径为 `0`，则不会显示图形，如果半径为负数，则会报错。来几个例子看看：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed2a592869caf~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

## 多边形

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed2a6ec3d3c50~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

咱们可以使用 `<polygon>` 元素绘制多边形，使用 `points` 属性指定一系列的 `x/y` 坐标对，并用逗号或者空格分隔**坐标个数必须是偶数**。指定坐标不需要在最后指定返回起始坐标， `<polygon>` 元素会自动回到起始坐标。来几个例子看看：

```
<svg width='200' height='200' xmlns='http://wwww.w3.org/2000/svg'>
  <!--平等四边形-->
  <polygon points='15,10 55,10 45,20 5,20'
    style='fill:red; stroke: black;'
  />
  <!--五角星-->
  <polygon points='35,37.5 37.9,46.1 46.9,46.1 39.7,51.5
    42.3,60.1 35,55 27.7,60.1 30.3,51.5 23.1,46.1 32.1,46.1'
    style='fill: #ccffcc; stroke: green;'
    />
  <!--不规则图形-->
  <polygon points='60 60, 65,72 80 60, 90,90 72,85 50,95'
    style="fill: yellow; fill-opacity:.5; stroke:black"
  />
</svg>
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed2a85562f74c~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

从上面很容易看出多边形都很容易填充，因为多边形的各边都没有交叉，很容易区分出多边形的内部区域和外部区域。但是，当多边形彼此交叉的时候，要区分哪些区域是图形内部并不容易。如下如融合所示，中间的区域是算内部还是外部呢？

```
<svg width='200' height='200' xmlns='http://wwww.w3.org/2000/svg'>
  <polygon points='48,16 16,96 96,48 0,48 80,96'
    style='fill:none; stroke: black;'
  />
</svg>
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed2a97f8c2b9f~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

SVG有两种判断某个点是否在多边形中的规则。分别对应`fill-true`属性的`nonezero`（默认值）和`evenodd`。其效果图分别如下：

```
<body style='padding: 100px 0 0 200px'>

<svg width='200' height='200' xmlns='http://wwww.w3.org/2000/svg'>
  <polygon points='48,16 16,96 96,48 0,48 80,96'
    style='fill-rule: nonzero; fill:yellow; stroke: black;'
  />

  <polygon points='148,16 116,96 196,48 100,48 180,96'
    style='fill-rule: evenodd; fill:red; stroke: black;' />
</svg>
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed2ab2c3089a6~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

## 折线

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed2accb6ed782~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

`<polyline>` 元素与 有相同的属性，不同之处在于图形并不封闭，直接来个事例看看：

```
<svg width='200' height='200' xmlns='http://wwww.w3.org/2000/svg'>
  <polyline points="5,20 20,20 25,10 35,30 45,10
    55,30 65,10 74,30 80,20 95,20"
    style="stroke:black; stroke-width:3; fill:none"
  />
</svg>
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed2ae1f24c245~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

## 总结

#### 形状元素

线段：`<line x1=" " y1=" " x2=" " y2=" " style=" "/>`

矩形：`<rect x=" "  y=" "  width=" "  height=" "  style=" "/>`

圆角矩形：`<rect x=" "  y=" "  rx=" "  ry=" "  style=" "/>`

圆形：`<circle cx=" "  cy=" "  r=" " style=" "/>`

椭圆形：`<ellipse cx=" "  cy=" "  rx=" "  ry=" "  style=" " />`

多边形：`<polygon points="      "  style=" "/>`

折线：`<polyline points="    "  style=" "/> //注意需把fill设成none`

SVG有两种判断某个点是否在多边形中的规则。分别对应`fill-true`属性的`nonezero`（默认值）和`evenodd`。其效果图分别如下：

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed2af92e02a81~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

#### 笔画特性：

| 属性              | 值                                                           |
| ----------------- | ------------------------------------------------------------ |
| stoke             | 笔画颜色，默认为none                                         |
| stroke-opacity    | 笔画透明度，默认为1.0（完全不透明），值范围：0.0~1.0         |
| stroke-dasharray  | 用一系列数字指定虚线和间隙的长度，如：stroke-dasharray:5,10,5,20 |
| stroke-linecap    | 线头尾的形状：butt（默认）、round、square                    |
| stroke-linejoin   | 图形的棱角或一系列连线的形状：miter（尖的，默认值）、round（圆的）、bevel（平的） |
| stroke-miterlimit | 相交处显示宽度与线宽的最大比例，默认为4                      |

#### 填充颜色

| 属性         | 值                                                           |
| ------------ | ------------------------------------------------------------ |
| fill         | 指定填充颜色，默认值为 black                                 |
| fill-opacity | 从 0.0 到 1.0 的数字， 0.0 表示完全透明, 1.0(默认值) 表示完全不透明 |
| fill-rule    | 属性值为 nonzero (默认值) 或 evenodd。                       |

## 在 SVG 中使用样式

在 SVG 的使用样式中 CSS 很相似，主要有 4 种，分别如下：

-   内联样式
-   内部样式表
-   外部样式表
-   表现属性

**内联样式**

用法跟 css 一样，如下所示：

```
<line style="fill:yellow;stroke:blue;stroke-width=4" x1="10" y1="10" x2="100" y2="100"/>* 
```

**内部样式表**

用法也跟 css 的类名一样，如下所示：

```
.linestyle{
stroke:red;
stroke-width:2;
}
// 那么在使用标签时，指定此样式即可：
<line class="linestyle" x1="10" y1="10" x2="100" y2="100"/>
```

**外部样式表**

跟 CSS 用法一样，把样式写在另外文件中，然后导入使用。

**表现属性**

咱们可能通过 style 属性修改样式，当然 style 里面的属性值，可以单独写，这种也叫表现属性：

```
<circle cx='10' cy='10' r='5'
  fill='red' stroke='black' stroke-width='2'/>    
```

## 分组与引用对象

虽然可以将所有的绘图看成是由一系列几乎一样的形状和线条组成的，但通常咱们还是认为大多数非抽象的艺术作品是由一系列命名对象组成的，而这些对象由形状和线条组合而成。SVG 提供了一些元素，允许咱们对元素进行这样的分组，从而使文档更加结构化以及更易理解。

#### `<g>` 元素

1）`<g>`元素会将所有子元素作为一个组合，通常还有一个唯一的id作为名称; 2）每个组合还可以拥有自己的`<title>`和`<desc>`来供基于文本的xml应用程序识别或者为视障用户提供更好的可访问性; 3）阅读器会读取`<title>`和`<desc>`元素的内容。鼠标悬停或者轻触组合内的图形时，会显示`<title>`元素内容的提示框。 4）`<g>`元素可以组合元素并可以提供一些注释，组合还可以比较嵌套;

在起始 标签中指定的所有样式会应用于组合内的所有子元素，如下面示例所示，咱们可以不用复制每个元素上的 `style='fill:none; stroke:black;'`

```
 <svg width='240' height='240' xmlns='http://wwww.w3.org/2000/svg'>
  <title>欢乐一家人</title>
  <desc>一家人在一起就是简单幸福的了</desc>

  <g id='house' style='fill:none; stroke:black'>
    <desc>房子</desc>
    <rect x='6' y='50' width='60' height='60'/>
    <polyline points='6 50, 36 9, 66 50' />
    <polyline points='36 110, 36 80, 50 80， 50 110' />
  </g>

  <g id='man' style='fill:none; stroke:green'>
    <desc>男人</desc>
    <circle cx='85' cy='56' r='10'/>
    <line x1='85' y1='66' x2='85' y2='80'/>
    <polyline points='76 104, 85 80, 94 104'/>
    <polyline points='76 70, 85 76, 94 70'/>
  </g>

  <g id='woman' style='fill:none; stroke:red'>
    <desc>女人</desc>
    <circle cx='110' cy='56' r='10'/>
    <polyline points='110 66, 110 80, 100 90, 120 90, 110 80'/>
    <line x1='104' y1='104' x2='108' y2='90'/>
    <line x1='112' y1='90' x2='116' y2='104'/>
    <polyline points='101 70, 110 76, 119 80'/>
  </g>
 </svg>
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed2b33671e7e8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

#### `<use>` 元素

1）复杂的图形中经常会出现重复元素，svg 使用`<use>`元素为定义在`<g>`元素内的组合或者任意独立图形元素提供了类似复杂黏贴的能力; 2）定义了一组`<g>`图形对象后，使用`<use>`标签再次显示它们。要指定想要的重用的组合就给`xlink:href`属性指定`URI`即可，同时还要指定`x`和`y`的位置以表示组合应该移动到的位置。 3）`<use>`元素并不限制只使用在同一个文件内的对象，还可以指定任意有效的文件或者URI.

因此为了创建另一个上面的房子和一组小人，只要把下面的代码入 `<svg>` 元素里面即可。

```
<use xlink:href='#house' x='70' y='100'/>
<use xlink:href='#woman' x='-80' y='100'/>
<use xlink:href='#man' x='-30' y='100'/>  
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed2b49f513e02~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

#### `<defs>`元素

上面例子有几个缺点：

-   复用 `man` 和 `woman` 组合时，需要知道原始图像中这些图形的位置，并以此位置作为利用的基础，而不是使用诸如 `0` 这样的简单数字

-   房子的填充和笔画颜色由原始图形建立，并且不能通过 元素覆盖，这说明咱们不能构造一行彩色的房子。

-   文档中会画出所有的三个元素 woman,man 和 house,并不能将它们单独 '存储' 下来，然后只绘制一排房子或者只绘制一组人。

`<defs>` 元素可以解决这些问题

1）SVG规范推荐我们将所有想要复用的对象放置在元素内，这样SVG阅读器进入流式环境中就能更轻松地处理数据。 2）由于组合在`<defs>`元素内，它们不会立刻绘制到屏幕上，而是作为"模板"供其他地方使用。

```
<svg width='240' height='240' viewBox='0 0 240 240' xmlns='http://wwww.w3.org/2000/svg'>
  <title>欢乐一家人</title>
  <desc>一家人在一起就是简单幸福的了</desc>
  
  <defs>
    <g id='house' style='stroke:black'>
      <desc>房子</desc>
      <rect x='0' y='41' width='60' height='60' />
      <polyline points='0 41, 30 0, 60 41' />
      <polyline points='30 110, 30 71, 44 71， 44 101' />
    </g>
    
    <g id='man' style='fill:none; stroke:green'>
      <desc>男人</desc>
      <circle cx='10' cy='10' r='10' />
      <line x1='10' y1='20' x2='10' y2='44' />
      <polyline points='1 58, 10 44, 19 58' />
      <polyline points='1 24, 10 30, 19 24' />
    </g>
    
    <g id='woman' style='fill:none; stroke:red'>
      <desc>女人</desc>
      <circle cx='10' cy='10' r='10' />
      <polyline points='10 20, 10 34, 0 44, 20 44, 10 34' />
      <line x1='4' y1='58' x2='8' y2='44' />
      <line x1='12' y1='44' x2='16' y2='58' />
      <polyline points='1 24, 10 30, 19 24' />
    </g>

    <g id='couple'>
      <desc>夫妻</desc>
      <use xlink:href='#man' x='0' y='0'/>
      <use xlink:href='#woman' x='25' y='0'/>
    </g>
  </defs>
  <use xlink:href='#house' x='0' y='0' style='fill:#cfc'/>
  <use xlink:href='#couple' x='70' y='40'/>

  <use xlink:href='#house' x='120' y='0' style='fill:#99f' />
  <use xlink:href='#couple' x='190' y='40' />
</svg>
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed2b6b859c890~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

#### `<symbol>`元素

`<symbol>`作为模板，同`<defs>`一样，内部的所有元素都不会展现在画布上，因此咱们无需把它放在 规范内。然而，咱们还是习惯将它放到 `<defs>` 中，因为 symbol 也是咱们定义的供后续使用的元素。

```
<svg width='240' height='240' viewBox='0 0 240 240' xmlns='http://wwww.w3.org/2000/svg'>
  <defs>
    <symbol id="circle" viewBox="0 0 100 100" preserveAspectRatio="xMinYMin meet">
      <circle cx="50" cy="50" r="50"></circle>
    </symbol>
    <symbol id="triangle" viewBox="0 0 100 100" preserveAspectRatio="xMaxYMax slice">
      <polygon points="0 0, 100 0, 50 100"></polygon>
    </symbol>
  </defs>
  <g stroke="grey" fill="none">
    <rect x="0" y="0" width="50" height="100"></rect>
    <rect x="100" y="0" width="50" height="100"></rect>
  </g>
  <use xlink:href="#circle" width="50" height="100" fill="red"></use>
  <use xlink:href="#triangle" width="50" height="100" fill="red" x="100"></use>
</svg>
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed2b7fd80ee80~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

## image 元素

`<image>`顾名思义里面放图片的，至于说是矢量图(vector)还是位图(raster)，都成，用起来也方便：

```
<svg width='310' height='310' viewBox='0 0 310 310' xmlns='http://wwww.w3.org/2000/svg'>
  <ellipse cx='154' cy='154' rx='150' ry='120' style='fill: #999'/>
  <ellipse cx='152' cy='152' rx='150' ry='120' style='fill: #999' />

  <image xlink:href='3.jpg' x='72' y='92'
    width='160' height='120'
  />
</svg>
```

![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/10/16eed2b97c5689d2~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)

**代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 [Fundebug](https://link.juejin.cn/?target=https%3A%2F%2Fwww.fundebug.com%2F%3Futm_source%3Dxiaozhi "https://www.fundebug.com/?utm_source=xiaozhi")。**

# WebGL高性能图形编程

> 课程目标：
>
> 掌握在页面中使用WebGL**绘制3D**展示效果的图形。

## 第1章-课程介绍

### 01-学什么

​    WebGL 解决了用户在页面中**绘制和渲染 3D 图形**的功能，且使用户通过页面与**三维图形交互成**为可能，这项技术将在下一代开发用户易用直观界面中发挥重要的作用。在接下的几年，WebGL技术将广泛地应用于电子设备的移动终端，包括**平板、手机设备**，因此，WebGL 技术的学习显的特别重要。

[WebGL能做什么？](http://127.0.0.1:5500/%E6%BC%94%E7%A4%BA%E6%A1%88%E4%BE%8B/%E6%A1%88%E4%BE%8B%E6%95%88%E6%9E%9C%E5%B1%95%E7%A4%BA.html)

### 02-技术栈

- HTML、HTML5
- JavaScript
- GLSL ES语言

### 03-课程安排

- 第1章 课程介绍
- 第2-5章 基础知识点说明
- 第6章 回顾总结

### 04-学习前提

- HTML
- CSS
- JavaScript

## 第2章-初识WebGL

### 01-手动绘制一个WebGL图形

![image-20190325140143588](https://s2.loli.net/2022/07/09/GEw51QogVDPzSvn.png)

实现的步骤：

1. 添加一个画布元素
2. 获取到画布元素的基于webgl上下文环境对象
3. 使用对象中的API实现图形绘制

### 02-使用着色器绘制一个 WebGL图形 

![image-20190325144201606](https://s2.loli.net/2022/07/09/Adz5Nt4ne1rZkoQ.png)



- WebGL 中的坐标系统：

![01-坐标](https://s2.loli.net/2022/07/09/rEwa62hCgyfTPdU.jpg)

![02-坐标](https://s2.loli.net/2022/07/09/X1chHqJNa2iS5VC.jpg)

- 着色器的介绍：

​       **着色器是**使用 OpenGL ES Shading Language 语言编写的程序，负责记录像素点的**位置**和**颜色**，并由**顶点着色器和片段着色器**组成，通过用GLSL 编写这些着色器，并将代码文本传递给WebGL执行时编译，另外，顶点着色器和片段着色器的集合我们通常称之为**着色器程序**。

​       **顶点着色器**的功能是将输入顶点从原始坐标系转换到WebGL使用的缩放空间坐标系，每个轴的坐标范围从-1.0到1.0，顶点着色器对顶点坐标进行必要的转换后，保存在名称为gl_Position的特殊变量中备用。

​      **片段着色器**在顶点着色器处理完图形的顶点后，会被要绘制的每个图形的每个像素点调用一次，它的功能是确定像素的颜色值，并保存在名称为gl_FragColor的特殊变量中，该颜色值将最终绘制到图形像素的对应位置中。   

## 第3章-绘制三角形

### 01-多点绘制的方法

![image-20190326133332093](https://s2.loli.net/2022/07/09/BiCwSGvWmz6Q9g7.png)

- 什么attribute 变量

  它是一种存储限定符，表示定义一个attribute的全局变量，这种变量的数据将由外部向顶点着色器内传输，并保存**顶点**相关的数据，只有顶点着色器才能使用它。

- 使用attribute 变量

  1. 在顶点着色器中，声明一个 attribute 变量。

  2. 将 attribute 变量赋值给 gl_Position 变量。

  3. 向 attribute 变量传输数据。

- 使用缓存区关联attribute变量

  1. 创建缓存区对象
  2. 绑定缓存区对象
  3. 将数据写入对象
  4. 将缓存区对象分配给attribute变量
  5. 开启attribute变量

### 02-绘制三角形的方法

-  实现代码




## 第4章-WebGL动画

### 01-图形的移动

![image-20190318160443253](https://s2.loli.net/2022/07/09/B6WZjvbkwJ9LfG5.png)

- 平移原理

​       为了平移一个三角形，只需要对它的每个顶点进行移动，即每个顶点加上一个分量，得到一个新的坐标：

`       X1=X+TX``Y1=Y+TY``Z1=Z+TZ`

​     只需要着色器中为顶点坐标的每个分量加上一个常量就可以实现，当然这这修改在顶点着色器上。

- uniform类型变量

  用于保存和传输一致的数据，既可用于顶点，也可用于片断。

### 02-图形的旋转

![image-20190326165438537](https://s2.loli.net/2022/07/09/NWOY2HkoT9jcg6s.png)



旋转原理

为了描述一个图形的旋转过程，必须指明以下内容：

1. 旋转轴(围绕X和Y轴旋转)

2. 旋转的方向(顺时针和逆时针)，负值是为顺时针，正值时为逆时针

3. 旋转的角度(图形经过的角度)

   ![image-20190319154151430](https://s2.loli.net/2022/07/09/FWszZQXADjTxKLk.png)

![image-20190327174612322](https://s2.loli.net/2022/07/09/ag2tspG5wCRxir1.png)



### 03-图形的缩放

![image-20190318160344389](https://s2.loli.net/2022/07/09/yfrpiCXHw3gtRn8.png)

- 缩放的原理

​       通过改变原有图形中的矩阵值，实现图形的拉大和缩下效果，因此，只需要修改原有图形的矩阵值即可。

![image-20190319154240988](https://s2.loli.net/2022/07/09/aGSmhEVOwLsT2I6.png)

- 动画实现

  需求：制作一个按旋转三角形的动画

  **屏幕刷新频率**

     图像在屏幕上更新的速度，也即屏幕上的图像每秒钟出现的次数，一般是60Hz的屏幕每16.7ms刷新一次。

  **动画原理**

    图像被刷新时，引起以连贯的、平滑的方式进行过渡变化。

  **核心方法**

  ```javascript
  requestAnimationFrame(callback)
  //执行一个动画,并在下次绘制前调用callback回调函数更新该动画
  ```

## 第5章-WebGL颜色

### 01-操作步骤介绍

![image-20190318162409517](https://s2.loli.net/2022/07/09/KHVsdWTgfx6ZemP.png)

- 颜色添加步骤

  1. 在顶点着色器中定义一个接收外部传入颜色值的属性变量a_Color和用于传输获取到的颜色值变量v_Color
  2. 在片段着色器中定义一个同一类型和名称的v_Color变量接收传顶点传入的值。
  3. 重新传入到顶点坐标和颜色值的类型化数组
  4. 将数组值传入缓存中并取出，赋值给顶点的两个变量
  5. 接收缓存值并绘制图形和颜色



- vertexAttribPointer 方法

- |   参数    | 说明                                                         |
  | :-------: | ------------------------------------------------------------ |
  | 第1个参数 | 指定待分配attribute变量的存储位置                            |
  | 第2个参数 | 指定缓存区中每个顶点的分量个数（1~4）                        |
  | 第3个参数 | 类型有，无符号字节，短整数，无符号短整数，整型，无符号整型，浮点型 |
  | 第4个参数 | 表示是否将非浮点型的数据归到[0,1][-1,1]区间                  |
  | 第5个参数 | 相邻两个顶点的字节数。默认为0                                |
  | 第6个参数 | 表示缓存区对象的偏移量（以字节为单位），attribute 变量从缓冲区中的何处开始存储 |

- 案例实现

  1. 添加画布元素，并获取webGL对象，保存在变量中。
  2. 定义着色器内容，并进行附件编译。
  3. 使用缓存对象向顶点传入多个坐标数据。
  4. 根据坐标数据绘制图像。

### 02-着色器编译与图像绘制

- 代码实现


## 第6章-回顾总结

回顾

1.如何使用画布绘制一个应webgl技术的图形

   colorColor

2.有坐标点的图形

​    一个坐标点

   着色器(顶点、片段)

   坐标体系

 3.绘制多个顶点的三角形

 4.平移，uniform

​    旋转，数学函数计算角度获取坐标值

​    缩放

5.各个顶点的绘制颜色

   步骤 

   varying 

   理解和掌握WebGL工作原理的重要基础

总结：

可绘制简单webgl图形，

动画、三维透视方法

借助一些比较简单快速上手的框架，three.js



# 图形化开发



## Threejs

### 为什么？

**webGL太难用，太复杂！**

**但是现代浏览器都支持 WebGL**

> 这样我们就不必使用 **Flash**、**Java** 等插件就能在浏览器中创建三维图形。



**Three.js 的出现完美地解决了这个矛盾。**

> 它提供一个很简单的关于 **WebGL** 特性的 **JavaScript API**，使得用户不需要详细地学习 **WebGL**，就能轻松创作出好看的三维图形样例。

> WebGL原生的api是一种非常低级的接口，而且还需要一些数学和图形学的相关技术。对于没有相关基础的人来说，入门真的很难，Three.js将入门的门槛降低了整整的一大截，对WebGL进行封装，简化我们创建三维动画场景的过程。只要你有一定的JavaScript的基础，有一定的前端经验，我坚信，用不了多长时间，三维制作会变得很简单。

**学习Three.js入门3D开发不但门槛低，而且学习曲线不会太陡，即使以后转向WebGL原生开发，也能通过Three.js学习到很多有用的知识。** 并且在webGL封装的各种库来讲，threejs现在是独领风骚。

**现在最火的微信小游戏跳一跳也是在Three.js的基础上开发出来的。**

所以，你如果要学3D，Three.js是我们必须要学的WebGL框架。



### 基本介绍

**Threejs 该项目的目的是使用默认的WebGL渲染器创建一个易于使用，轻量级的3D库。该库还在示例中提供了Canvas 2D，SVG和CSS3D渲染器。**

https://github.com/mrdoob/three.js



#### 特点

Three.js作为WebGL框架中的佼佼者，由于它的易用性和扩展性，使得它能够满足大部分的开发需求。

1. **Three.js掩盖了3D渲染的细节**：Three.js将WebGL原生API的细节抽象化，将3D场景拆解为网格、材质和光源(即它内置了图形编程常用的一些对象种类)。
2. **面向对象**：开发者可以使用上层的JavaScript对象，而不是仅仅调用JavaScript函数。
3. **功能非常丰富**：Three.js除了封装了WebGL原始API之外，Three.js还包含了许多实用的内置对象，可以方便地应用于游戏开发、动画制作、幻灯片制作、髙分辨率模型和一些特殊的视觉效果制作。
4. **速度很快**：Three.js采用了3D图形最佳实践来保证在不失可用性的前提下，保持极高的性能。
   支持交互：WebGL本身并不提供拾取（picking)功能（即是否知道鼠标正处于某个物体上）。而Three.js则固化了拾取支持，这就使得你可以轻松为你的应用添加交互功能。
5. **包含数学库**：Three.js拥有一个强大易用的数学库，你可以在其中进行矩阵、投影和矢量运算。
6. **内置文件格式支持**：你可以使用流行的3D建模软件导出文本格式的文件，然后使用Three.js加载；也可以使用Three.js自己的JSON格式或二进制格式。
7. **扩展性很强**：为Three.js添加新的特性或进行自定义优化是很容易的事情。如果你需要某个特殊的数据结构，那么只需要封装到Three.js即可。



#### 缺点

1. 官网文档非常粗糙，对于新手极度不友好。
2. 国内的相关资源匮乏。
3. Three.js所有的资料都是以英文格式存在，对国内的朋友来说又提高了门槛。
4. Three.js不是游戏引擎，一些游戏相关的功能没有封装在里面，如果需要相关的功能需要进行二次开发。



#### 与Babylon.js对比

Babylon.JS是最好的JavaScript3D游戏引擎，它能创建专业级三维游戏。主要以游戏开发和易用性为主。与Three.js之间的对比： 

1. Three.js比较全面，而Babylon.js专注于游戏方面。 
2. Babylon.js提供了对碰撞检测、场景重力、面向游戏的照相机，Three.js本身不自带，需要依靠引入插件实现。 
3. 对于WebGL的封装，双方做的各有千秋，Three.js浅一些，好处是易于扩展，易于向更底层学习；Babylon.js深一些，好处是易用扩展难度大一些。 
4. Three.js的发展是依靠社区推动，出来的比较早，发展比较成熟，Babylon.js是由微软公司在2013推出，文档和社区都比较健全，国内还不怎么火。



#### PC兼容性

基本上所有的**现代**浏览器都支持 **Three.js**。

- **Firefox**：**4.0** 版本后开始支持
- **Chrome**：**9.0** 版本后开始支持
- **Safari**：**5.1** 版本后开始支持
- **Opera**：**12.00** 版本后开始支持
- **IE**：**IE11** 起才开始支持（唯一一个很长时间都不支持 **WebGL** 的浏览器）



#### 移动端兼容性

- **Android**：**Android** 原生的浏览器是不支持 **WebGL** 的。如果想在 **Android** 上运行 **WebGL**，需要安装最新的移动版本的 **Chrome**、**Firefox** 或者 **Opera**。
- **iOS**：从 **iOS8** 起就开始支持
- **Windows mobile**：从 **8.1** 版本后开始支持



#### 在线编辑器

https://threejs.org/editor/

可以通过可视化的方式导出并生成代码，也可以导入的代码在线演示。



### Hello World

前面说了这么多，准备了这么多，最后，放上我们的第一个案例吧。由此来打开学习Three.js 的大门：

```js
<!DOCTYPE html>
<html>
<head>
    <meta charset=utf-8>
    <title>我的第一个Three.js案例</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
    </style>
</head>
<body onload="init()">
<script src="https://cdn.bootcss.com/three.js/92/three.js"></script>
<script>
    //声明一些全局变量
    var renderer, camera, scene, geometry, material, mesh;

    //初始化渲染器
    function initRenderer() {
        renderer = new THREE.WebGLRenderer(); //实例化渲染器
        renderer.setSize(window.innerWidth, window.innerHeight); //设置宽和高
        document.body.appendChild(renderer.domElement); //添加到dom
    }

    //初始化场景
    function initScene() {
        scene = new THREE.Scene(); //实例化场景
    }

    //初始化相机
    function initCamera() {
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 200); //实例化相机
        camera.position.set(0, 0, 15);
    }

    //创建模型
    function initMesh() {
        geometry = new THREE.BoxGeometry( 2, 2, 2 ); //创建几何体
        material = new THREE.MeshNormalMaterial(); //创建材质

        mesh = new THREE.Mesh( geometry, material ); //创建网格
        scene.add( mesh ); //将网格添加到场景
    }

    //运行动画
    function animate() {
        requestAnimationFrame(animate); //循环调用函数

        mesh.rotation.x += 0.01; //每帧网格模型的沿x轴旋转0.01弧度
        mesh.rotation.y += 0.02; //每帧网格模型的沿y轴旋转0.02弧度

        renderer.render( scene, camera ); //渲染界面
    }

    //初始化函数，页面加载完成是调用
    function init() {
        initRenderer();
        initScene();
        initCamera();
        initMesh();

        animate();
    }
</script>
</body>
</html>

```

#### 分析

```
<body onload="init()">
```

> ready和onload的区别： ready加载完js和css就执行，onload必须加载完图片之后。

```js
//初始化函数，页面加载完成是调用
function init() {
  initRenderer();
  initScene();
  initCamera();
  initMesh();
  animate();
}
```

使用`Three.js`显示创建的内容，我们必须需要的三大件是：`渲染器，相机和场景`。相机获取到场景内显示的内容，然后再通过渲染器渲染到画布上面。

![image-20190714190138267](https://s2.loli.net/2022/07/02/TzZ4RaeXDnihBwS.png)

#### 创建渲染器

```js
function initRenderer() {
    renderer = new THREE.WebGLRenderer(); //实例化渲染器
    renderer.setSize(window.innerWidth, window.innerHeight); //设置宽和高
    document.body.appendChild(renderer.domElement); //添加到dom
}
```

>  第一行，我们实例化了一个THREE.WebGLRenderer，这是一个基于WebGL渲染的渲染器，当然，Three.js向下兼容，还有CanvasRenderer，CSS2DRenderer，CSS3DRenderer和SVGRenderer，这四个渲染器分别基于canvas2D,CSS2D，CSS3D和SVG渲染的渲染器。由于，作为3D渲染，WebGL渲染的效果最好，并且支持的功能更多，我们以后的课程也只会用到THREE.WebGLRenderer，需要使用其他渲染器时，会重点提示。

> 第二行，调用了一个设置函数`setSize`方法，这个是设置我们需要显示的窗口大小。案例我们是基于浏览器全屏显示，所以设置了浏览器窗口的宽和高。

> 第三行，`renderer.domElement`是在实例化渲染器时生成的一个`canvas`画布，渲染器渲染界面生成的内容，都将在这个画布上显示。所以，我们将这个画布添加到了dom当中，来显示渲染的内容。

#### 创建相机

```js
//初始化相机
function initCamera() {
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 200); //实例化相机
    camera.position.set(0, 0, 15);
}
```

`Three.js`里面有几个不同的相机，我们这里使用到的是`THREE.PerspectiveCamera`，这个相机的效果是模拟人眼看到的效果，就是具有透视的效果，近大远小。

> 第一行，我们实例化了一个透视相机，需要四个值分别是视野，宽高比，近裁面和远裁面。我们分别介绍一下这四个值：
>
> - 视野：当前相机视野的宽度，值越大，渲染出来的内容也会更多。
> - 宽高比：默认是按照画布的显示的宽高比例来设置，如果比例设置的不对，会发现渲染出来的画面有拉伸或者压缩的感觉。
> - 近裁面和远裁面：这个是设置相机可以看到的场景内容的范围，如果场景内的内容位置不在这两个值内的话，将不会被显示到渲染的画面中。

> 第二行，我们设置了相机的位置。

![image-20190714000818622](https://s2.loli.net/2022/07/02/4BL1iGORPoTVI7A.png)

> WebGL坐标系统作为3D坐标，在原来的2D坐标xy轴上面又多了一个z轴，大家注意z轴的方向，是坐标轴朝向我们的方向是正轴，我们眼看去的方向是是z轴的负方向。
> camera.position.set函数是设置当前相机的位置，函数传的三个值分别是x轴坐标，y轴坐标和z轴坐标。我们只是将相机的放到了z正轴坐标轴距离坐标原点的15的位置。相机默认的朝向是朝向0点坐标的，我们也可以设置相机的朝向，这将在后面相机介绍是，专门介绍相机的相关。

#### 创建场景

```js
//初始化场景
function initScene() {
	scene = new THREE.Scene(); //实例化场景
}
```

场景只是作为一个容器，我们将需要显示的内容都放到场景对象当中。如果我们需要将一个模型放入到场景当中，则可以使用`scene.add`方法，如：

```js
scene.add(mesh); //添加一个网格（模型）到场景
```



#### 创建第一个模型

渲染器，场景和相机都全了，是不是就能显示东西了？不能！因为场景内没有内容，即使渲染出来也是一片漆黑，所以我们需要往场景里面添加内容。接下来，我们将查看`initMesh`方法，看看如何创建一个最简单的模型：

```js
//创建模型
function initMesh() {
    geometry = new THREE.BoxGeometry( 2, 2, 2 ); //创建几何体
    material = new THREE.MeshNormalMaterial(); //创建材质

    mesh = new THREE.Mesh( geometry, material ); //创建网格
    scene.add( mesh ); //将网格添加到场景
}
```

> 第一行代码里，我们实例化了一个`THREE.BoxGeometry`立方体的几何体对象，实例化的三个传值分别代表着立方体的长度，宽度和高度。我们全部设置的相同的值，将渲染出一个标准的正立方体。

> 第二行里面，我们实例化了一个THREE.MeshNormalMaterial材质，这种材质的特点是，它会根据面的朝向不同，显示不同的颜色。

> 第三行，通过`THREE.Mesh`方法实例化创建了一个网格对象，`THREE.Mesh`实例化需要传两个值，分别是几何体对象和材质对象，才可以实例化成功。

> 第四行，添加

#### 动画

```js
function animate() {
    requestAnimationFrame(animate); //循环调用函数
	...
}

```

在循环调用的函数中，每一帧我们都让页面重新渲染相机拍摄下来的内容：

````js
renderer.render( scene, camera ); //渲染界面
````

> 渲染的`render`方法需要两个值，第一个值是场景对象，第二个值是相机对象。这意味着，你可以有多个相机和多个场景，可以通过渲染不同的场景和相机让画布上显示不同的画面。

但是，如果现在一直渲染的话，我们发现就一个立方体在那，也没有动，我们需要做的是让立方体动起来：

```
mesh.rotation.x += 0.01; //每帧网格模型的沿x轴旋转0.01弧度
mesh.rotation.y += 0.02; //每帧网格模型的沿y轴旋转0.02弧度
```

> 每一个实例化的网格对象都有一个`rotation`的值，通过设置这个值可以让立方体旋转起来。在每一帧里，我们让立方体沿x轴方向旋转0.01弧度，沿y轴旋转0.02弧度（1π弧度等于180度角度）。



#### 性能监测插件

在`Three.js`里面，遇到的最多的问题就是性能问题，所以我们需要时刻检测当前的`Three.js`的性能。现在`Three.js`常使用的一款插件叫`stats`。接下来我们看看如何将`stats`插件在`Three.js`的项目中使用：

核心指标：

- FPS: 画面每秒传输帧数。

##### 引入

```
<script src="http://www.wjceo.com/lib/js/libs/stats.min.js"></script>
```

我们需要实例化一个`stats`对象，然后把对象内生成的`dom`添加到页面当中。

```js
stats = new Stats();
document.body.appendChild(stats.dom);
```

最后一步，我们需要在`requestAnimationFrame`的回调里面进行更新每次渲染的时间：

```js
function animate() {
    requestAnimationFrame(animate); //循环调用函数
    stats.update(); //更新性能插件
		renderer.render( scene, camera ); //渲染界面
}
```





### 基本元素

#### scene场景

##### 介绍

场景是我们每个`Three.js`项目里面放置内容的容器，我们也可以拥有多个场景进行切换展示，你可以在场景内放置你的**模型**，**灯光**和**照相机**。还可以通过调整场景的位置，让场景内的所有内容都一起跟着调整位置。

##### THREE.Object3D

为了方便操作，Three.js将每个能够直接添加到场景内的对象都继承至一个基类-THREE.Object3D，以后我们将继承至这个基类的对象称为3d对象，判断一个对象是否是继承至THREE.Object3D，我们可以这么判断：

```js
obj instanceof THREE.Object3D
//继承至返回 true 否则返回false
```

![image-20190717191601592](https://s2.loli.net/2022/07/02/nYg4ISfUqzyW6Rx.png)



##### 向场景内添加一个`3d`对象：

```js
scene.add(mesh); //将网格添加到场景
```


这个方法不光能够在场景内使用，而且也可以将一个`3d`对象添加到另一个`3d`对象里面：

```js
parent.add(child);
```

##### 获取一个3d对象

```js
object3D.name = "firstObj";
scene.add(object3D);

scene.getObjectByName("firstObj"); //返回第一个匹配的3d对象
```

##### 删除一个3d对象

如果我们想隐藏一个`3d`对象，而不让它显示，可以通过设置它的`visible`的值：

```js
mesh.visible = false; //设置为false，模型将不会被渲染到场景内
```

如果一个模型不再被使用到，需要彻底删除掉，我们可以使用`remove`方法进行删除：

```js
scene.remove(mesh); //将一个模型从场景中删除
```

##### 修改位置(3种方式)

单独设置

```
mesh.position.x = 3; //将模型的位置调整到x正轴距离原点为3的位置。
mesh.position.y += 5; //将模型的y轴位置以当前的位置向上移动5个单位。
mesh.position.z -= 6;
```

一次性设置所有

```
mesh.position.set(3, 5, -6);  //直接将模型的位置设置在x轴为3，y轴为5，z轴为-6的位置
```

`Three.js`的模型的位置属性是一个`THREE.Vector3`（三维向量）的对象（后期教程会讲解相关对象），我们可以直接重新赋值一个新的对象：

```js
mesh.position = new THREE.Vector3(3, 5, -6); //上面的设置位置也可以通过这样设置。
```

##### 修改大小

单独设置

```
mesh.scale.x = 2; //模型沿x轴放大一倍
mesh.scale.y = 0.5; //模型沿y轴缩小一倍
mesh.scale.z = 1; //模型沿z轴保持不变
```

第二种是使用set方法:

```js
mesh.scale.set(2, 2, 2); //每个方向等比放大一倍
```

第三种方式，由于`scale`属性也是一个三维向量，我们可以通过赋值的方式重新修改：

```js
mesh.scale = new THREE.Vector3(2, 2, 2); //每个方向都放大一倍
```

##### 修改模型的转向

第一种方式是单独设置每个轴的旋转：

```js
mesh.rotation.x = Math.PI; //模型沿x旋转180度
mesh.rotation.y = Math.PI * 2; //模型沿y轴旋转360度，跟没旋转一样的效果。。。
mesh.rotation.z = - Math.PI / 2; //模型沿z轴逆时针旋转90du
```

第二种方式就是使用`set`方法重新赋值：

```js
mesh.rotation.set(Math.PI, 0, - Math.PI / 2); //旋转效果和第一种显示的效果相同
```

第三种方式，模型的`rotation`属性其实是一个欧拉角对象（`THREE.Euler`）欧拉角后面会讲解到，我们可以通过重新赋值一个欧拉角对象来实现旋转调整：

```js
mesh.rotation = new THREE.Euler(Math.PI, 0, - Math.PI / 2, "YZX"); 
```



#### 调式方法

有些时候，我们需要调整模型的位置或者大小什么的需要每次都去场景内进行调试，现在我推荐一种常用的插件`dat.GUI`，接下来，我们将一起看看如何使用这一款插件：

https://github.com/dataarts/dat.gui

##### 功能

- 参数调整
- 自动匹配参数类型 (滑块， checkbox, 编辑 等)
- 可以自定义函数

##### 使用

1.引入

```
<script src="https://cdn.bootcss.com/dat-gui/0.7.1/dat.gui.min.js"></script>
```

2.建一个对象，在里面设置我们需要修改的一些数据：

```
controls = {
    positionX:0,
    positionY:0,
    positionZ:0
};
```

3.实例化`dat.GUI`对象，将需要修改的配置添加对象中，并监听变化回调：

```js
gui = new dat.GUI();
gui.add(controls, "positionX", -1, 1).onChange(updatePosition);
gui.add(controls, "positionY", -1, 1).onChange(updatePosition);
gui.add(controls, "positionZ", -1, 1).onChange(updatePosition);

function updatePosition() {
    mesh.position.set(controls.positionX, controls.positionY, controls.positionZ);
}
```

这样，只要我们每次都修改对象里面的值以后，都会触发`updatePosition`回调，来更新模型的位置。



#### Geometry几何体

一个模型是由几何体`Geometry`和材质`material`组成。`Three.js`内置了很多的几何体种类，如：立方体、三棱锥、球、八面体、十二面体、二十面体等等，这一节我们将介绍一下这些类型几何体的模型创建和几何体的通用方法。

##### Geometry和BufferGeometry

当前`Three.js`内置了这两种几何体类型Geometry和BufferGeometry，**这两个几何体类型都是用于存储模型的顶点位置、面的索引、法向量、颜色、uv纹理以及一些自定义的属性。**

**它们两个的区别是**：

- Geometry
  - 使用了Three.js提供的THREE.Vector3或者THREE.Color这样的对象来存储数据
  - 易与阅读和编辑
  - 性能弱一些
  - 适合动画场景
- BufferGeometry
  - 存储数据原始
  - 不易阅读和编辑
  - **性能好**
  - 适合存储一些放入场景内不需要再额外操作的模型

##### 互转

两种几何体类型可以互转，所以，不要害怕现在使用的是那种。



BufferGeometry`转换成`Geometry

```js
//实例化一个Geometry对象
var geo = new THREE.Geometry(); 
//调用对象的fromBufferGeometry方法，并将需要转换的bufferGeometry传入
geo.fromBufferGeometry(bufferGeometry);
//geo为转换转换成的Geometry
```

Geometry`转换成`BufferGeometry

```js
//实例化一个BufferGeometry对象
var bufferGeo = new THREE.BufferGeometry(); 
//调用对象的fromGeometry方法，并将需要转换的geometry传入
bufferGeo.fromGeometry(geometry);
//bufferGeo为geometry转换成的BufferGeometry
```



##### 立方体

在`WebGL`里面，所有的模型都是通过三角形面组成。

###### 创建

```js
var geometry = new THREE.BoxGeometry( 1, 1, 1 );
var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
var cube = new THREE.Mesh( geometry, material );
scene.add( cube );
```

###### 构造函数

```js
BoxGeometry(width : 浮点类型, height : 浮点类型, depth : 浮点类型, widthSegments : 整数类型, heightSegments : 整数类型, depthSegments : 整数类型)
```

width — 沿x轴的宽度，默认值为1
height — 沿y轴的高度，默认值为1
depth — 沿z轴的深度，默认值为1
widthSegments — 可选，沿着边的宽度的分割面的数量。默认值为1
heightSegments — 可选，沿着边的高度的分割面的数量。默认值为1
depthSegments — 可选，沿着边的深度的分割面的数量。缺省值是1

**widthSegments，heightSegments，depthSegments这三个参数有点类似切西瓜，分别朝3个方向将几何体切成一块一块。**

###### 在线示意：

https://threejs.org/docs/scenes/geometry-browser.html#BoxGeometry

> 比如我们要将西瓜切成小块，必须朝三个方向切才行。

![image-20190717173516260](https://s2.loli.net/2022/07/02/A8QOJunch2b1MTm.png)

##### 圆形

**圆形是由多个三角形分段构成**，这些三角形分段围绕一个中心点延伸并且延伸到给定半径以外。

###### 创建

```js
var geometry = new THREE.CircleGeometry( 5, 32 );
var material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
var circle = new THREE.Mesh( geometry, material );
scene.add( circle );
```

###### 构造函数

```
CircleGeometry(radius : 浮点类型, segments : 整数类型, thetaStart : 浮点类型, thetaLength : 浮点类型)
```

radius — 圆的半径，默认值为1
segments — 段数（三角形），最小值为3，默认值为8
thetaStart — 第一段的起始角度，默认值为0
thetaLength — 圆形扇形的中心角，通常称为theta。默认值是2 * Pi，画出一个整圆

###### 在线示意

https://threejs.org/docs/scenes/geometry-browser.html#CircleGeometry

##### 圆锥

###### 创建

```js
var geometry = new THREE.ConeGeometry( 5, 20, 32 );
var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
var cone = new THREE.Mesh( geometry, material );
scene.add( cone );
```

###### 构造函数

```js
ConeGeometry(radius : 浮点类型, height : 浮点类型, radialSegments : 整数类型, heightSegments : 整数类型, openEnded : 布尔类型, thetaStart : 浮点类型, thetaLength : 浮点类型)
```

radius — 底部圆锥的半径，默认值为1。
height — 圆锥体的高度，默认值为1。
radialSegments — 圆锥周围的分段面数，默认值为8。
heightSegments — 沿圆锥体高度的面的行数，默认值为1。
openEnded — 圆锥体底部是是隐藏还是显示，默认值为false，显示。
thetaStart — 第一段的起始角度，默认值是0（Three.js的0度位置）。
thetaLength — 圆形扇形的中心角，通常称为theta。默认值是2 * Pi，画出一个整圆

###### 在线示意

https://threejs.org/docs/scenes/geometry-browser.html#ConeGeometry

##### 圆柱

###### 创建

```js
var geometry = new THREE.CylinderGeometry( 5, 5, 20, 32 );
var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
var cylinder = new THREE.Mesh( geometry, material );
scene.add( cylinder );
```

###### 构造函数

```
CylinderGeometry(radiusTop : 浮点类型, radiusBottom : 浮点类型, height : 浮点类型, radialSegments : 整数类型, heightSegments : 整数类型, openEnded : 布尔类型, thetaStart : 浮点类型, thetaLength : 浮点类型)
```

radiusTop — 顶部圆柱体的半径。默认值为1.
radiusBottom — 底部圆柱体的半径。默认值为1.
height — 圆柱体的高度。默认值为1.
radialSegments — 圆柱周围的分段面数。默认值为8
heightSegments — 沿圆柱体高度的面的行数。默认值为1.
openEnded — 圆柱体的两端是否显示，默认值是false，显示。
thetaStart — 第一段的起始角度，默认值是0（Three.js的0度位置）。
thetaLength — 圆形扇形的中心角，通常称为theta。默认值是2 * Pi，画出一个整圆

###### 在线示意

https://threejs.org/docs/scenes/geometry-browser.html#CylinderGeometry

##### 球

###### 创建

```js
var geometry = new THREE.SphereGeometry( 5, 32, 32 );
var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
var sphere = new THREE.Mesh( geometry, material );
scene.add( sphere );
```

###### 构造函数

```
SphereGeometry(radius : 浮点类型, widthSegments : 整数类型, heightSegments : 整数类型, phiStart : 浮点类型, phiLength : 浮点类型, thetaStart : 浮点类型, thetaLength : 浮点类型)
```

radius — 球体半径。默认值是1
widthSegments — 水平线段的数量。最小值是3，默认值是8
heightSegments — 垂直段的数量。最小值是2，默认值是6
phiStart — 指定水平渲染起始角度。默认值为0
phiLength — 指定水平渲染角度大小。默认值是Math.PI * 2
thetaStart — 指定垂直渲染起始角度。默认值为0
thetaLength — 指定垂直渲染角度大小。默认是Math.PI

###### 在线示意

https://threejs.org/docs/scenes/geometry-browser.html#SphereGeometry

##### 平面

###### 创建

```js
var geometry = new THREE.PlaneGeometry( 5, 20, 32 );
var material = new THREE.MeshBasicMaterial( {color: 0xffff00, side: THREE.DoubleSide} );
var plane = new THREE.Mesh( geometry, material );
scene.add( plane );
```

###### 构造函数

```js
PlaneGeometry(width : 浮点类型, height : 浮点类型, widthSegments : 整数类型, heightSegments : 整数类型)
```

width — 沿X轴的宽度。默认值为1
height — 沿着Y轴的高度。默认值为1
widthSegments — 宽度的分段数，可选。默认值为1
heightSegments — 高度的分段数，可选。默认值为1

###### 在线示意

https://threejs.org/docs/scenes/geometry-browser.html#PlaneGeometry

##### 圆环

###### 创建

```js
var geometry = new THREE.TorusGeometry( 10, 3, 16, 100 );
var material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
var torus = new THREE.Mesh( geometry, material );
scene.add( torus );
```

###### 构造函数

```
TorusGeometry(radius : 浮点类型, tube : 浮点类型, radialSegments : 整数类型, tubularSegments : 整数类型, arc : 浮点类型)
```

radius - 圆环的半径，从圆环的中心到管的中心。默认值为1
tube — 管的半径。默认值是0.4
radialSegments — 横向分段数，默认值是8
tubularSegments — 纵向分段数，默认值是6
arc — 绘制的弧度。默认值是Math.PI * 2，绘制整个圆环

###### 在线示意

https://threejs.org/docs/scenes/geometry-browser.html#TorusGeometry

官网演示： https://threejs.org/docs/#api/en/geometries/TubeGeometry

以上是`Three.js`内置的一些基础的几何体，`Three.js`还内置了一些其他的几何体模型（如字体几何体、拉伸几何体、车床几何体等）。



#### 材质

这一节我们讲解一下模型的表现，也就是我们看到的模型的外观——材质。
**简单的说就是物体看起来是什么质地**。材质可以看成是材料和质感的结合。在渲染程式中，它是表面各可视属性的结合，这些可视属性是指表面的色彩、纹理、光滑度、透明度、反射率、折射率、发光度等。Three.js给我们封装好了大部分的材质效果。

##### MeshBasicMaterial

这种材质是一种简单的材质，不会受到光的影响，直接看到的效果就是整个物体的颜色都是一样，没有立体的感觉。

1.初始化color

```js
var material = new THREE.MeshBasicMaterial({color:0x00ffff});
var geometry = new THREE.BoxGeometry(1, 1, 1);

var mesh = new THREE.Mesh(geometry, material);
scene.add(mesh);
```

2.set修改color

```js
var material = new THREE.MeshBasicMaterial({color:0x00ffff}); //设置初始的颜色为浅蓝色
material.color.set(0xff00ff); //将颜色修改为紫色
```

3.我们也可以直接赋值一个新的`THREE.Color`对象

```
var material = new THREE.MeshBasicMaterial({color:0x00ffff}); //设置初始的颜色为浅蓝色
material.color = new THREE.Color(0xff00ff); //将颜色修改为紫色
```

##### MeshNormalMaterial

这种材质会根据面的方向不同自动改变颜色，也是我们之前一直在用的材质。

此材质不受灯光影响。

```js
geometry = new THREE.BoxGeometry( 2, 2, 2 ); //创建几何体
material = new THREE.MeshNormalMaterial(); //创建材质

mesh = new THREE.Mesh( geometry, material ); //创建网格
scene.add( mesh ); //将网格添加到场景

```

##### LineBasicMaterial线条材质

要绘制线段，我们需要确定两个点，就是起点和终点，案例中我们使用了四个顶点创建了三条线。然后`Geometry`对象使用这组顶点配置几何体，实例化线的材质，最后使用`THREE.Line`生成线。

```js
//添加直线
var pointsArr = [
    new THREE.Vector3( -10, 0, -5 ),
    new THREE.Vector3( -5, 15, 5 ),
    new THREE.Vector3( 20, 15, -5 ),
    new THREE.Vector3( 10, 0, 5 )
];

var lineGeometry = new THREE.Geometry(); //实例化几何体
lineGeometry.setFromPoints(pointsArr); //使用当前点的属性配置几何体

var lineMaterial = new THREE.LineBasicMaterial({color:0x00ff00}); //材质

line = new THREE.Line(lineGeometry, lineMaterial);
scene.add(line);

```

**添加光**

由于`MeshBasicMaterial`不会受光的影响，即使有光也不会影响它的效果，前面我们也没有添加光。但是后面介绍的材质会受到光源的影响，在介绍之前，我们需要添加一个光源，来影响材质的显示效果。

```js
//创建灯光
function initLight() {
    var light = new THREE.DirectionalLight(0xffffff); //添加了一个白色的平行光
    light.position.set(20, 50, 50); //设置光的方向
    scene.add(light); //添加到场景

    //添加一个全局环境光
    scene.add(new THREE.AmbientLight(0x222222));
}
```

##### MeshLambertMaterial 兰伯特材质

这种材质会对光有反应，但是不会出现高光，可以模拟一些粗糙的材质的物体，比如木头或者石头。实现案例：

```js
geometry = new THREE.BoxGeometry( 2, 2, 2 ); //创建几何体
material = new THREE.MeshLambertMaterial({color:0x00ffff}); //创建材质

mesh = new THREE.Mesh( geometry, material ); //创建网格
scene.add( mesh ); //将网格添加到场景
```

##### MeshPhongMaterial 高光材质

这种材质具有高光效果，可以模拟一些光滑的物体的材质效果，比如油漆面，瓷瓦等光滑物体。实现案例：

```js
geometry = new THREE.BoxGeometry( 2, 2, 2 ); //创建几何体
material = new THREE.MeshPhongMaterial({color:0x00ffff}); //创建材质

mesh = new THREE.Mesh( geometry, material ); //创建网格
scene.add( mesh ); //将网格添加到场景

```



#### 光照

通过之前的内容，我们已经了解一个模型的创建整个过程。接下来，我们将学习如果实现在场景中添加光效和阴影效果。首先我们先介绍一下光照的创建：

##### 创建光照

在上一节，因为案例需求，我们创建过一次光照效果，所有的光照效果也都是通过这种方式创建出来。

```js
var light = new THREE.DirectionalLight(0xffffff); //添加了一个白色的平行光
```

并且还在场景中添加了一个全局光照：

```js
scene.add(new THREE.AmbientLight(0x222222));
```

不同种类的光照，通过实例化，可以接受两个传值，分别是光照颜色和光照强度。

```js
var light = new THREE.DirectionalLight(0xffffff, 1.0); //添加了一个白色的平行光
```

第二个值光照强度默认值是`1.0`，我们可以根据项目需求调整光照强度。

我们也可以动态修改光的颜色和光照强度：

```js
var light = new THREE.DirectionalLight(0xffffff); //添加了一个白色的平行光

light.color.set(0x000000); //将光照的颜色修改为黑色
light.intensity = 2.0; // 光照的强度改为默认的两倍
```

##### AmbientLight 环境全局光

环境光会照亮场景中所有的物体，在计算物体的颜色的时候，都会叠加上环境光的颜色。

```js
var light = new THREE.AmbientLight( 0x404040 ); // 创建一个灰色的环境光
scene.add( light );
```

由于环境光作用于所有的物体，所有的材质，所以环境光是没有方向的，也无法产生阴影效果。

##### DirectionalLight平行光

平行光是以特定的方向发射的光。它产生的光都是平行的状态，主要用于模拟太阳光线。
创建平行光也接受两个值，颜色和光线强度：

```js
var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 ); //创建一个颜色为纯白色并且强度为默认的一半的平行光
scene.add( directionalLight );
```

平行光除了可以动态修改光的颜色和强度外，还可以通过设置它的位置和目标位置来确定平行光的照射方向（两点确定一条直线的概念）：

```js
var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 ); 
directionalLight.color.set(0x000000);  //将光照颜色修改为黑色
directionalLight.intensity = 1.0; //将光照强度修改为默认

directionalLight.position.set(10, 10, 10); //设置平行光的位置
directionalLight.target.set(0, 0, 0); //设置当前的平行光的朝向位置
scene.add( directionalLight );
```

##### 添加阴影效果

平行光是可以产生投影效果的，下面我们来设置一下平行光如何产生阴影效果：
首先，需要设置渲染器可以渲染阴影效果：

```js
renderer.shadowMap.enabled = true; // 渲染器
```

实例化灯光时，需要设置灯光渲染阴影：

```js
directionalLight = new THREE.DirectionalLight("#ffffff");
directionalLight.castShadow = true; // 设置平行光投射投影

scene.add(directionalLight);
```

最后，我们还需要设置模型哪些需要可以产生阴影和哪些模型可以接收阴影：

```js
sphere.castShadow = true; //开启阴影
scene.add(sphere);

cube.castShadow = true; //开启阴影
scene.add(cube);

plane.receiveShadow = true; //可以接收阴影
scene.add(plane);
```

上面我们设置了球体和立方体可以产生阴影，底部的平面可以接收球和立方体产生的阴影，便可以产生下面的图片效果：

![image-20190718141005720](https://s2.loli.net/2022/07/02/5dRXD3tIFEeGcOw.png)

由于设置阴影是一项十分耗性能的工作，所以我们需要尽量设置合适的阴影渲染范围和密度。平行光阴影的实现原理是通过正交相机OrthographicCamera（将在下一节讲解相机）来通过检测当前模型，也就是directionalLight.shadow.camera就是一个正交相机，只要在这个正交相机可视范围内的可以投影的物体才可以被设置投影。并且我们可以通过设置一些相机的属性属性来实现产生阴影的范围：

```js
directionalLight.shadow.camera.near = 20; //产生阴影的最近距离
directionalLight.shadow.camera.far = 100; //产生阴影的最远距离
directionalLight.shadow.camera.left = -50; //产生阴影距离位置的最左边位置
directionalLight.shadow.camera.right = 50; //最右边
directionalLight.shadow.camera.top = 50; //最上边
directionalLight.shadow.camera.bottom = -50; //最下面

//这两个值决定生成阴影密度 默认512
directionalLight.shadow.mapSize.height = 1024;
directionalLight.shadow.mapSize.width = 1024;
```

##### PointLight 点光源

点光源就是从一个点的位置向四面八方发射出去光，一个简单的例子就是一个裸露的灯泡。
实现一个最普通的点光源很简单：

```js
var pointLight = new THREE.PointLight(0xff0000); //创建一个白色的点光源
pointLight.position.set( 50, 50, 50 );
scene.add( pointLight );
```

点光源支持四个参数配置，除了前两个颜色和光的强度外，另外两个是照射范围和衰减度：

```js
var pointLight = new THREE.PointLight(0xff0000, 1, 100, 2); //创建一个白色的点光源
pointLight.position.set( 50, 50, 50 );
scene.add( pointLight );
```

第三个参数照射范围，如果物体距离点光源超过这个距离，将不会受到点光源的影响，默认是所有的物体会受到点光源的影响。如果设置了参数，将按照第四个参数，衰减度的值来慢慢减少影响，默认是1，如果需要模拟现实中的效果，这个参数可以设置为2。

这些属性也可以通过动态修改：

```js
pointLight.color.set(0x000000); //修改光照颜色
pointLight.intensity = 0.5; //修改光的强度
pointLight.distance = 50; //修改光的照射范围
pointLight.decay = 1.0; //修改衰减度
```

**实现点光源阴影效果和实现平行光的阴影效果的设置基本一样**，而且由于点光源是散射，阴影效果会终止在点光源的影响范围内。我们可以仿照平行光的阴影实现过程进行实现，只是将平行光修改为了点光源：

```js
pointLight = new THREE.PointLight("#ffffff");
pointLight.position.set(40, 60, 10);

//告诉平行光需要开启阴影投射
pointLight.castShadow = true;

scene.add(pointLight);
```

##### SpotLight 聚光灯光源

聚光灯光源的效果也是从一个点发出光线，然后沿着一个一个圆锥体进行照射，可以模仿手电筒，带有灯罩的灯泡等效果。
实现聚光灯的案例最简单是直接设置一个颜色即可，默认照射原点位置的光照：

```js
var spotLight = new THREE.SpotLight( 0xffffff ); //创建一个白色光照
spotLight.position.set( 100, 1000, 100 );
scene.add( spotLight );
```

聚光灯光源和点光源一样，也可以设置光的强度和照射范围

```js
spotLight = new THREE.SpotLight( 0xffffff, 2.0, 100); //设置光照强度是默认的两倍,照射范围为100
```

聚光灯由于是沿圆锥体照射，我们可以设置聚光灯的这个椎体的角度来影响：

```js
spotLight = new THREE.SpotLight( 0xffffff, 2.0, 100, Math.PI/4); //设置光的照射圆锥范围为90度
```

因为聚光灯只能照射一定的区域的物体，所以会出现光亮和无法照射地方的交接，我们可以通过配置第五个值来设置交接渐变的过渡效果：

```
spotLight = new THREE.SpotLight( 0xffffff, 2.0, 100, Math.PI/4, 0.5); //设置交界过渡幅度为0.5，默认是0，没有过渡，最大值为1
```

我们也可以通过设置第六个值来设置聚光灯的衰减度，和点光源一样：

```
spotLight = new THREE.SpotLight( 0xffffff, 2.0, 100, Math.PI/4, 0.5, 2.0); // 设置衰减度为物理效果的值2.0

```

同样道理，我们也可以动态修改相关配置项：

```js
spotLight.color.set(0x000000); //修改光照颜色
spotLight.intensity = 0.5; //修改光的强度
spotLight.distance = 50; //修改光的照射范围
spotLight.angle = Math.PI/3; //修改光的照射弧度
spotLight.penumbra = 1.0; //修改交界过渡
spotLight.decay = 1.0; //修改衰减度
```

我们也可以修改聚光灯的`target`来修改光的照射方向：

```js
spotLight.target.set(0, 1, 1); //修改照射方向
```

##### 实现聚光灯阴影

实现聚光灯阴影和实现平行光和点光源的设置一样，聚光灯的设置也是将可以生成阴影设置打开，并将聚光灯添加到场景中即可：

```js
spotLight= new THREE.SpotLight("#ffffff");
spotLight.position.set(40, 60, 10);
//告诉平行光需要开启阴影投射
spotLight.castShadow = true;
scene.add(spotLight);
```

##### HemisphereLight室外光源

最后我们说一下室外光源，这个光源主要是为了模拟在户外的环境光效果，比如在蓝天绿地的户外，模型下面会显示出来绿色的环境光，而上方则会受到蓝天的影响而颜色偏蓝。
实例化室外光源支持三个参数：天空的颜色，地面的颜色，和光的强度。

```js
//添加户外光源
var hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
scene.add(hemisphereLight);
```

同样的道理，我们也可以通过配置属性实时修改：

```js
hemisphereLight.color.set(0xffffff); //将天空颜色修改为白色
hemisphereLight.groundColor.set(0x000000); //将地面颜色修改为黑色
```

我们也可以修改`position`配置项来修改渲染的方向：

```js
hemisphereLight.position.set(0, -1, 0); //默认从上往下渲染，也就是天空在上方，当前修改为了，天空颜色从下往上渲染
```



#### Camera相机

相机是`Three.js`抽象出来的一个对象，使用此对象，我们可以定义显示的内容，并且可以通过移动相机位置来显示不同的内容。 下面讲解一下`Three.js`中的相机的通用属性和常用的相机对象。

我们常用的相机正交相机(`OrthographicCamera`)和透视相机(`PerspectiveCamera`)两种相机，用于来捕获场景内显示的物体模型。它们有一些通用的属性和方法：

由于相机都是继承至THREE.Object3D对象的，所以像设置位置的position属性、rotation旋转和scale缩放属性，可以直接对相机对象设置。我们甚至还可以使用add()方法，给相机对象添加子类，移动相机它的子类也会跟随着一块移动，我们可以使用这个特性制作一些比如HUD类型的显示界面。

##### target 焦点属性和lookAt()方法

这两个方法的效果一定，都是调整相机的朝向，可以设置一个`THREE.Vector3`(三维向量)点的位置：

```js
camera.target = new THREE.Vector3(0, 0, 0);
camera.lookAt(new THREE.Vector3(0, 0, 0));
```

上面两个都是朝向了原点，我们也可以将相机的朝向改为模型网格的`position`，如果物体的位置发生了变化，相机的焦点方向也会跟随变动：

```js
var mesh = new THREE.Mesh(geometry, material);
camera.target = mesh.position;  // 小技巧
//或者
camera.lookAt(mesh.position);
```

##### OrthographicCamera 正交相机

使用正交相机`OrthographicCamera`渲染出来的场景，所有的物体和模型都按照它固有的尺寸和精度显示，一般使用在工业要求精度或者2D平面中，因为它能完整的显示物体应有的尺寸。

![image-20190718175457610](https://s2.loli.net/2022/07/02/Nd1P6FigXUhW24J.png)

上面的图片可以清晰的显示出正交相机显示的范围，它显示的内容是一个立方体结构，通过图片我们发现，只要确定`top`，`left`，`right`，`bottom`，`near`和`far`六个值，我们就能确定当前相机捕获场景的区域，在这个区域外面的内容不会被渲染，所以，我们创建相机的方法就是：

```js
new THREE.OrthographicCamera( left, right, top, bottom, near, far );
```

下面我们创建了一个显示场景中相机位置前方长宽高都为4的盒子内的物体的正交相机：

```js
var orthographicCamera = new THREE.OrthographicCamera(-2, 2, 2, -2, 0, 4);
scene.add(orthographicCamera); //一般不需要将相机放置到场景当中，如果需要添加子元素等一些特殊操作，还是需要add到场景内
```

正常情况相机显示的内容需要和窗口显示的内容同样的比例才能够显示没有被拉伸变形的效果：

```js
var frustumSize = 1000; //设置显示相机前方1000高的内容
var aspect = window.innerWidth / window.innerHeight; //计算场景的宽高比
var orthographicCamera = new THREE.OrthographicCamera( frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 1, 2000 ); //根据比例计算出left，top，right，bottom的值
```

我们也可以动态的修改正交相机的一些属性，注意修改完以后需要调用相机`updateProjectionMatrix()`方法来更新相机显存里面的内容：

```js
var frustumSize = 1000; //设置显示相机前方1000高的内容
var aspect = window.innerWidth / window.innerHeight; //计算场景的宽高比
var orthographicCamera = new THREE.OrthographicCamera(); //实例化一个空的正交相机
orthographicCamera.left = frustumSize * aspect / - 2; //设置left的值
orthographicCamera.right = frustumSize * aspect / 2; //设置right的值
orthographicCamera.top = frustumSize / 2; //设置top的值
orthographicCamera.bottom = frustumSize / - 2; //设置bottom的值
orthographicCamera.near = 1; //设置near的值
orthographicCamera.far = 2000; //设置far的值

//注意，最后一定要调用updateProjectionMatrix()方法更新
orthographicCamera.updateProjectionMatrix();
```

由于浏览器的窗口是可以随意修改，我们有时候需要监听浏览器窗口的变化，然后获取到最新的宽高比，再重新设置相关属性：

```js
var aspect = window.innerWidth / window.innerHeight; //重新获取场景的宽高比

//重新设置left right top bottom 四个值
orthographicCamera.left = frustumSize * aspect / - 2; //设置left的值
orthographicCamera.right = frustumSize * aspect / 2; //设置right的值
orthographicCamera.top = frustumSize / 2; //设置top的值
orthographicCamera.bottom = frustumSize / - 2; //设置bottom的值

//最后，记得一定要更新数据
orthographicCamera.updateProjectionMatrix();

//显示区域尺寸变了，我们也需要修改渲染器的比例
renderer.setSize(window.innerWidth, window.innerHeight);
```

##### PerspectiveCamera 透视相机

透视相机是最常用的也是模拟人眼的视角的一种相机，它所渲染生成的页面是一种近大远小的效果。

![image-20190718175812754](https://s2.loli.net/2022/07/02/O8kuSZJch23TBzD.png)

上面的图片就是一个透视相机的生成原理，我们先看看渲染的范围是如何生成的：

- 首先，我们需要确定一个fov值，这个值是用来确定相机前方的垂直视角，角度越大，我们能够查看的内容就越多。
- 然后，我们又确定了一个渲染的宽高比，这个宽高比最好设置成页面显示区域的宽高比，这样我们查看生成画面才不会出现拉伸变形的效果，这时，我们可以确定了前面生成内容的范围是一个四棱锥的区域。
- 最后，我们需要确定的就是相机渲染范围的最小值near和最大值far，注意，这两个值都是距离相机的距离，确定完数值后，相机会显示的范围就是一个近小远大的四棱柱的范围，我们能够看到的内容都是在这个范围内的。
- 通过上面的原理，我们需要通过设置fov垂直角度，aspect视角宽高比例和near最近渲染距离far最远渲染距离，就能够确定当前透视相机的渲染范围。

 下面，是一个透视相机的创建：

```js
var perspectiveCamera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );
scene.add( perspectiveCamera );
```

我们设置了前方的视角为45度，宽度和高度设置成显示窗口的宽度除以高度的比例即可，显示距离为1到1000距离以内的物体。

透视相机的属性创建完成后我们也可以根据个人需求随意修改，但是注意，相机的属性修改完成后，以后要调用`updateProjectionMatrix()`方法来更新：

```js
var perspectiveCamera = new THREE.PerspectiveCamera( 45, width / height, 1, 1000 );
scene.add( perspectiveCamera );

//下面为修改当前相机属性
perspectiveCamera.fov = 75; //修改相机的fov
perspectiveCamera.aspect = window.innerWidth/window.innerHeight; //修改相机的宽高比
perspectiveCamera.near = 100; //修改near
perspectiveCamera.far = 500; //修改far

//最后更新
perspectiveCamera.updateProjectionMatrix();

```

如果当前场景浏览器的显示窗口变动了，比如修改了浏览器的宽高后，我们需要设置场景自动更新，下面是一个常用的案例：

```js
function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight; //重新设置宽高比
    camera.updateProjectionMatrix(); //更新相机
    renderer.setSize(window.innerWidth, window.innerHeight); //更新渲染页面大小
}
window.onresize = onWindowResize;
```

##### 相机插件

下载地址： https://github.com/mrdoob/three.js/blob/master/examples/js/controls/OrbitControls.js

使用方法：

选择摄像机，并实例化

```js
function initControl() {
    control = new THREE.OrbitControls(camera, renderer.domElement);
}
```

执行init方法

```js
function init() {  // 3d三要素
    initRenderer();   // 渲染
    initScene();  // 场景
    initCamera();  // 相机

    initMesh();  // 物体

    initControl();
    animate();  // 旋转,动画
}
```

在每一帧执行update

```js
function animate() {
    requestAnimationFrame(animate); //循环调用函数

    mesh.rotation.x += 0.01; //每帧网格模型的沿x轴旋转0.01弧度  半圈是180度
    mesh.rotation.y += 0.02; //每帧网格模型的沿y轴旋转0.02弧度
    stats.update();
    control.update();
    renderer.render(scene, camera); //渲染界面
}
```





#### Points 粒子

这一节，我们将学习到`Sprite`精灵和`Points`粒子两项东西，这两种对象共同点就是我们通过相机查看它们时，始终看到的是它们的正面，它们总朝向相机。通过它们的这种特性，我们可以实现广告牌的效果，或实现更多的比如雨雪、烟雾等更加绚丽的特效。

##### Sprite 精灵

精灵由于一直正对着相机的特性，一般使用在模型的提示信息当中。通过THREE.Sprite创建生成，由于THREE.Sprite和THREE.Mesh都属于THREE.Object3D的子类，所以，我们操作模型网格的相关属性和方法大部分对于精灵都适用。和精灵一起使用的还有一个THREE.SpriteMaterial对象，它是专门配合精灵的材质。注意：**精灵没有阴影效果。**

1. 普通精灵

```js
var spriteMaterialNormal = new THREE.SpriteMaterial({color: 0x00ffff});
var spriteNormal = new THREE.Sprite(spriteMaterialNormal);
spriteNormal.position.set(-30, 10, 0); //设置位置
spriteNormal.scale.set(5, 5, 1); //设置scale进行大小设置
scene.add(spriteNormal);
```

2. 图片导入的方式

```js
var spriteMap = new THREE.TextureLoader().load(drawCanvas({text: "球", width: 64, height: 64}).toDataURL());  // 转为base64
var spriteMaterial = new THREE.SpriteMaterial({map: spriteMap, color: 0xffffff});
var sprite = new THREE.Sprite(spriteMaterial);
sprite.position.set(0, 10, 0); //设置位置
sprite.scale.set(5, 5, 1); //设置scale进行大小设置
scene.add(sprite);
```

3. canvas导入的方式

```js
var canvas = drawCanvas({text: "立方体", width: 256, height: 64});
var spriteMapCube = new THREE.Texture(canvas);
spriteMapCube.wrapS = THREE.RepeatWrapping;
spriteMapCube.wrapT = THREE.RepeatWrapping;
spriteMapCube.needsUpdate = true;

var spriteCube = new THREE.Sprite(new THREE.SpriteMaterial({map: spriteMapCube, color: 0xffffff}));
spriteCube.position.set(30, 10, -5); //设置位置
spriteCube.scale.set(20, 5, 1); //设置scale进行大小设置
spriteCube.center.set(0.5, 0); //设置位置点处于精灵的最下方中间位置
scene.add(spriteCube);
```

##### points 粒子

**粒子和精灵的效果是一样的，它们之间的区别就是如果当前场景内的精灵过多的话，就会出现性能问题**。粒子的作用就是为解决很多精灵而出现的，我们可以使用粒子去模型数量很多的效果，比如下雨，下雪等，数量很多的时候就适合使用粒子来创建，相应的，提高性能的损失就是失去了对单个精灵的操作，所有的粒子的效果都是一样。总的来说，粒子就是提高性能减少的一些自由度，而精灵就是为了自由度而损失了一些性能。

**粒子THREE.Points和精灵THREE.Sprite还有网格THREE.Mesh都属于THREE.Object3D的一个扩展**，但是粒子有一些特殊的情况就是THREE.Points是它们粒子个体的父元素，它的位置设置也是基于THREE.Points位置而定位，而修改THREE.Points的scale属性只会修改掉粒子个体的位置。下面先查看一下一个粒子的创建，创建一个粒子，需要一个含有顶点的几何体，和粒子纹理THREE.PointsMaterial创建：

```js
//球体
var sphereGeometry = new THREE.SphereGeometry(5, 24, 16); // 球
var sphereMaterial = new THREE.PointsMaterial({color: 0xff00ff});
var sphere = new THREE.Points(sphereGeometry, sphereMaterial);
scene.add(sphere);
```

> 粒子会吸附在几何体的表面

上面是一个通过球体几何体创建的一个最简单的粒子特效。
几何体使用任何几何体都可以，甚至自己生成的几何体都可以，比如创建星空的案例：

```js
var starsGeometry = new THREE.Geometry();
//生成一万个点的位置
for (var i = 0; i < 10000; i++) {
    var star = new THREE.Vector3();
    //THREE.Math.randFloatSpread 在区间内随机浮动* - 范围 / 2 *到* 范围 / 2 *内随机取值。
    star.x = THREE.Math.randFloatSpread(2000);
    star.y = THREE.Math.randFloatSpread(2000);
    star.z = THREE.Math.randFloatSpread(2000);
    starsGeometry.vertices.push(star);
}
var starsMaterial = new THREE.PointsMaterial({color: 0x888888});
var starField = new THREE.Points(starsGeometry, starsMaterial);
scene.add(starField);
```

###### THREE.PointsMaterial 粒子的纹理

如果我们需要设置粒子的样式，还是需要通过设置`THREE.PointsMaterial`属性实现：

```js
var pointsMaterial = new THREE.PointsMaterial({color: 0xff00ff}); //设置了粒子纹理的颜色
```

我们还可以通过`PointsMaterial`的`size`属性设置粒子的大小：

```js
var pointsMaterial = new THREE.PointsMaterial({color: 0xff00ff, size:4}); //粒子的尺寸改为原来的四倍
//或者直接设置属性
pointsMaterial.size = 4;
```

我们也可以给粒子设置纹理：

```js
var pointsMaterial = new THREE.PointsMaterial({color: 0xff00ff, map:texture}); //添加纹理
```

默认粒子是不受光照的影响的，我们可以设置`lights`属性为`true`，让粒子受光照影响：

```js
var pointsMaterial = new THREE.PointsMaterial({color: 0xff00ff, lights:true}); 
//或者
pointsMaterial.lights = true; //开启受光照影响
```

我们也可以设置粒子不受到距离的影响产生近大远小的效果：

```js
var pointsMaterial = new THREE.PointsMaterial({color: 0xff00ff, sizeAttenuation: false}); 
//或者
pointsMaterial.sizeAttenuation = false; //关闭粒子的显示效果受距离影响
```



### 导入模型

官方推荐我们使用的`3D`模型的格式为`glTF`，由于`glTF`专注于传输，因此它的传输和解析的速度都很快。`glTF`模型功能包括：网格，材质，纹理，蒙皮，骨骼，变形动画，骨骼动画，灯光以及相机。

模型制作工具：

- 3dmax
- SketchUp

#### json格式

一般用于官方的editor导出

这里的JSON格式指的是Three.js可以将其转换为场景的3D对象的JSON格式模型。这种格式内部一般必有的四项为：

- metadata 当前模型的相关信息以及生成的工具信息 
- geometries 存储当前模型所使用的几何体的数组
- materials 存储当前模型所使用的材质的数组
- object 当前模型的结构以及标示所应用到的材质和几何体标示
  所有的模型网格，几何体和材质都有一个固定的uuid标识符，JSON格式中都是通过uuid作为引用。

所有的模型网格，几何体和材质都有一个固定的`uuid`标识符，`JSON`格式中都是通过`uuid`作为引用。

#### 3d对象转成JSON

所有的`THREE.Object3D`对象都可以转成`JSON`字符串保存成为文件，我们不能直接将对象转成`JSON`是因为`JSON`是无法保存函数的，所以，`Three.js`给我们提供了一个`toJSON()`的方法来让我们转换为可存储的`JSON`格式。

```js
var obj = scene.toJSON(); //将整个场景的内容转换成为json对象
var obj = group.toJSON(); //将一个模型组转成json对象
var obj = mesh.toJSON(); //将一个模型网格转成json对象
var JSONStr = JSON.stringify(obj); //将json对象转换成json字符串
```

#### 使用ObjectLoader加载JSON模型

既然我们能够导入，肯定就可以导入。这里我们将使用到`Three.js`内置的对象`THREE.ObjectLoader`来加载模型：
直接加载`Three.js`生成的`JSON`对象：

```js
var obj = scene.toJSON(); //将整个场景的内容转换成为json对象

let loader = new THREE.ObjectLoader(); //实例化ObjectLoader对象
let scene = loader.parse(obj); //将json对象再转换成3D对象
```

加载外部的`JSON`文件：

```js
let loader = new THREE.ObjectLoader(); //实例化ObjectLoader对象

//加载模型，并在回调中将生成的模型对象添加到场景中
loader.load("../js/models/json/file.json", function (group) {
    scene.add(group);
});
```

#### glTF格式文件导入

`glTF`格式的3D格式文件是官方推荐的使用的格式，这种格式的文件我们可以在`sketchfab`官网下载，这是一个国外比较知名的模型网站。

loader地址：

https://github.com/mrdoob/three.js/blob/master/examples/js/loaders/GLTFLoader.js

下载地址：

https://sketchfab.com/3d-models?date=week&features=downloadable&sort_by=-likeCount

1. 首先，将`GLTFLoader`加载器插件引入到页面，插件在官方包的地址`/examples/js/loaders/`，一些文件的导入插件都在这一个文件夹内，大家有兴趣可以研究一下：

   ```js
   <script src="../js/loaders/GLTFLoader.js"></script>
   ```

2. 然后创建一个加载器：

   ```js
   var loader = new THREE.GLTFLoader();
   ```

3. 使用加载器去加载模型，并调节一下模型大小在场景内展示：

   ```js
   loader.load('../js/models/gltf/scene.gltf', function (gltf) {
       gltf.scene.scale.set(.1,.1,.1);
       scene.add(gltf.scene);
   });
   ```

> 只要碰到loader，一定要使用dev server

### 动画

动画一般可以定义两种：一种是变形动画，另一种是骨骼动画。

#### 变形动画

变形动画的实现就是通过修改当前模型的顶点位置来实现动画。就比如，一个动画需要变动十次才可以实现，那么我们就需要为当前模型的每一个顶点定义每一次所在的位置，`Three.js`通过每一次修改实现最后的一个动画的整个流程。

1. 定义模型

   ```js
   var cubeGeometry = new THREE.BoxGeometry(4, 4, 4); // 正方体
   var cubeMaterial = new THREE.MeshLambertMaterial({morphTargets: true, color: 0x00ffff}); // 材质
   
   // 创建两个影响立方体的变形目标， 动画完成的终极状态
   var cubeTarget1 = new THREE.BoxGeometry(2, 10, 2);   // 瘦高
   var cubeTarget2 = new THREE.BoxGeometry(8, 2, 8); // 矮胖
   
   // 将两个geometry的顶点放入到立方体的morphTargets里面
   cubeGeometry.morphTargets[0] = {name: 'target1', vertices: cubeTarget1.vertices}; // 设定需要变化的终极目标
   cubeGeometry.morphTargets[1] = {name: 'target2', vertices: cubeTarget2.vertices};
   cubeGeometry.computeMorphNormals(); // 告诉threejs我要进行变形动画
   
   cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
   cube.position.set(0, 10, 0);
   
   // 将立方体添加到顶点当中
   scene.add(cube);
   ```

2. 调试器绑定update

   ```js
   //声明一个保存需求修改的相关数据的对象
   gui = {
     influence1:0.01,
     influence2:0.01,
     update : function () {
       cube.morphTargetInfluences[0] = gui.influence1;  // 原生属性， 代表权重，值越大越接近变化目标
       cube.morphTargetInfluences[1] = gui.influence2;
     }
   };
   
   var datGui = new dat.GUI();
   //将设置属性添加到gui当中，gui.add(对象，属性，最小值，最大值）
   datGui.add(gui, 'influence1', 0, 1).onChange(gui.update);
   datGui.add(gui, 'influence2', 0, 1).onChange(gui.update);
   ```

   ![image-20190725232943778](https://s2.loli.net/2022/07/02/egA2I8macw57jLG.png)

#### 骨骼动画

骨骼动画是需要生成一个与模型相关的骨架，骨架中的骨骼也会存在对应关系，模型的每一个需要动画的顶点需要设置影响它的骨骼以及骨骼影响顶点的程度。骨骼动画和变形动画相比会比较复杂一些，但是它又有更多的灵活性。我们可以想象一下人体的骨骼，如果使用变形动画，需要把所有的每一次的变动都存一个顶点数组，而骨骼动画，只需要设置骨骼的相关信息，就可以实现更多的动画。

1. 首先， 我们创建了一个圆柱几何体，然后通过圆柱的几何体每一个顶点的y轴坐标来设置需要绑定的骨骼的下标和影响的程度：

   ```js
   //遍历几何体所有的顶点
   for (var i = 0; i < geometry.vertices.length; i++) {
   
       //根据顶点的位置计算出骨骼影响下标和权重
   
       var vertex = geometry.vertices[i];
       var y = (vertex.y + sizing.halfHeight);
   
       var skinIndex = Math.floor(y / sizing.segmentHeight);
       var skinWeight = (y % sizing.segmentHeight) / sizing.segmentHeight;
   
       geometry.skinIndices.push(new THREE.Vector4(skinIndex, skinIndex + 1, 0, 0));
       geometry.skinWeights.push(new THREE.Vector4(1 - skinWeight, skinWeight, 0, 0));
   
   }
   
   ```

   > 几何体的`skinIndices`属性和`skinWeights`属性就是来设置相关的绑定下标和权重（骨骼影响程度）。
   >
   > 
   >
   > Vector4 不代表任何意义,仅仅是4个float , 你需要根据你的需求 赋予这个Vetor4的含义
   > 比如 XYZ 代表坐标 ,W 代表比例, 这样 你可以用 Vector3 pos = new Vector3(X/W,Y/W,Z/W) 来控制坐标的比例
   > 你也可用W 代表透明度, XYZ来控制RPG
   > 或者也可以用W 来进行bool 判断

2. 相应的，我们需要设置一组相关的骨骼，骨骼具有嵌套关系，这样才能实现一个骨架，由于圆柱体比较简单，我们就创建一条骨骼垂直嵌套的骨骼：

   ```js
   bones = [];
   
   var prevBone = new THREE.Bone();
   bones.push(prevBone);
   prevBone.position.y = -sizing.halfHeight;
   
   for (var i = 0; i < sizing.segmentCount; i++) {
   
       var bone = new THREE.Bone();
       bone.position.y = sizing.segmentHeight;
       bones.push(bone); //添加到骨骼数组
       prevBone.add(bone); //上一个骨骼定义为父级
       prevBone = bone;
   
   }
   
   ```

3. 创建纹理时，我们还需要设置当前纹理需要受到骨骼的影响，将材质的`skinning`属性设置为`true`：

   ```js
   var lineMaterial = new THREE.MeshBasicMaterial({
       skinning: true,
       wireframe: true
   });
   ```

4. 最后，我们需要创建骨骼材质，并将模型绑定骨骼：

   ```js
   mesh = new THREE.SkinnedMesh(geometry, [material, lineMaterial]);
   var skeleton = new THREE.Skeleton(bones); //创建骨架
   mesh.add(bones[0]); //将骨骼添加到模型里面
   mesh.bind(skeleton); //模型绑定骨架
   ```

   

#### 两种动画的区别

**变形动画**主要用于精度要求高的动画，比如人物的面部表情。优点是动画表达会很到位，缺点就是扩展性不强，只能执行设置好的相关动画。

**骨骼动画**主要用于那种精度要求低，而且需要丰富多样的动画，就比如人物的走动，攻击防御等动画，我们可以通过一套骨骼，修改相应骨骼的位置的信息直接实现相应的效果。确定是没有变形动画的精度高，但是可以实现多种多样的效果。

**总结**：我们可以根据项目的需求来设置不同的动画，就比如一个人物模型，说话我们使用变形动画去实现，而肢体动作使用骨骼动画去实现。

#### 导入动画

https://sketchfab.com/3d-models?date=week&features=downloadable&sort_by=-likeCount

在Three.js的动画系统中，你可以为模型的各种属性设置动画：骨骼动画，变形动画，材质的相关属性（颜色，透明度， 是否可见）。动画属性可以设置淡入淡出效果以及各种扭曲特效。也可以单独的改变一个对象或者多个对象上的动画的影响程度和动画时间。
为了实现这些，Three.js动画系统在2015年修改为了一个类似于Unity和虚幻引擎4的架构。接下来我们了解一下这套动画系统的主要组件以及它们时如何协同工作。

1. 在模型加载成功以后，我们首先将模型创建出来，并将材质的`morphTargets`设置为ture，可以使用变形动画：

   ```js
   mesh = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({
       vertexColors: THREE.FaceColors,
       morphTargets: true
   }));
   mesh.castShadow = true;
   mesh.scale.set(0.1, 0.1, 0.1);
   scene.add(mesh);
   
   ```

   

2. 然后我们创建了一个针对于该模型的混合器：

   ```js
   mixer = new THREE.AnimationMixer(mesh);
   
   ```

   

3. 接着使用变形目标数据创建一个动画片段：

   ```js
   var clip = THREE.AnimationClip.CreateFromMorphTargetSequence('gallop', geometry.morphTargets, 30);
   
   ```

   

4. 使用混合器和动画片段创建一个动画播放器来播放：

   ```js
   var action = mixer.clipAction(clip); //创建动画播放器
   action.setDuration(1); //设置当前动画一秒为一个周期
   action.play(); //设置当前动画播放
   
   ```

   

5. 最后，我们还需要在重新绘制循环中更新混合器，进行动作更新：

   ```js
   function render() {
   
       control.update();
   
       var time = clock.getDelta();
   	//由于模型导入是异步的，所以我们再模型没有加载完之前是获取不到混合器的
       if (mixer) {
           mixer.update(time);
       }
   
       renderer.render(scene, camera);
   }
   
   ```



#### 补间动画

补间(动画)（来自 in-between）是一个概念，允许你以平滑的方式更改对象的属性。你只需告诉它哪些属性要更改，当补间结束运行时它们应该具有哪些最终值，以及这需要多长时间，补间引擎将负责计算从起始点到结束点的值。
在Three.js中，我们也有一些修改模型的位置，旋转和缩放的需求，我们无法直接在webgl中使用css3动画，所以，Tween给我们提供了一个很好的解决方案。

**我们先实现一个`Three.js`应用`Tween`的案例：**

1. 首先，创建一个`position`对象，里面存储当前立方体的位置数据：

   ```js
   var position = {x:-40, y:0, z:-30};
   ```

   

2. 然后，通过当前的对象创建一个补间`Tween`：

   ```js
   tween = new TWEEN.Tween(position);
   ```

   

3. 设置每一个属性的目标位置，并告诉`Tween`在2000毫秒内移动到目标位置：

   ```js
   tween.to({x:40, y:30, z:30}, 2000);
   ```

   

4. 我们设置`Tween`对象的每次更新的回调，在每次数据更新以后，将立方体的位置更新掉：

   ```js
   tween.onUpdate(function (pos) {
       cube.position.set(pos.x, pos.y, pos.z);
   });
   ```

   

5. `Tween`对象不会直接执行，需要我们去调用`start()`方法激活：

   ```js
   tween.start();
   ```

   

6. 想要完成整个过程，我们还需要在每帧里面调用`TWEEN.update`，来触发`Tween`对象更新位置：

   ```js
   function render() {
   
       //更新Tween
       TWEEN.update();
   
       control.update();
   
       renderer.render(scene, camera);
   }
   ```

### 性能优化建议

#### 尽量共用几何体和材质

如果你需要创建三百个简单的相同颜色的立方体模型：

```js
for (let i = 0; i < 300; i++) {
	let geometry = new THREE.BoxGeometry(10, 10, 10);
    let material = new THREE.MeshLambertMaterial({color: 0x00ffff});
    let mesh = new THREE.Mesh(geometry, material);
    //随机位置
    mesh.position.set(THREE.Math.randFloatSpread(200), THREE.Math.randFloatSpread(200), THREE.Math.randFloatSpread(200));
    group.add(mesh);
}

```

我们尽量共用相同的几何体和材质：

```js
let geometry = new THREE.BoxGeometry(10, 10, 10);
let material = new THREE.MeshLambertMaterial({color: 0x00ffff});
for (let i = 0; i < 300; i++) {
    let mesh = new THREE.Mesh(geometry, material);
    //随机位置
    mesh.position.set(THREE.Math.randFloatSpread(200), THREE.Math.randFloatSpread(200), THREE.Math.randFloatSpread(200));
    group.add(mesh);
}

```



#### 删除模型时，将材质和几何体从内存中清除

使用`remove()`将模型从场景内删除掉，大家会发现内存基本上没有怎么降低。因为几何体和材质还保存在内存当中，我们需要手动调用`dispose()`方法将其从内存中删除。

```js
//删除group
function deleteGroup(name) {
    let group = scene.getObjectByName(name);
    if (!group) return;
    //删除掉所有的模型组内的mesh
    group.traverse(function (item) {
        if (item instanceof THREE.Mesh) {
            item.geometry.dispose(); //删除几何体
            item.material.dispose(); //删除材质
        }
    });

    scene.remove(group);
}

```



#### 使用merge方法合并不需要单独操作的模型

这个方法新版本整合在了几何体上面，主要应用场景为大量几何体相同材质的模型。我们可以通过将多个几何体拼接成一个单个整体的几何体来节约性能，缺点就是将缺少对单个模型的控制。
如果在不选中combined的时候，选择redraw20000个模型的话，一般只有十几帧的帧率。但是如果选中combined，会发现渲染的帧率能够达到满帧（60帧），性能巨大提升。

merge使用方法：

```js
//合并模型，则使用merge方法合并
var geometry = new THREE.Geometry();
//merge方法将两个几何体对象或者Object3D里面的几何体对象合并,(使用对象的变换)将几何体的顶点,面,UV分别合并.
//THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead. 如果新版本用老版本的会报这个错
for(var i=0; i<20000; i++){
    var cube = addCube(); //创建了一个随机位置的几何体模型
    cube.updateMatrix(); //手动更新模型的矩阵
    geometry.merge(cube.geometry, cube.matrix); //将几何体合并
}

scene.add(new THREE.Mesh(geometry, cubeMaterial));

```



#### 在循环渲染中避免使用更新

这里的更新指的是当前的几何体、材质、纹理等发生了修改，需要`Three.js`重新更新显存的数据，具体包括：

```js
geometry.verticesNeedUpdate = true; //顶点发生了修改
geometry.elementsNeedUpdate = true; //面发生了修改
geometry.morphTargetsNeedUpdate = true; //变形目标发生了修改
geometry.uvsNeedUpdate = true; //uv映射发生了修改
geometry.normalsNeedUpdate = true; //法向发生了修改
geometry.colorsNeedUpdate = true; //顶点颜色发生的修改

material.needsUpdate = true

texture.needsUpdate = true;

```

如果它们发生更新，则将其设置为`true`，`Three.js`会通过判断，将数据重新传输到显存当中，并将配置项重新修改为`false`。这是一个很耗运行效率的过程，所以我们尽量只在需要的时候修改，不要放到`render()`方法当中循环设置。

#### 只在需要的时候渲染

如果在没有操作的时候，让循环一直渲染属于浪费资源，接下来我来带给大家一个只在需要时渲染的方法。

```js
var renderEnabled;
function animate() {

    if (renderEnabled) {
        renderer.render(scene, camera);
    }

    requestAnimationFrame(animate);
}

animate();

```

66

### 王者荣耀demo制作

![image-20190725192207759](https://s2.loli.net/2022/07/02/ZfFAa6SYQgdjyLt.png)

#### 1. 场景搭建

```js
scene = new THREE.Scene();
scene.background = new THREE.Color(0xa0a0a0);
scene.fog = new THREE.Fog(0xa0a0a0, 1000, 11000);
```

我们创建了场景，并设置了场景一个灰色的背景色。还设置了场景的雾化效果，这个雾的效果主要是针对于场景的相机的距离实现的，三个值分别是雾的颜色、雾的开始距离、完全雾化距离相机的位置。

#### 2. 创建相机

我们创建了一个与地面呈45度角并朝向原点的相机：

```js
camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 20000);
camera.position.set(0, 800, -800);
camera.lookAt(new THREE.Vector3());
```

#### 3. 创建灯光

我们创建了两个灯光：照射全局的环境光和可以产生阴影的平衡光。

```js
scene.add(new THREE.AmbientLight(0x444444));

light = new THREE.DirectionalLight(0xaaaaaa);
light.position.set(0, 200, 100);
light.lookAt(new THREE.Vector3());

light.castShadow = true;
light.shadow.camera.top = 180;
light.shadow.camera.bottom = -180;
light.shadow.camera.left = -180;
light.shadow.camera.right = 180;

//告诉平行光需要开启阴影投射
light.castShadow = true;

scene.add(light);
```

#### 4. 创建草地

我们使用平面几何体创建了一个贴有草皮贴图的材质的模型：

```js
var groundTexture = new THREE.TextureLoader().load('../images/grasslight-big.jpg');
groundTexture.wrapS = groundTexture.wrapT = THREE.RepeatWrapping;
groundTexture.repeat.set(25, 25);
groundTexture.anisotropy = 16;
var groundMaterial = new THREE.MeshLambertMaterial({map: groundTexture});
var mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(20000, 20000), groundMaterial);
mesh.rotation.x = -Math.PI / 2;
mesh.receiveShadow = true;
scene.add(mesh);
```

到这里，场景、灯光、相机、舞台都已经备齐。接下来我们将请出我们主角`naruto`登场。

#### 5. 添加人物模型

接下来主人公登场，首先我们将模型导入到场景内，注意，案例中的模型比较大，加载和处理需要一定的时间，请小伙伴们耐心等待即可：

```js
var loader = new THREE.FBXLoader();
        loader.load("../js/models/fbx/Naruto.fbx", function (mesh) {
        scene.add(mesh);
});
```

我们不单单只是将模型添加到场景，还对模型的阴影和位置做了一下调整：

```js
//设置模型的每个部位都可以投影
mesh.traverse(function (child) {
    if (child.isMesh) {
        child.castShadow = true;
        child.receiveShadow = true;
    }
});
```

调整模型的位置，站立在草地上面

```js
mesh.position.y += 110;
```

设置灯光一直照射模型：

```js
//设置光线焦点模型
light.target = mesh;
```

#### 6. 添加动画

这个模型里面含有27个骨骼动画，我们可以通过设置不同的动画，来实现一整套的动作来实现相应的比如攻击效果，移动效果等。接下来我们通过模型的数据生成一下所需的动画：

```js
actions = []; //所有的动画数组

for (var i = 0; i < mesh.animations.length; i++) {
    createAction(i);
}

function createAction(i) {
    actions[i] = mixer.clipAction(mesh.animations[i]);
    gui["action" + i] = function () {
        for (var j = 0; j < actions.length; j++) {
            if (j === i) {
                actions[j].play();
            }
            else {
                actions[j].stop();
            }
        }
    };
}

//添加暂停所有动画的按键
gui.stop = function () {
    for (var i = 0; i < actions.length; i++) {
        actions[i].stop();
    }
};
```

模型加载成功后，我们需要让模型执行一个普通的站立效果：

```js
//第24个动作是鸣人站立的动作
gui["action" + 24]();
```

#### 7. 添加操作

在案例中，我们主要添加了两种操作：模型位置移动操作和攻击效果。
操作按钮为了方便，直接使用的`dom`标签模拟出来的。
模型位置移动操作中，我们需要模型的位置的变动和模型的朝向以及修改站立动画和奔跑动画的切换。
攻击效果则是实现攻击并且根据点击速度实现一整套的攻击动作切换。

**实现位移**

在实现位置移动效果中，我们为按钮绑定了三个事件：鼠标按下，鼠标移动，鼠标抬起。
在鼠标按下时，我们获取到了当前操作圆盘的中心点的位置，让模型进入跑步动画，绑定了鼠标的移动和抬起事件。重要的是更新模型的移动方向和移动速度。

```js
dop.$(control).on("down", function (event) {
    event.preventDefault();

    //获取当前的按钮中心点
    center.x = window.innerWidth - parseFloat(dop.getFinalStyle(control, "right")) - parseFloat(dop.getFinalStyle(control, "width")) / 2;
    center.y = window.innerHeight - parseFloat(dop.getFinalStyle(control, "bottom")) - parseFloat(dop.getFinalStyle(control, "height")) / 2;

    getRadian(event);

    //鼠标按下切换跑步动作
    state.skills === 0 && gui["action" + 3]();

    //给document绑定拖拽和鼠标抬起事件
    doc.on("move", move);
    doc.on("up", up);
});

```

上面的`dop`类是一个兼容多端的事件库。
在鼠标移动回调事件中，我们更新模型的移动方向和移动速度。

```js
function move(event) {
    getRadian(event);
}
```

最后在鼠标抬起事件中，我们解绑事件，将按键复原，并停止掉模型的移动状态，将模型动画恢复到站立状态。

```js
function up() {
    doc.remove("move", move);
    doc.remove("up", up);

    //按钮复原
    bar.style.marginTop = 0;
    barWrap.style.transform = `translate(-50%, -50%) rotate(0deg)`;
    bar.style.transform = `translate(-50%, -50%) rotate(0deg)`;

    //设置移动距离为零
    characterMove(new THREE.Vector2(), 0);

    //鼠标抬起切换站立状态
    state.skills === 0 && gui["action" + 24]();
}
```

三个事件绑定完成后，我们需要将在回调中获得的值求出当前的偏转方向和移动速度：
首先我们获取一下当前鼠标的位置：

```js
if (media === "pc") {
    mouse.x = event.clientX;
    mouse.y = event.clientY;
}
else {
    mouse.x = event.touches[0].clientX;
    mouse.y = event.touches[0].clientY;
}

```

根据位置求出距离操作圆盘中心的位置，并保证最大值也不会超出圆盘的半径：

```js
let distance = center.distanceTo(mouse);
distance >= parseFloat(dop.getFinalStyle(control, "width")) / 2 && (distance = parseFloat(dop.getFinalStyle(control, "width")) / 2);
```

计算出来当前位置和中心的夹角，并修改dom的位置：

```js
//计算两点之间的夹角
mouse.x = mouse.x - center.x;
mouse.y = mouse.y - center.y;

//修改操作杆的css样式
bar.style.marginTop = `-${distance}px`;
bar.style.transform = `translate(-50%, -50%) rotate(-${(mouse.angle() / Math.PI * 180 + 90) % 360}deg)`;
barWrap.style.transform = `translate(-50%, -50%) rotate(${(mouse.angle() / Math.PI * 180 + 90) % 360}deg)`;

```

函数的最后，则调用的`characterMove`方法，将按钮数据转换成为模型实际需要移动的距离。

```js
//修改当前的移动方向和移动速度
characterMove(mouse.normalize(), distance / (parseFloat(dop.getFinalStyle(control, "width")) / 2));
```

接下来我们查看一下characterMove方法，在这个方法中，我们计算出了模型每一帧需要移动的距离。这里有一个问题，我们所谓的操作杆向前让模型移动前方，其实是相机朝向的前方。所以我们需要先求出相机的前方矢量，再通过相机的前方矢量为基础，计算出来模型实际方向。
我们首先声明了两个变量，一个是旋转矩阵，另一个是移动矢量：

```js
let direction = new THREE.Matrix4(); //当前移动的旋转矩阵
let move = new THREE.Vector3(); //当前位置移动的距离
```

在`characterMove`函数内，我们根据相机的四元数获得了旋转矩阵：

```js
//重置矩阵
direction.identity();

//通过相机的四元数获取到相机的旋转矩阵
let quaternion = camera.quaternion;
direction.makeRotationFromQuaternion(quaternion);
```

然后通过旋转矩阵和当前的操作杆的方向通过相乘计算出来实际模型移动的方向：

```js
//获取到操作杆的移动方向
move.x = vector.x;
move.y = 0;
move.z = vector.y;

//通过相机方向和操作杆获得最终角色的移动方向
move.applyMatrix4(direction);
move.normalize();

```

最后，通过比例和方向得出当前模型每一帧移动的距离，因为我们不需要修改模型y轴，所以实际上也只是修改两个轴的位置：

```js
move.x = move.x * ratio * 10;
move.z = move.z * ratio * 10;
```

我们获取到了模型的每一帧移动的距离，还需要在帧循环中调用：

```js
//如果模型添加成功，则每帧都移动角色位置
if (naruto) {
    //获取当前位置
    position.x += move.x;
    position.z += move.z;

    //修改模型位置
    naruto.position.x = position.x;
    naruto.position.z = position.z;

    //修改平衡光的位置
    light.position.x = position.x;
    light.position.z = position.z + 100;

    //修改相机位置
    camera.position.x = position.x;
    camera.position.z = position.z - 800;
}

```

当前的模型，灯光，和相机都会跟随移动，实现了，我们上面动图中的模型移动的效果

**实现攻击效果**

在实现攻击效果时，我没有只是简单的实现一个普通的攻击，而是直接实现一套连招。
这一套连招是通过五个动作组成，在执行一个攻击动画时如果再次点击了攻击按钮，执行完这个攻击动画将不会切换到站立动画，而是直接切换到连招的下一个攻击动画中。
只要连续点按攻击按钮，模型将完成一整套的动作。实现这个效果，我们只是使用了一个简单的定时器即可实现，接下来我们通过代码了解一下实现过程。

在实现动画前，先设置一个连招的数组，将需要的动作添加到数组当中。我这里添加了五个手部攻击的效果：

```js
let attackList = [12, 13, 14, 15, 16]; //连招的循序
let attackCombo = false; //是否连招，接下一个攻击
```

我们还设置了`attackCombo`设置当前是否可以连招的变量，这个变量`state.skills`值不为0时，将变为true。定时器每一次更新的时候，将判断`attackCombo`是否为true，在为true的状态下，将执行连招的下一个动作。否则，将停止连招。

```js
//attackIndex 等于0，当前不处于攻击状态  不等于，当前处于攻击状态
if(state.skills === 0){
    state.skills++;
    gui["action" + attackList[state.skills-1]]();
    attackInterval = setInterval(function () {
        if(attackCombo){
            //如果设置了连招，上一个攻击动作完成后，进行下一个攻击动作
            state.skills++;
            //如果整套攻击动作已经执行完成，则清除定时器
            if(state.skills-1 >= attackList.length){
                closeAttack();
                return;
            }

            //进行下一个动作
            gui["action" + attackList[state.skills-1]]();

            attackCombo = false;
        }
        else{
            closeAttack();
        }
    }, naruto.animations[attackList[state.skills-1]].duration*1000);
}
else{
    attackCombo = true;
}

```

在关闭掉攻击动画的函数内，我们首先将`state.skills`设置为0，然后恢复到移动或者站立动画，最后清除掉定时器：

```js
//关闭攻击状态
function closeAttack() {
    state.skills = 0;
    //根据状态设置是移动状态还是站立状态
    state.move ? gui["action" + 3]() :gui["action" + 24](); //回到站立状态
    clearInterval(attackInterval);
}
```



## D3.js

### 为什么学习D3

**D3.js和threejs的应用场景完全不一样**。threejs主要应用与基于webGL的3D场景，而D3.js确主要应用与2D场景。

它们一起形成了一种互补关系。

简而言之D3JS就是一个数据可视化的库。

那什么是数据可视化呢？

> 给出一组数据 [10，80，40,100,30,20,50]

![image-20190801162422591](https://s2.loli.net/2022/07/02/lEQI5jviK1zZH9J.png)

#### 类似的库 eharts

ECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器，ECharts 提供了常规的[折线图](https://www.echartsjs.com/option.html#series-line)、[柱状图](https://www.echartsjs.com/option.html#series-line)、[散点图](https://www.echartsjs.com/option.html#series-scatter)、[饼图](https://www.echartsjs.com/option.html#series-pie) 等等。

#### 和eharts的区别

eharts是封装好的各种的图表可以直接拿来使用，类似于图表模具，直接拿来使用即可。

D3.js就像画笔一样，一切都由你自由发挥。

### 基本介绍

**D3.js**（**Data-Driven Documents**）是一个使用动态图形进行[数据可视化](https://zh.wikipedia.org/wiki/資料視覺化)的[JavaScript程序库](https://zh.wikipedia.org/wiki/JavaScript函式庫)。与[W3C](https://zh.wikipedia.org/wiki/W3C)标准兼容，并且利用广泛实现的[SVG](https://zh.wikipedia.org/wiki/SVG)、JavaScript和[CSS](https://zh.wikipedia.org/wiki/CSS)标准，改良自早期的[Protovis](https://zh.wikipedia.org/w/index.php?title=Protovis&action=edit&redlink=1)程序库。与其他的程序库相比，D3对**视图结果有很大的可控性**。D3是2011年面世的，同年的8月发布了2.0.0版。到2018年4月，D3已被更新到了5.5.0版[[1\]](https://zh.wikipedia.org/wiki/D3.js#cite_note-d3_Releases-1)。

#### 	发展历史

在D3.js开发之前已经有出现过许多尝试做数据可视化的包，例如[Prefuse](https://zh.wikipedia.org/w/index.php?title=Prefuse&action=edit&redlink=1)，Flare和Protovis程序库，他们都可以视为D3.js的前身。然而Prefuse和Flare皆有缺点，皆不能只透过浏览器完成渲染，皆须要透过额外插件来完成。

例如2005年发布的Prefuse是一个数据可视化程序库，但是它需要透过网页的[Java](https://zh.wikipedia.org/wiki/Java)插件才能于[浏览器](https://zh.wikipedia.org/wiki/瀏覽器)中呈现；而Flare是2007年发布的另一个数据可视化工具包，由于其是使用[ActionScript](https://zh.wikipedia.org/wiki/ActionScript)编程语言开发，因此也需要额外插件，即[Flash](https://zh.wikipedia.org/wiki/Adobe_Flash_Player)插件才能完成渲染。

2009年，[史丹佛大学](https://zh.wikipedia.org/wiki/史丹佛大學)的史丹佛可视化团队（Stanford Visualization Group）的杰佛瑞·赫尔、[迈克·保斯托](https://zh.wikipedia.org/w/index.php?title=邁克·保斯托&action=edit&redlink=1)和瓦迪姆·欧格菲兹齐利用开发Prefuse和Flare的经验开始用Javscript开发了可从给定数据产生SVG图形的Protovis程序库。而Protovis程序库在业界和学界皆有一定的知名度[[3\]](https://zh.wikipedia.org/wiki/D3.js#cite_note-3)。

2011年，史丹佛可视化团队停止开发Protovis，并开始开发新的数据可视化程序库，借由之前开发Protovis的经验，开发出了D3.js程序库，在注重于Web标准的同时提供了更丰富的平台也有了更好的性能[[4\]](https://zh.wikipedia.org/wiki/D3.js#cite_note-Bostock,_Ogievetsky_&_Heer_2011-4)。

#### 技术原理

D3.js透过预先创建好迁入于网页中的[JavaScript](https://zh.wikipedia.org/wiki/JavaScript)函数来选择网页元素、创建[SVG](https://zh.wikipedia.org/wiki/SVG)元素、调整[CSS](https://zh.wikipedia.org/wiki/CSS)来呈现数据，并且也可以设置动画、动态改变对象状态或加入工具提示来完成用户交互功能。使用简单的D3.js函数就能够将大型的数据数据结构与SVG对象进行绑定，并且能生成[格式化文本](https://zh.wikipedia.org/wiki/格式化文本)和各种图表。



### 基本使用

#### hello world

先尝试用 D3 写第一个 HelloWorld 程序。学编程入门的第一个程序都是在屏幕上输出 HelloWorld，本课稍微有些不同，不是单纯的输出。

在 HTML 中输出 HelloWorld 是怎样的呢，先看下面的代码。

```html
<html> 
  <head> 
        <meta charset="utf-8"> 
        <title>HelloWorld</title> 
  </head> 
    <body> 
        <p>Hello World 1</p>
        <p>Hello World 2</p>
    </body> 
</html>
```

##### 用 JavaScript 来更改 HelloWorld

对于上面输出的内容，如果想用 JavaScript 来更改这两行文字，怎么办呢？我们会添加代码变为：

```html
<html> 
  <head> 
        <meta charset="utf-8"> 
        <title>HelloWorld</title> 
  </head> 
    <body> 
    <p>Hello World 1</p>
    <p>Hello World 2</p>
        <script>
        var paragraphs = document.getElementsByTagName("p");
        for (var i = 0; i < paragraphs.length; i++) {
          var paragraph = paragraphs.item(i);
          paragraph.innerHTML = "I like dog.";
        }          
        </script> 
    </body> 
</html>
```

##### 用 D3 来更改 HelloWorld

如果使用 D3.js 来修改这两行呢？只需添加一行代码即可。注意不要忘了引用 D3.js 源文件。

**引入**： 

```
<script src="https://d3js.org/d3.v5.js"></script>
```

```html
<html> 
  <head> 
        <meta charset="utf-8"> 
        <title>HelloWorld</title> 
  </head> 
    <body> 
        <p>Hello World 1</p>
        <p>Hello World 2</p>
        <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script> 
        <script>  
        d3.select("body").selectAll("p").text("www.ourd3js.com");      
        </script> 
    </body> 
</html>
```

接下来改变字体的颜色和大小，稍微修改上述代码：

```js
//选择<body>中所有的<p>，其文本内容为 www.ourd3js.com，选择集保存在变量 p 中
var p = d3.select("body")
          .selectAll("p")
          .text("www.ourd3js.com");

//修改段落的颜色和字体大小
p.style("color","red")
 .style("font-size","72px");
```

#### 选择元素

在 D3 中，用于选择元素的函数有两个：

- d3.select()：是选择所有指定元素的第一个
- d3.selectAll()：是选择指定元素的全部

这两个函数返回的结果称为选择集。

例如，选择集的常见用法如下。

```js
var body = d3.select("body"); //选择文档中的body元素
var p1 = body.select("p");      //选择body中的第一个p元素
var p = body.selectAll("p");    //选择body中的所有p元素
var svg = body.select("svg");   //选择body中的svg元素
var rects = svg.selectAll("rect");  //选择svg中所有的svg元素
```

#### 绑定数据

选择集和绑定数据通常是一起使用的。

D3 有一个很独特的功能：能将数据绑定到 DOM 上，也就是绑定到文档上。这么说可能不好理解，例如网页中有段落元素 p 和一个整数 5，于是可以将整数 5 与 p 绑定到一起。绑定之后，当需要依靠这个数据才操作元素的时候，会很方便。

D3 中是通过以下两个函数来绑定数据的：

- datum()：绑定一个数据到选择集上
- data()：绑定一个数组到选择集上，数组的各项值分别与选择集的各元素绑定

相对而言，data() 比较常用。

假设现在有三个段落元素如下。

```
<p>Apple</p>
<p>Pear</p>
<p>Banana</p>
```

**datum()**

假设有一字符串 China，要将此字符串分别与三个段落元素绑定，代码如下：

```js
var str = "China";

var body = d3.select("body");
var p = body.selectAll("p");

p.datum(str);

p.text(function(d, i){
    return "第 "+ i + " 个元素绑定的数据是 " + d;
});
```

绑定数据后，使用此数据来修改三个段落元素的内容，其结果如下：

```
第 0 个元素绑定的数据是 China

第 1 个元素绑定的数据是 China

第 2 个元素绑定的数据是 China
```

在上面的代码中，用到了一个无名函数 **function(d, i)**。当选择集需要使用被绑定的数据时，常需要这么使用。其包含两个参数，其中：

- d 代表数据，也就是与某元素绑定的数据。
- i 代表索引，代表数据的索引号，从 0 开始。

例如，上述例子中：第 0 个元素 apple 绑定的数据是 China。

**data()**

有一个数组，接下来要分别将数组的各元素绑定到三个段落元素上。

```js
var dataset = ["I like dog","I like cat","I like snake"];
```

绑定之后，其对应关系的要求为：

- Apple 与 I like dog 绑定
- Pear 与 I like cat 绑定
- Banana 与 I like snake 绑定

调用 data() 绑定数据，并替换三个段落元素的字符串为被绑定的字符串，代码如下：

```js
var body = d3.select("body");
var p = body.selectAll("p");

p.data(dataset)
  .text(function(d, i){
      return d;
});
```

这段代码也用到了一个无名函数 function(d, i)，其对应的情况如下：

- 当 i == 0 时， d 为 I like dog。
- 当 i == 1 时， d 为 I like cat。
- 当 i == 2 时， d 为 I like snake。

此时，三个段落元素与数组 dataset 的三个字符串是一一对应的，因此，在函数 function(d, i) 直接 return d 即可。

结果自然是三个段落的文字分别变成了数组的三个字符串。

```
I like dog

I like cat

I like snake
```

#### 选择、插入、删除元素

已经讲解了 select 和 selectAll，以及选择集的概念。本节具体讲解这两个函数的用法。

假设在 body 中有三个段落元素：

```
<p>Apple</p>
<p>Pear</p>
<p>Banana</p>
```

现在，要分别完成以下四种选择元素的任务。

##### 选择第一个 p 元素

```
t("p");
p1.style("color","red");
```

##### 选择三个 p 元素

```javascript
var p = body.selectAll("p");
p.style("color","red");
```

##### 选择第二个 p 元素

有不少方法，一种比较简单的是给第二个元素添加一个 id 号。

Pear

然后，使用 select 选择元素，注意参数中 id 名称前要加 # 号。

```
var p2 = body.select("#myid");
p2.style("color","red");
```

##### 选择后两个 p 元素

给后两个元素添加 class，

```
<p class="myclass">Pear</p>
<p class="myclass">Banana</p>
```

由于需要选择多个元素，要用 selectAll。注意参数，class 名称前要加一个点。

```javascript
var p = body.selectAll(".myclass");
p.style("color","red");
```

#### 插入元素

插入元素涉及的函数有两个：

- append()：在选择集末尾插入元素
- insert()：在选择集前面插入元素

假设有三个段落元素，与上文相同。

**append()**

```
body.append("p")
    .text("append p element");
```

在 body 的末尾添加一个 p 元素，结果为：

```
Apple
Pear
Banana
append p element
```

**insert()**

在 body 中 id 为 myid 的元素前添加一个段落元素。

```
body.insert("p","#myid")
  .text("insert p element");
```

已经指定了 Pear 段落的 id 为 myid，因此结果如下。

```
Apple
insert p element
Pear
Banana
```

#### 删除元素

删除一个元素时，对于选择的元素，使用 remove 即可，例如：

```
var p = body.select("#myid");
p.remove();
```



### SVG 基本使用

SVG 意为可缩放矢量图形（Scalable Vector Graphics）。

SVG 使用 XML 格式定义图像。

#### 什么是svg

- SVG 指可伸缩矢量图形 (Scalable Vector Graphics)
- SVG 用来定义用于网络的基于矢量的图形
- SVG 使用 XML 格式定义图形
- **SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失**
- SVG 是万维网联盟的标准
- **SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体**

#### hello-world

```html
<html>
<body>
 
<h1>My first SVG</h1>
 
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <circle cx="100" cy="50" r="40" stroke="black"
  stroke-width="2" fill="red" />
</svg>
 
</body>
</html>
```

#### 简单的 SVG 实例

一个简单的SVG图形例子：

这里是SVG文件（SVG文件的保存与SVG扩展）：

```svg
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" 
"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">

<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <circle cx="100" cy="50" r="40" stroke="black"
  stroke-width="2" fill="red" />
</svg>
```

**第一行**包含了 XML 声明。请注意 standalone 属性！该属性规定此 SVG 文件是否是"独立的"，或含有对外部文件的引用。

standalone="no" 意味着 SVG 文档会引用一个外部文件 - 在这里，是 DTD 文件。

**第二和第三行**引用了这个外部的 SVG DTD。该 DTD 位于 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"。该 DTD 位于 W3C，含有所有允许的 SVG 元素。

SVG 代码以 `<svg> `元素开始，包括开启标签` <svg> `和关闭标签 `</svg> `。这是根元素。width 和 height 属性可设置此 SVG 文档的宽度和高度。version 属性可定义所使用的 SVG 版本，xmlns 属性可定义 SVG 命名空间。

SVG 的` <circle>` 用来创建一个圆。cx 和 cy 属性定义圆中心的 x 和 y 坐标。如果忽略这两个属性，那么圆点会被设置为 (0, 0)。r 属性定义圆的半径。

stroke 和 stroke-width 属性控制如何显示形状的轮廓。我们把圆的轮廓设置为 2px 宽，黑边框。

fill 属性设置形状内的颜色。我们把填充颜色设置为红色。

关闭标签的作用是关闭 SVG 元素和文档本身。

#### SVG 在 HTML 页面

SVG 文件可通过以下标签嵌入 HTML 文档：<embed>、<object> 或者 <iframe>。

SVG的代码可以直接嵌入到HTML页面中，或您可以直接链接到SVG文件。

##### 使用 `<embed>` 标签

```
<embed src="circle1.svg" type="image/svg+xml" />
```

##### 直接在HTML嵌入SVG代码

在Firefox、Internet Explorer9、谷歌Chrome和Safari中，你可以直接在HTML嵌入SVG代码。

```html
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
   <circle cx="100" cy="50" r="40" stroke="black" stroke-width="2" fill="red" />
</svg>
```

#### SVG图形

SVG有一些预定义的形状元素，可被开发者使用和操作：

- 矩形 <rect>
- 圆形 <circle>
- 椭圆 <ellipse>
- 线 <line>
- 折线 <polyline>
- 多边形 <polygon>
- 路径 <path>



##### 矩形

EX1:

<rect> 标签可用来创建矩形，以及矩形的变种：

```html
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <rect width="300" height="100"
  style="fill:rgb(0,0,255);stroke-width:1;stroke:rgb(0,0,0)"/>
</svg>
```

- rect 元素的 width 和 height 属性可定义矩形的高度和宽度
- style 属性用来定义 CSS 属性
- CSS 的 fill 属性定义矩形的填充颜色（rgb 值、颜色名或者十六进制值）
- CSS 的 stroke-width 属性定义矩形边框的宽度
- CSS 的 stroke 属性定义矩形边框的颜色

EX2:

让我们看看另一个例子，它包含一些新的属性：

```html
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <rect x="50" y="20" width="150" height="150"
  style="fill:blue;stroke:pink;stroke-width:5;fill-opacity:0.1;
  stroke-opacity:0.9"/>
</svg>
```

- x 属性定义矩形的左侧位置（例如，x="0" 定义矩形到浏览器窗口左侧的距离是 0px）
- y 属性定义矩形的顶端位置（例如，y="0" 定义矩形到浏览器窗口顶端的距离是 0px）
- CSS 的 fill-opacity 属性定义填充颜色透明度（合法的范围是：0 - 1）
- CSS 的 stroke-opacity 属性定义轮廓颜色的透明度（合法的范围是：0 - 1）



##### 圆形

<circle> 标签可用来创建一个圆：

```html
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <circle cx="100" cy="50" r="40" stroke="black"
  stroke-width="2" fill="red"/>
</svg>
```

- cx和cy属性定义圆点的x和y坐标。如果省略cx和cy，圆的中心会被设置为(0, 0)
- r属性定义圆的半径



##### 椭圆

<ellipse> 元素是用来创建一个椭圆：

椭圆与圆很相似。不同之处在于椭圆有不同的x和y半径，而圆的x和y半径是相同的：

````html
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <ellipse cx="300" cy="80" rx="100" ry="50"
  style="fill:yellow;stroke:purple;stroke-width:2"/>
</svg>
````

##### 直线

<line> 元素是用来创建一个直线：

```html
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <line x1="0" y1="0" x2="200" y2="200"
  style="stroke:rgb(255,0,0);stroke-width:2"/>
</svg>
```

- x1 属性在 x 轴定义线条的开始
- y1 属性在 y 轴定义线条的开始
- x2 属性在 x 轴定义线条的结束
- y2 属性在 y 轴定义线条的结束

##### 多边形

<polygon> 标签用来创建含有不少于三个边的图形。

polygon来自希腊。 "Poly" 意味 "many" ， "gon" 意味 "angle".

```html
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <polygon points="200,10 250,190 160,210"
  style="fill:lime;stroke:purple;stroke-width:1"/>
</svg>
```

下面的示例创建一个四边的多边形：

```html
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <polygon points="220,10 300,210 170,250 123,234"
  style="fill:lime;stroke:purple;stroke-width:1"/>
</svg>
```

##### 曲线

<polyline> 元素是用于创建任何只有直线的形状：

```html
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <polyline points="20,20 40,25 60,40 80,120 120,140 200,180"
  style="fill:none;stroke:black;stroke-width:3" />
</svg>
```

只有直线的另一个例子：

```html
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <polyline points="0,40 40,40 40,80 80,80 80,120 120,120 120,160" style="fill:white;stroke:red;stroke-width:4" />
</svg>
```

##### 路径

<path> 元素用于定义一个路径。

下面的命令可用于路径数据：

- M = moveto
- L = lineto
- H = horizontal lineto
- V = vertical lineto
- C = curveto
- S = smooth curveto
- Q = quadratic Bézier curve
- T = smooth quadratic Bézier curveto
- A = elliptical Arc
- Z = closepath

例子定义了一条路径，它开始于位置150 0，到达位置75 200，然后从那里开始到225 200，最后在150 0关闭路径。

```html
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
    <path d="M150 0 L75 200 L225 200 Z" />
</svg>
```

##### 文本

<text> 元素用于定义文本。

EX:1

```
<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <text x="0" y="15" fill="red">I love SVG</text>
</svg>
```

##### Svg与Canvas的区别？

1. 绘制的图片格式不同

```
Canvas 的工具getContext 绘制出来的图形或传入的图片都依赖分辨率，能够以 .png 和 .jpg格式保存存储图像，可以说是位图

SVG 可以在H5中直接绘制，但绘制的是矢量图

由于位图依赖分辨率，矢量图不依赖分辨率，所以Canvas和SVG的图片格式的不同实际上是他们绘制出来的图片的格式不同造成的。
```

2. Canvas不支持事件处理器，SVG支持事件处理器

```
Canvas 绘制的图像 都在Canvas这个画布里面，是Canvas的一部分，不能用js获取已经绘制好的图形元素。
```

3. 适用范围不同

```
Canvas是逐像素进行渲染的，一旦图形绘制完成，就不会继续被浏览器关注。而SVG是通过DOM操作来显示的。

所以Canvas的文本渲染能力弱，而SVG最适合带有大型渲染区域的应用程序，比如地图。

而Canvas 最适合有许多对象要被频繁重绘的图形密集型游戏。

而SVG由于DOM操作 在复杂度高的游戏应用中 会减慢渲染速度。所以不适合在游戏应用。
```



### 实践

#### 做一个简单的柱状图

![image-20190802172953054](https://s2.loli.net/2022/07/02/5WMfGmcuzILs67J.png)

##### 画布

前几章的处理对象都是 HTML 的文字，没有涉及图形的制作。

要绘图，首要需要的是一块绘图的“**画布**”。

HTML 5 提供两种强有力的“画布”：**SVG** 和 **Canvas**。

##### 添加画布

D3 虽然没有明文规定一定要在 SVG 中绘图，但是 D3 提供了众多的 SVG 图形的生成器，它们都是只支持 SVG 的。因此，建议使用 SVG 画布。

使用 D3 在 body 元素中添加 svg 的代码如下。

```js
var width = 300;  //画布的宽度
var height = 300;   //画布的高度

var svg = d3.select("body")     //选择文档中的body元素
    .append("svg")          //添加一个svg元素
    .attr("width", width)       //设定宽度
    .attr("height", height);    //设定高度
```

有了画布，接下来就可以在画布上作图了。

##### 绘制矩形

本文绘制一个横向的柱形图。只绘制矩形，不绘制文字和坐标轴。

在 SVG 中，矩形的元素标签是 rect。例如：

```html
<svg>
  <rect></rect>
  <rect></rect>
</svg>
```

上面的 rect 里没有矩形的属性。矩形的属性，常用的有四个：

- x：矩形左上角的 x 坐标
- y：矩形左上角的 y 坐标
- width：矩形的宽度
- height：矩形的高度

要注意，在 SVG 中，x 轴的正方向是水平向右，y 轴的正方向是垂直向下的。

现在给出一组数据，要对此进行可视化。数据如下：

```js
var dataset = [ 250 , 210 , 170 , 130 , 90 ];  //数据（表示矩形的宽度）
```

为简单起见，我们直接用数值的大小来表示矩形的像素宽度（后面会说到这不是一种好方法）。然后，添加以下代码。

```js
var rectHeight = 25;   //每个矩形所占的像素高度(包括空白)

svg.selectAll("rect")
    .data(dataset)
    .enter()
    .append("rect")
    .attr("x",20)
    .attr("y",function(d,i){
         return i * rectHeight;
    })
    .attr("width",function(d){
         return d;
    })
    .attr("height",rectHeight-2)
    .attr("fill","steelblue");
```

这段代码添加了与 dataset 数组的长度相同数量的矩形，所使用的语句是：

```js
svg.selectAll("rect")   //选择svg内所有的矩形
    .data(dataset)  //绑定数组
    .enter()        //指定选择集的enter部分
    .append("rect") //添加足够数量的矩形元素
```

这段代码以后会常常出现在 D3 的代码中，请务必牢记。目前不深入讨论它的作用机制是怎样的，只需要读者牢记，当：

**有数据，而没有足够图形元素的时候，使用此方法可以添加足够的元素。**

添加了元素之后，就需要分别给各元素的属性赋值。在这里用到了 function(d, i)，前面已经讲过，d 代表与当前元素绑定的数据，i 代表索引号。给属性赋值的时候，是需要用到被绑定的数据，以及索引号的。

最后一行的：

```javascript
.attr("fill","steelblue");
```



##### 比例尺的使用

比例尺是 D3 中很重要的一个概念，上一章里曾经提到过直接用数值的大小来代表像素不是一种好方法，本章正是要解决此问题。

**为什么需要比例尺**

上一章制作了一个柱形图，当时有一个数组：

```js
var dataset = [ 250 , 210 , 170 , 130 , 90 ];
```

绘图时，直接使用 250 给矩形的宽度赋值，即矩形的宽度就是 250 个像素。

此方式非常具有局限性，如果数值过大或过小，例如：

```javascript
var dataset_1 = [ 2.5 , 2.1 , 1.7 , 1.3 , 0.9 ];
var dataset_2 = [ 2500, 2100, 1700, 1300, 900 ];
```

对以上两个数组，绝不可能用 2.5 个像素来代表矩形的宽度，那样根本看不见；也不可能用 2500 个像素来代表矩形的宽度，因为画布没有那么长。

于是，我们需要一种计算关系，能够：

**将某一区域的值映射到另一区域，其大小关系不变。**

这就是比例尺（Scale）。

**有哪些比例尺**

比例尺，很像数学中的函数。例如，对于一个一元二次函数，有 x 和 y 两个未知数，当 x 的值确定时，y 的值也就确定了。

在数学中，x 的范围被称为**定义域**，y 的范围被称为**值域**。

D3 中的比例尺，也有定义域和值域，分别被称为 domain 和 range。开发者需要指定 domain 和 range 的范围，如此即可得到一个计算关系。

D3 提供了多种比例尺，下面介绍最常用的两种。



###### 线性比例尺

线性比例尺，能将一个连续的区间，映射到另一区间。要解决柱形图宽度的问题，就需要线性比例尺。

假设有以下数组：

```js
var dataset = [1.2, 2.3, 0.9, 1.5, 3.3];
```

现有要求如下：

**将 dataset 中最小的值，映射成 0；将最大的值，映射成 300。**

代码如下：

```js
var min = d3.min(dataset);
var max = d3.max(dataset);

var linear = d3.scaleLinear()
        .domain([min, max])
        .range([0, 300]);

linear(0.9);    //返回 0
linear(2.3);    //返回 175
linear(3.3);    //返回 300
```

其中，**d3.scale.linear()** 返回一个线性比例尺。domain() 和 range() 分别设定比例尺的定义域和值域。在这里还用到了两个函数，它们经常与比例尺一起出现：

- d3.max()
- d3.min()

这两个函数能够求数组的最大值和最小值，是 D3 提供的。按照以上代码，

比例尺的定义域 domain 为：[0.9, 3.3]

比例尺的值域 range 为：[0, 300]

因此，当输入 0.9 时，返回 0；当输入 3.3 时，返回 300。当输入 2.3 时呢？返回 175，这是按照线性函数的规则计算的。

有一点请大家记住：

d3.scale.linear() 的返回值，是可以当做**函数**来使用的。因此，才有这样的用法：linear(0.9)。



###### 序数比例尺

有时候，定义域和值域不一定是连续的。例如，有两个数组：

```js
var index = [0, 1, 2, 3, 4];
var color = ["red", "blue", "green", "yellow", "black"];
```

我们希望 0 对应颜色 red，1 对应 blue，依次类推。

但是，这些值都是离散的，线性比例尺不适合，需要用到序数比例尺。

```js
var ordinal = d3.scaleOrdinal()
        .domain(index)
        .range(color);

ordinal(0); //返回 red
ordinal(2); //返回 green
ordinal(4); //返回 black
```

###### 给柱形图添加比例尺

修改一下数组，再定义一个线性比例尺。

```js
var dataset = [ 2.5 , 2.1 , 1.7 , 1.3 , 0.9 ];

var linear = d3.scale.linear()
        .domain([0, d3.max(dataset)])
        .range([0, 250]);

```

其后，按照上一章的方法添加矩形，在给矩形设置宽度的时候，应用比例尺。

```js
var rectHeight = 25;   //每个矩形所占的像素高度(包括空白)

svg.selectAll("rect")
    .data(dataset)
    .enter()
    .append("rect")
    .attr("x",20)
    .attr("y",function(d,i){
         return i * rectHeight;
    })
    .attr("width",function(d){
         return linear(d);   //在这里用比例尺
    })
    .attr("height",rectHeight-2)
    .attr("fill","steelblue");
```

如此一来，所有的数值，都按照同一个线性比例尺的关系来计算宽度，因此数值之间的大小关系不变。



##### 坐标轴

坐标轴，是可视化图表中经常出现的一种图形，由一些列线段和刻度组成。坐标轴在 SVG 中是没有现成的图形元素的，需要用其他的元素组合构成。D3 提供了坐标轴的组件，如此在 SVG 画布中绘制坐标轴变得像添加一个普通元素一样简单。

![image-20190802180149326](https://s2.loli.net/2022/07/02/2r31CwbkMEQpRo7.png)

在 SVG 画布的预定义元素里，有六种基本图形：

- 矩形
- 圆形
- 椭圆
- 线段
- 折线
- 多边形

另外，还有一种比较特殊，也是功能最强的元素：

- 路径

画布中的所有图形，都是由以上七种元素组成。

显然，这里面没有**坐标轴** 这种元素。如果有的话，我们可以采用类似以下的方式定义：

```html
<axis x1="" x2="" ...></axis>
```

很可惜，没有这种元素。但是，这种设计是合理的：不可能为每一种图形都配备一个单独的元素，那样 SVG 就会过于庞大。

因此，我们需要用其他元素来组合成坐标轴，最终使其变为类似以下的形式：

```html
<g>
<!-- 第一个刻度 -->
<g>
<line></line>   <!-- 第一个刻度的直线 -->
<text></text>   <!-- 第一个刻度的文字 -->
</g>
<!-- 第二个刻度 -->
<g>
<line></line>   <!-- 第二个刻度的直线 -->
<text></text>   <!-- 第二个刻度的文字 -->
</g> 
...
<!-- 坐标轴的轴线 -->
<path></path>
</g>
```

分组元素 ，是 SVG 画布中的元素，意思是 group。此元素是将其他元素进行组合的容器，在这里是用于将坐标轴的其他元素分组存放。

如果需要手动添加这些元素就太麻烦了，为此，D3 提供了一个组件：d3.svg.axis()。它为我们完成了以上工作。



###### 定义坐标轴

上一章提到了比例尺的概念，要生成坐标轴，需要用到比例尺，它们二者经常是一起使用的。下面，在上一章的数据和比例尺的基础上，添加一个坐标轴的组件。

```js
var dataset = [1, 2, 3, 4, 5];  // 数据源  x

// 比例尺  让图表更加的直观， 合理

var min = d3.min(dataset);
var max = d3.max(dataset);

// console.log(max)

// scaleLinear可以定义比例尺  domain range
var linear = d3.scaleLinear().domain([0, max]).range([0, 300]);

// 添加坐标轴
var xAxis = d3.axisBottom(linear);
```



###### 在svg中添加坐标轴

定义了坐标轴之后，只需要在 SVG 中添加一个分组元素 ，再将坐标轴的其他元素添加到这个 里即可。代码如下：

```js
svg.append("g")
   .attr("transform","translate(20,130)")
   .call(axis);
```



#### 让你的坐标轴动起来demo

```html
<!DOCTYPE html>
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        #update {
            position: absolute;
            top: 10px;
            left: 10px;
        }
    </style>
</head>

<body>
    <button id="update">更新</button>
    <script src="https://d3js.org/d3.v5.js"></script>
    <script>

        // 1. 添加画布
        var width = 960;
        var height = 500;

        var svg = d3.select('body').append('svg').attr('width', width).attr('height', height)

        // 完成 静态的  坐标轴
        // 线性比例尺
        var scale = d3.scaleLinear().domain([0, 100]).range([100, 860]);

        var axis = d3.axisBottom(scale);

        
        var g = svg.append('g').attr('id', 'g').call(axis);

        // 绑定事件
        d3.select('#update').on('click', function() {
            // 更新数据
            scale.domain([0, Math.random() * 100]);
            // g.call(axis);
            // transition d3提供默认的动画
            d3.select('#g').transition().call(axis)
        })

    </script>
</body>

</html>

```





