# 三画项目面

### 你能说说为啥使用骨架屏吗?

现在的前端开发领域，都是前后端分离，前端框架主流的都是 SPA，MPA；这就意味着，页面渲染以及等待的白屏时间，成为我们需要解决的问题点；而且大项目，这个问题尤为突出。

webpack 可以实现按需加载，减小我们首屏需要加载的代码体积；再配合上 CDN 以及一些静态代码（框架，组件库等等…）缓存技术，可以很好的缓解这个加载渲染的时间过长的问题。

但即便如此，首屏的加载依然还是存在这个加载以及渲染的等待时间问题；

### 骨架屏的原理知道吗?

**方案一、**

在 index.html 中的 div#app 中来实现骨架屏，程序渲染后就会替换掉 index.html 里面的 div#app 骨架屏内容；

![img](https://s2.loli.net/2022/07/08/tJVIubK6nYa8Ce1.png)

**方案二、使用一个Base64的图片来作为骨架屏**

使用图片作为骨架屏； 简单暴力，让UI同学花点功夫吧；小米商城的移动端页面采用的就是这个方法，它是使用了一个Base64的图片来作为骨架屏。

按照方案一的方案，将这个 Base64 的图片写在我们的 index.html 模块中的 div#app 里面。

**方案三、使用 .vue 文件来完成骨架屏**

### CDN优化

### 能说说什么是CDN吗?

CDN（Content Delivery Network，**内容分发网络**）是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。

典型的CDN系统由下面三个部分组成：

- **分发服务系统：** 最基本的工作单元就是Cache设备，cache（边缘cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。同时cache还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache设备的数量、规模、总服务能力是衡量一个CDN系统服务能力的最基本的指标。
- **负载均衡系统：** 主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本地负载均衡（SLB）。**全局负载均衡**主要根据用户就近性原则，通过对每个服务节点进行“最优”判断，确定向用户提供服务的cache的物理位置。**本地负载均衡**主要负责节点内部的设备负载均衡
- **运营管理系统：** 运营管理系统分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。

### 能具体说说CDN是怎么配置的吗?

可以通过阿里云，百度云，华为云等CDN

通过externals这个配置项进行cdn配置

![img](https://s2.loli.net/2022/07/08/fAlt1cqzePvxnDZ.png)

然后通过在index.html中引入相应的cdn资源

cdn资源的话可以通过bootcdn来进行查找

### CDN有什么作用知道吗？

CDN一般会用来托管Web资源（包括文本、图片和脚本等），可供下载的资源（媒体文件、软件、文档等），应用程序（门户网站等）。使用CDN来加速这些资源的访问。

（1）**在性能方面**，引入CDN的作用在于：

- 用户收到的内容来自最近的数据中心，延迟更低，内容加载更快
- 部分资源请求分配给了CDN，减少了服务器的负载

（2）**在安全方面**，CDN有助于防御DDoS、MITM等网络攻击：

- 针对DDoS：通过监控分析异常流量，限制其请求频率
- 针对MITM：从源服务器到 CDN 节点到 ISP（Internet Service Provider），全链路 HTTPS 通信

除此之外，CDN作为一种基础的云服务，同样具有资源托管、按需扩展（能够应对流量高峰）等方面的优势。

### DNS解析与CDN的区别知道吗?

CDN和DNS有着密不可分的联系，先来看一下DNS的解析域名过程，在浏览器输入 [www.test.com](https://link.juejin.cn?target=http%3A%2F%2Fwww.test.com) 的解析过程如下： （1） 检查浏览器缓存 （2）检查操作系统缓存，常见的如hosts文件 （3）检查路由器缓存 （4）如果前几步都没没找到，会向ISP(网络服务提供商)的LDNS服务器查询 （5）如果LDNS服务器没找到，会向根域名服务器(Root Server)请求解析，分为以下几步：

- 根服务器返回顶级域名(TLD)服务器如.com，.cn，.org等的地址，该例子中会返回.com的地址
- 接着向顶级域名服务器发送请求，然后会返回次级域名(SLD)服务器的地址，本例子会返回.test的地址
- 接着向次级域名服务器发送请求，然后会返回通过域名查询到的目标IP，本例子会返回www.test.com的地址
- Local DNS Server会缓存结果，并返回给用户，缓存在系统中

### CDN的工作原理知道吗?

（1）**用户未使用CDN缓存资源的过程：**

1. 浏览器通过DNS对域名进行解析（就是上面的DNS解析过程），依次得到此域名对应的IP地址
2. 浏览器根据得到的IP地址，向域名的服务主机发送数据请求
3. 服务器向浏览器返回响应数据

（2）**用户使用CDN缓存资源的过程：**

1. 对于点击的数据的URL，经过本地DNS系统的解析，发现该URL对应的是一个CDN专用的DNS服务器，DNS系统就会将域名解析权交给CNAME指向的CDN专用的DNS服务器。
2. CND专用DNS服务器将CND的全局负载均衡设备IP地址返回给用户
3. 用户向CDN的全局负载均衡设备发起数据请求
4. CDN的全局负载均衡设备根据用户的IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求
5. 区域负载均衡设备选择一台合适的缓存服务器来提供服务，将该缓存服务器的IP地址返回给全局负载均衡设备
6. 全局负载均衡设备把服务器的IP地址返回给用户
7. 用户向该缓存服务器发起请求，缓存服务器响应用户的请求，将用户所需内容发送至用户终端

### 那ES6 模块与 CommonJS 模块的差异有哪些呢?

**1. CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。**

- CommonJS 模块输出的是值的**拷贝**(浅拷贝)，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
- ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。原始值变了，import加载的值也会跟着变。**因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。**

**2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。**

- 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，然后再从这个对象上面读取方法，这种加载称为“运行时加载”。
- 编译时加载: ES6 模块不是对象，而是通过 export 命令显式指定输出的代码，import时采用静态命令的形式。即在import时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。

CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

### webpack的编译(打包)流程说说

- **初始化参数**：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数,形成最后的配置结果；
- **开始编译**：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件 监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的run方法开始执行编译；
- ***确定入口\***：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去；
- **编译模块**：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
- **完成模块编译并输出**：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据entry或分包配置生成代码块chunk;
- **输出完成**：输出所有的chunk到文件系统；

### 说一下 Webpack 的热更新原理吧？

Webpack 的热更新又称**热替换**（Hot Module Replacement），缩写为 **HMR**。 这个机制**可以做到不用刷新浏览器**而将**新变更的模块替换掉旧的模块**。

HMR的核心就是**客户端从服务端拉去更新后的文件**，准确的说是 chunk diff (chunk 需要更新的部分)，实际上 WDS(无线路由)与浏览器之间维护了一个 Websocket，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 Ajax 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 jsonp 请求获取该chunk的增量更新。

后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 HotModulePlugin 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像react-hot-loader 和 vue-loader 都是借助这些 API 实现 HMR。

### 你知道哪些loader吗？

- file-loader：把⽂件输出到⼀个⽂件夹中，在代码中通过相对 URL 去引⽤输出的⽂件
- url-loader：和 file-loader 类似，但是能在⽂件很⼩的情况下以 base64 的⽅式把⽂件内容注⼊到代码中去
- source-map-loader：加载额外的 Source Map ⽂件，以⽅便断点调试
- image-loader：加载并且压缩图⽚⽂件
- babel-loader：把 ES6 转换成 ES5
- css-loader：加载 CSS，⽀持模块化、压缩、⽂件导⼊等特性
- style-loader：把 CSS 代码注⼊到 JavaScript 中，通过 DOM 操作去加载 CSS。
- eslint-loader：通过 ESLint 检查 JavaScript 代码

# Git

### 项目里git怎么使用的可以说说吗?

1.在工作区开发，添加，修改文件。

2.将修改后的文件放入暂存区。

3.将暂存区域的文件提交到本地仓库。

4.将本地仓库的修改推送到远程仓库。



### 知道git的原理吗?说说他的原理吧

Workspace：工作区，就是平时进行开发改动的地方，是当前看到最新的内容，在开发的过程也就是对工作区的操作

Index：暂存区，当执行 git add 的命令后，工作区的文件就会被移入暂存区，暂存区标记了当前工作区中那些内容是被 Git 管理的，当完成某个需求或者功能后需要提交代码，第一步就是通过 git add 先提交到暂存区。

Repository：本地仓库，位于自己的电脑上，通过 git commit 提交暂存区的内容，会进入本地仓库。

Remote：远程仓库，用来托管代码的服务器，远程仓库的内容能够被分布在多个地点的处于协作关系的本地仓库修改，本地仓库修改完代码后通过 git push 命令同步代码到远程仓库。



### 能说几个git的操作吗?

## Git命令

<img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20220709094028533.png" alt="image-20220709094028533" style="zoom:200%;" />



在实际开发中，会使用git作为版本控制工具来完成团队协作。因此，对基本的git操作指令进行总结是十分有必要的，本文对一些术语或者理论基础，不重新码字，可以[参考廖雪峰老师的博文](https://link.juejin.cn/?target=https%3A%2F%2Fwww.liaoxuefeng.com%2Fwiki%2F0013739516305929606dd18361248578c67b8067c8c017b000)，本文只对命令做归纳总结。

[git总结](https://juejin.cn/post/6844903598522908686)

[工作中使用](https://juejin.cn/post/6974184935804534815)

![git操作](https://s2.loli.net/2022/07/29/v7OrSxV1gDAl3M2.png)

### 基本使用

#### 1.基本原理和使用

 git的通用操作流程如下图（来源于网络）



![git操作通用流程](https://s2.loli.net/2022/07/29/4AobW6DCr5LUzlZ.webp)



主要涉及到四个关键点：

1.  工作区：本地电脑存放项目文件的地方，比如learnGitProject文件夹；
2.  暂存区（Index/Stage）：在使用git管理项目文件的时候，其本地的项目文件会多出一个.git的文件夹，将这个.git文件夹称之为版本库。其中.git文件夹中包含了两个部分，一个是暂存区（Index或者Stage）,顾名思义就是暂时存放文件的地方，通常使用add命令将工作区的文件添加到暂存区里；
3.  本地仓库：.git文件夹里还包括git自动创建的master分支，并且将HEAD指针指向master分支。使用commit命令可以将暂存区中的文件添加到本地仓库中；
4.  远程仓库：不是在本地仓库中，项目代码在远程git服务器上，比如项目放在github上，就是一个远程仓库，通常使用clone命令将远程仓库拷贝到本地仓库中，开发后推送到远程仓库中即可；

更细节的来看：



![git几个核心区域间的关系](https://s2.loli.net/2022/07/29/RTCIsL3PB2V4UiE.webp)



日常开发时代码实际上放置在工作区中，也就是本地的XXX.java这些文件，通过add等这些命令将代码文教提交给暂存区（Index/Stage），也就意味着代码全权交给了git进行管理，之后通过commit等命令将暂存区提交给master分支上，也就是意味打了一个版本，也可以说代码提交到了本地仓库中。另外，团队协作过程中自然而然还涉及到与远程仓库的交互。

因此，经过这样的分析，git命令可以分为这样的逻辑进行理解和记忆：

1. git管理配置的命令；

   **几个核心存储区的交互命令：**

2. 工作区与暂存区的交互；

3. 暂存区与本地仓库（分支）上的交互；

4. 本地仓库与远程仓库的交互。

#### 2. git配置命令

>   查询配置信息

1.  列出当前配置：`git config --list`;
2.  列出repository配置：`git config --local --list`;
3.  列出全局配置：`git config --global --list`;
4.  列出系统配置：`git config --system --list`;

>   第一次使用git，配置用户信息

1.  配置用户名：`git config --global user.name "your name"`;
2.  配置用户邮箱：`git config --global user.email "youremail@github.com"`;

>   其他配置

1.  配置解决冲突时使用哪种差异分析工具，比如要使用vimdiff：`git config --global merge.tool vimdiff`;
2.  配置git命令输出为彩色的：`git config --global color.ui auto`;
3.  配置git使用的文本编辑器：`git config --global core.editor vi`;

#### 3. 工作区上的操作命令

>   新建仓库

1.  将工作区中的项目文件使用git进行管理，即创建一个新的本地仓库：`git init`；
2.  从远程git仓库复制项目：`git clone <url>`，如：git clone git://github.com/wasd/example.git;克隆项目时如果想定义新的项目名，可以在clone命令后指定新的项目名：`git clone git://github.com/wasd/example.git mygit`；

>   提交

1.  提交工作区所有文件到暂存区：`git add .`
2.  提交工作区中指定文件到暂存区：`git add <file1> <file2> ...`;
3.  提交工作区中某个文件夹中所有文件到暂存区：`git add [dir]`;

>   撤销

1.  删除工作区文件，并且也从暂存区删除对应文件的记录：`git rm <file1> <file2>`;
2.  从暂存区中删除文件，但是工作区依然还有该文件:`git rm --cached <file>`;
3.  取消暂存区已经暂存的文件：`git reset HEAD <file>...`;
4.  撤销上一次对文件的操作：`git checkout --<file>`。要确定上一次对文件的修改不再需要，如果想保留上一次的修改以备以后继续工作，可以使用stashing和分支来处理；
5.  隐藏当前变更，以便能够切换分支：`git stash`；
6.  查看当前所有的储藏：`git stash list`；
7.  应用最新的储藏：`git stash apply`，如果想应用更早的储藏：`git stash apply stash@{2}`；重新应用被暂存的变更，需要加上`--index`参数：`git stash apply --index`;
8.  使用apply命令只是应用储藏，而内容仍然还在栈上，需要移除指定的储藏：`git stash drop stash{0}`；如果使用pop命令不仅可以重新应用储藏，还可以立刻从堆栈中清除：`git stash pop`;
9.  在某些情况下，你可能想应用储藏的修改，在进行了一些其他的修改后，又要取消之前所应用储藏的修改。Git没有提供类似于 stash unapply 的命令，但是可以通过取消该储藏的补丁达到同样的效果：`git stash show -p stash@{0} | git apply -R`；同样的，如果你沒有指定具体的某个储藏，Git 会选择最近的储藏：`git stash show -p | git apply -R`；

>   更新文件

1.  重命名文件，并将已改名文件提交到暂存区：`git mv [file-original] [file-renamed]`;

>   查新信息

1.  查询当前工作区所有文件的状态：`git status`;
2.  比较工作区中当前文件和暂存区之间的差异，也就是修改之后还没有暂存的内容：git diff；指定文件在工作区和暂存区上差异比较：`git diff <file-name>`;

#### 4. 暂存区上的操作命令

>   提交文件到版本库

1.  将暂存区中的文件提交到本地仓库中，即打上新版本：`git commit -m "commit_info"`;
2.  将所有已经使用git管理过的文件暂存后一并提交，跳过add到暂存区的过程：`git commit -a -m "commit_info"`;
3.  提交文件时，发现漏掉几个文件，或者注释写错了，可以撤销上一次提交：`git commit --amend`;

>   查看信息

1.  比较暂存区与上一版本的差异：`git diff --cached`;
2.  指定文件在暂存区和本地仓库的不同：`git diff <file-name> --cached`;
3.  查看提交历史：git log；参数`-p`展开每次提交的内容差异，用`-2`显示最近的两次更新，如`git log -p -2`;

>   打标签

Git 使用的标签有两种类型：**轻量级的（lightweight）和含附注的（annotated）**。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。

1.  列出现在所有的标签：`git tag`;
2.  使用特定的搜索模式列出符合条件的标签，例如只对1.4.2系列的版本感兴趣：`git tag -l "v1.4.2.*"`;
3.  创建一个含附注类型的标签，需要加`-a`参数，如`git tag -a v1.4 -m "my version 1.4"`;
4.  使用git show命令查看相应标签的版本信息，并连同显示打标签时的提交对象：`git show v1.4`;
5.  如果有自己的私钥，可以使用GPG来签署标签，只需要在命令中使用`-s`参数：`git tag -s v1.5 -m "my signed 1.5 tag"`;
6.  验证已签署的标签：git tag -v ，如`git tag -v v1.5`;
7.  创建一个轻量级标签的话，就直接使用git tag命令即可，连`-a`,`-s`以及`-m`选项都不需要，直接给出标签名字即可，如`git tag v1.5`;
8.  将标签推送到远程仓库中：git push origin ，如`git push origin v1.5`；
9.  将本地所有的标签全部推送到远程仓库中：`git push origin --tags`;

>   分支管理

1.  创建分支：`git branch <branch-name>`，如`git branch testing`；
2.  从当前所处的分支切换到其他分支：`git checkout <branch-name>`，如`git checkout testing`；
3.  新建并切换到新建分支上：`git checkout -b <branch-name>`;
4.  删除分支：`git branch -d <branch-name>`；
5.  将当前分支与指定分支进行合并：`git merge <branch-name>`;
6.  显示本地仓库的所有分支：`git branch`;
7.  查看各个分支最后一个提交对象的信息：`git branch -v`;
8.  查看哪些分支已经合并到当前分支：`git branch --merged`;
9.  查看当前哪些分支还没有合并到当前分支：`git branch --no-merged`;
10.  把远程分支合并到当前分支：`git merge <remote-name>/<branch-name>`，如`git merge origin/serverfix`；如果是单线的历史分支不存在任何需要解决的分歧，只是简单的将HEAD指针前移，所以这种合并过程可以称为快进（Fast forward），而如果是历史分支是分叉的，会以当前分叉的两个分支作为两个祖先，创建新的提交对象；如果在合并分支时，遇到合并冲突需要人工解决后，再才能提交；
11.  在远程分支的基础上创建新的本地分支`：git checkout -b <branch-name> <remote-name>/<branch-name>`，如`git checkout -b serverfix origin/serverfix`;
12.  从远程分支checkout出来的本地分支，称之为跟踪分支。在跟踪分支上向远程分支上推送内容：`git push`。该命令会自动判断应该向远程仓库中的哪个分支推送数据；在跟踪分支上合并远程分支：`git pull`；
13.  将一个分支里提交的改变移到基底分支上重放一遍：`git rebase <rebase-branch> <branch-name>`，如`git rebase master server`，将特性分支server提交的改变在基底分支master上重演一遍；使用rebase操作最大的好处是像在单个分支上操作的，提交的修改历史也是一根线；如果想把基于一个特性分支上的另一个特性分支变基到其他分支上，可以使用`--onto`操作：`git rebase --onto <rebase-branch> <feature branch> <sub-feature-branch>`，如`git rebase --onto master server client`；使用rebase操作应该遵循的原则是：**一旦分支中的提交对象发布到公共仓库，就千万不要对该分支进行rebase操作**；

#### 5.本地仓库上的操作

1.  查看本地仓库关联的远程仓库：`git remote`；在克隆完每个远程仓库后，远程仓库默认为`origin`;加上`-v`的参数后，会显示远程仓库的`url`地址；
2.  添加远程仓库，一般会取一个简短的别名：`git remote add [remote-name] [url]`，比如：`git remote add example git://github.com/example/example.git`;
3.  从远程仓库中抓取本地仓库中没有的更新：`git fetch [remote-name]`，如`git fetch origin`;使用fetch只是将远端数据拉到本地仓库，并不自动合并到当前工作分支，只能人工合并。如果设置了某个分支关联到远程仓库的某个分支的话，可以使用`git pull`来拉去远程分支的数据，然后将远端分支自动合并到本地仓库中的当前分支；
4.  将本地仓库某分支推送到远程仓库上：`git push [remote-name] [branch-name]`，如`git push origin master`；如果想将本地分支推送到远程仓库的不同名分支：`git push <remote-name> <local-branch>:<remote-branch>`，如`git push origin serverfix:awesomebranch`;如果想删除远程分支：`git push [romote-name] :<remote-branch>`，如`git push origin :serverfix`。这里省略了本地分支，也就相当于将空白内容推送给远程分支，就等于删掉了远程分支。
5.  查看远程仓库的详细信息：`git remote show origin`；
6.  修改某个远程仓库在本地的简称：`git remote rename [old-name] [new-name]`，如`git remote rename origin org`；
7.  移除远程仓库：`git remote rm [remote-name]`；

#### 6. 忽略文件.gitignore

一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件模式。如下例：

```
# 此为注释 – 将被 Git 忽略
# 忽略所有 .a 结尾的文件
*.a
# 但 lib.a 除外
!lib.a
# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO
/TODO
# 忽略 build/ 目录下的所有文件
build/
# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
doc/*.txt
# 忽略 doc/ 目录下所有扩展名为 txt 的文件
doc/**/*.txt
```

### [一张脑图带你掌握Git命令](https://juejin.cn/post/6869519303864123399)

![a1d538d63559402fbcfd82d68b08061c](https://s2.loli.net/2022/07/29/nx8XdjVM3lLESFf.png)

![b675e7bb00d24232a2338f87d85d00af](https://s2.loli.net/2022/07/29/5ZhQ4YiaGJ38L9V.png)

版本库👉`.git`

- 当我们使用git管理文件时，比如`git init`时，这个时候，会多一个`.git`文件，我们把这个文件称之为版本库。
- `.git文件`另外一个作用就是它在创建的时候，会自动创建master分支，并且将HEAD指针指向master分支。

工作区

- 本地项目存放文件的位置
- 可以理解成图上的workspace

暂存区 (Index/Stage)

- 顾名思义就是暂时存放文件的地方，通过是通过add命令将工作区的文件添加到缓冲区

本地仓库（Repository）

- 通常情况下，我们使用commit命令可以将暂存区的文件添加到本地仓库
- 通常而言，HEAD指针指向的就是master分支

远程仓库（Remote）

- 举个例子，当我们使用GitHub托管我们项目时，它就是一个远程仓库。
- 通常我们使用clone命令将远程仓库代码拷贝下来，本地代码更新后，通过push托送给远程仓库。

#### Git文件状态

- 通常我们需要查看一个文件的状态

```bash
git status
```

- ```
  Changes not staged for commit
  ```

  - 表示得大概就是工作区有该内容，但是缓存区没有，需要我们`git add`

- ```
  Changes to be committed
  ```

  - 一般而言，这个时候，文件放在缓存区了，我们需要`git commit`

- ```
  nothing to commit, working tree clean
  ```

  - 这个时候，我们将本地的代码推送到远端即可

#### 常见命令

#### git配置命令


![29f0c70414b14fe1986b376f7b303959](https://s2.loli.net/2022/07/29/6VsTgdRpq9CZQjY.png)

- 列出当前配置

```bash
git config --list	
```

- 列出Repository配置

```bash
git config --local --list
```

- 列出全局配置

```bash
git config --global --list
```

- 列出系统配置

```bash
git config --system --list
```

- 配置用户名

```bash
git config --global user.name "your name"
```

- 配置用户邮箱

```bash
git config --global user.email "youremail@github.com"
```

#### 分支管理

![3bff7ddbc6a145f993c0841eb81c8998](https://s2.loli.net/2022/07/29/fKrukGdxRe2nl4t.png)

- 查看本地分支

```bash
git branch
```

- 查看远程分支

```bash
git branch -r
```

- 查看本地和远程分支

```bash
git branch -a
```

- 从当前分支，切换到其他分支

```bash
git checkout <branch-name>
// 举个例子
git checkout feature/tiantian
```

- 创建并切换到新建分支

```bash
git checkout -b <branch-name>
// 举个例子👇
git checkout -b feature/tiantian
```

- 删除分支

```bash
git branch -d <branch-name>
// 举个例子👇
git branch -d feature/tiantian
```

- 当前分支与指定分支合并

```bash
git merge <branch-name>
// 举个例子👇
git merge feature/tiantian
```

- 查看哪些分支已经合并到当前分支

```bash
git branch --merged
```

- 查看哪些分支没有合并到当前分支

```bash
git branch --no-merged
```

- 查看各个分支最后一个提交对象的信息

```bash
git branch -v
```

- 删除远程分支

```bash
git push origin -d <branch-name>
```

- 重命名分支

```bash
git branch -m <oldbranch-name> <newbranch-name>
```

- 拉取远程分支并创建本地分支

```bash
git checkout -b 本地分支名x origin/远程分支名x

// 另外一种方式,也可以完成这个操作。
git fetch origin <branch-name>:<local-branch-name>
// fetch这个指令的话,后续会梳理
```

#### fetch指令

![6c666ec139fe4dc5a08df6b811b9803d](https://s2.loli.net/2022/07/29/eHRS56VyYoxgQ1z.png)

我理解的就是将远程仓库内容更新到本地，最近与师姐开发项目过程中，使用的就是这个命令。

具体是这样子的👇

#### fetch推荐写法

```bash
git fetch origin <branch-name>:<local-branch-name>
```

- 一般而言，这个origin是远程主机名，一般默认就是origin。
- `branch-name` 你要拉取的分支
- `local-branch-name` 通常而言，就是你本地新建一个新分支，将origin下的某个分支代码下载到本地分支。

举个例子👇

```bash
git fetch origin feature/template_excellent:feature/template_layout
// 你的工作目录下，就会有feature/template_layout
// 一般情况下,我们需要做的就是在这个分支上开发新需求
// 完成代码后,我们需要做的就是上传我们的分支
```

#### fetch其他写法

- 将某个远程主机的更新，全部取回本地。

```bash
git fetch <远程主机名> 
```

- 这样子的话，取回的是所有的分支更新，如果想取回特定分支，可以指定分支名👇

```bash
git fetch <远程主机名> <分支名>
```

- 当你想将某个分支的内容取回到本地下某个分支的话，如下👇

```
git fetch origin :<local-branch-name>
// 等价于👇
git fetch origin master:<local-branch-name>
```

#### 花式撤销

[Git 误操作救命篇一： 如何将改动撤销？](https://zhuanlan.zhihu.com/p/42929114)

![f29320c710544828a494918b1ec2da05](https://s2.loli.net/2022/07/29/ZHWKpXxPiLJ5vwY.png)

撤销**工作区**修改

- git checkout --  

暂存区文件撤销 (不覆盖工作区)

- git reset HEAD 

版本回退

- git reset --(soft | mixed | hard )  < HEAD ~(num) > |  

- | 指令    | 作用范围                                |
  | ------- | --------------------------------------- |
  | --hard  | 回退全部，包括HEAD，index，working tree |
  | --mixed | 回退部分,包括HEAD，index                |
  | --soft  | 只回退HEAD                              |

git revert  用于回滚某一个（或多个）提交引入的更改

反转该提交引入的更改 并创建一个新的「回滚提交」记录反转更改 然后更新分支引用 使其指向该提交

#### 状态查询

- 查看状态
  - git status
- 查看历史操作记录
  - git reflog
- 查看日志
  - git log 

------

#### 文档查询

- 展示Git命令大纲
  - git help (--help)
- 展示Git命令大纲全部列表
  - git help -a
- 展示具体命令说明手册
  - git help

#### 文件暂存

![1b229cb4872e4991b33181cdad72b59d](https://s2.loli.net/2022/07/29/M9rfPWA4qg6Sstk.png)

- 添加改动到stash
  - git stash save -a “message”
- 删除暂存
  - git stash drop <`stash@{ID}`>
- 查看stash列表
  - git stash list
- 删除全部缓存
  - git stash clear
- 恢复改动
  - git stash pop <`stash@{ID}`>

#### 差异比较

![c779e736198247bfb0795b50dced0814](https://s2.loli.net/2022/07/29/FOQbe9EymYIRTkq.png)

比较工作区与缓存区

- git diff

比较缓存区与本地库最近一次commit内容

- git diff -- cached

比较工作区与本地最近一次commit内容

- git diff HEAD

比较两个commit之间差异

- git diff

#### 分支命名

![fd8abe5e5605411d8dbe5c4faa0054aa](https://s2.loli.net/2022/07/29/K8sBYQrMgjVywdk.png)

**master分支**

1. 主分支，用于部署生产环境的分支，确保稳定性。
2. master分支一般由develop以及hotfix分支合并，任何情况下都不能直接修改代码。

**develop 分支**

1. develop为开发分支，通常情况下，保存最新完成以及bug修复后的代码。
2. 开发新功能时，feature分支都是基于develop分支下创建的。

**feature分支**

1. 开发新功能，基本上以develop为基础创建feature分支。
2. 分支命名：feature/ 开头的为特性分支， 命名规则: feature/user_module、 feature/cart_module。

**这点我深有体会，我在网易，mentor就是这么教我的，**通常建一个feature分支。

**release分支**

1. release 为预上线分支，发布提测阶段，会release分支代码为基准提测。

**hotfix分支**

1. 分支命名：hotfix/ 开头的为修复分支，它的命名规则与 feature 分支类似。
2. 线上出现紧急问题时，需要及时修复，以master分支为基线，创建hotfix分支，修复完成后，需要合并到master分支和develop分支。

#### 基本操作

有了上述的基本了解后，那么我们就来看看整体的一个流程吧。

- 创建本地仓库 git init

  > git init

- 链接本地仓库与远端仓库

  > git remote add  origin 
  >
  > origin默认是远端仓库别名  url 可以是**可以使用https或者ssh的方式新建**

- 检查配置信息

  - git config --list

- Git user name 与email

  > git config --global user.name "yourname"
  >
  > git config --global user.email  "your_email"

- 生成SSH密钥

  > ssh-keygen -t rsa -C "这里换上你的邮箱"
  >
  > cd ~/.ssh 里面有一个文件名为id_rsa.pub,把里面的内容复制到git库的我的SSHKEYs中

- 常看远端仓库信息

  - git remote -v

- 远端仓库重新命名

  - git remote rename old new

- 提交到缓存区

  - git add .  全部上传到缓存区
  - git add   指定文件

- 提交到本地仓库

  - git commit -m 'some message'

- 提交远程仓库

  - git push <远程主机名> <本地分支名>:<远程分支名>

- 查看分支

  - git  branch

- 创建新分支

  - git branch 

- 切换分支

  - git checkout 

- 创建分支并切换

  - git checkout -b 

- 删除分支

  - git branch -d 

- 删除远程分支

  - git push -d  

- 切换分支

  - git checkout

### [Git 撤销操作实践之 Reset Revert Rebase](https://juejin.cn/post/6997042719138791460)

#### 数据准备

```bash
# 新建 git 环境
mkdir demo; cd demo ; git init

# 新建 reset 分支
git checkout -b dev

echo AAAAA > reset.txt
git add reset.txt
git commit -m "AAAAA"

echo BBBBB >> reset.txt
git add reset.txt
git commit -m "BBBBB"

echo CCCCC >> reset.txt
git add reset.txt
git commit -m "CCCCC"

echo DDDDD >> reset.txt
git add reset.txt
git commit -m "DDDDD"


# 此时的 git log 如下
$ git log --pretty=format:"%h %s" --graph

* d6212d8 DDDDD
* e807553 CCCCC
* 3609018 BBBBB
* a9fb808 AAAAA

# 此时的文件如下
$ cat reset.txt
AAAAA
BBBBB
CCCCC
DDDDD
```

#### git reset

该命令用于回退版本，可以指定退回某一次提交的版本，常见模式如下：

- `--mixed` 默认参数回退版本并将修改放入工作区
- `--soft` 回退版本并将修改放入暂存区
- `--hard` 回退版本并将修改丢弃

```bash
# 回退到上一版本
$ git reset HEAD^ 
# 指定文件回退到上一版本
$ git reset HEAD^ hello.php 
# 回退到指定版本
$ git  reset  3609018 
```

比如上面的 demo 仓库现在需要回到 BBBBB 的提交：

```bash
$ git reset --hard f64fbe6
HEAD is now at f64fbe6 BBBBB

$ cat reset.txt
AAAAA
BBBBB

$ git log --pretty=format:"%h %s" --graph
* f64fbe6 BBBBB
* 17a6e45 AAAAA
```





#### git revert

该命令与 reset 功能基本一致。需要注意的是此次操作之前和之后的commit和history 都会保留，并且把这次撤销作为一次最新的提交。比如实现 demo 仓库现在需要回到 BBBBB 的提交对应的操作为：

```bash
# 1. 执行撤销到的 commit
$ git revert f64fbe6
error: could not revert f64fbe6... BBBBB

# 2. 解决冲突

# 3. 提交修改
$ git commit -am "revert commit"

# 验证结果
$ cat reset.txt
AAAAA
BBBBB

$ git log --pretty=format:"%h %s" --graph
* a6fa241 revert commit
* 7dedf32 DDDDD
* a513f6c CCCCC
* f64fbe6 BBBBB
* 17a6e45 AAAAA
```

对比 `git reset` 来看 `git revert`保留了完整的提交历史，不会改变项目历史，对那些已经发布到共享仓库的提交来说这是一个安全的操作。

当然 revert 还可以指定回退的提交记录， 比如回退 BBBBB、CCCCC 两次提交：

**注意 `git diff 17a6e45..a513f6c` 左开右闭的区间。**

```bash
# 先 diff 查看对应的差异
git diff 17a6e45..a513f6c
# 回退revert
$ git reset --hard HEAD^

#  解决冲突

# 查看日志
$ git log --pretty=format:"%h %s" --graph
* 81a5d64 revert BC
* 7dedf32 DDDDD
* a513f6c CCCCC
* f64fbe6 BBBBB
* 17a6e45 AAAAA
```

#### git rebase

该命令是一个非常强大的命令，功能有很多。主要的功能是修改 git 的提交历史，常见的场景为合并提交记录、修改commit message等。

下面依旧是 git revert 中的例子撤销 BBBBB、CCCCC 两次提交：

```bash
# 先 diff 查看对应的差异
git diff 17a6e45..a513f6c
# rebase 前三次提交
$ git rebase -i HEAD~3

# 修改 commit 
d 515cfeb BBBBB
d 879218f CCCCC
pick 6a664ef DDDDD

# 解决冲突并存入暂存区间（git add reset.txt）

# 继续 rebase （弹出后默认保存既可，如需修改commit log 直接编辑）
git rebase --continue 

# 查看commit log
$ git log --pretty=format:"%h %s" --graph
* 989618e DDDDD
* 17a6e45 AAAAA
```

#### 总结

- `git reset` 最佳场景本地commit，一般是回退到指定版本。
- `git rebase` 可以新增、修改、删除 commit log，一般适用于展示完美的 commit log，方便于代码的 review。
- `git revert` 可以删除一次或多次 commit，并新增 commit log 的方式完成。适用于远程仓库的提交记录。记录所有的修改历史，方便 review commit log。

# 说说vue和react的异同

早就预料到可能会问这个, 因此之前自己有总结过: 

相同点:

- 核心库都只关注ui层面的问题解决，路由/状态管理都由其他库处理。

- 都使用了虚拟dom来提高重渲染效率。

- 都采用了组件化思想，将应用中不同功能抽象成一个组件，提高了代码复用性。

- 都能进行跨平台，react使用react native，vue使用weex

- 都有自己的构建工具:

  vue: vue-cli

  react: create-react-app

不同点:

- 最大的不同是组件的编写方式

  vue推荐使用类似于常规html模板的方式来编写组件, 基于vue强大的指令系统来进行数据的绑定和添加事件监听。在vue中，一个组件就是一个.vue文件。

  而react中采用jsx语法，每一个jsx表达式都是一个react元素. 在react中，一个组件本质就是一个函数或者一个类。

- 虚拟dom渲染效率方面

  由于vue对数据进行了劫持，因此每一个响应式数据都能进行依赖跟踪。当组件重新渲染时，不必重新渲染它的整个子组件树，而是只渲染应该重渲染的子组件。

  在react中，一旦组件状态变化导致重渲染后，其整个子组件树都会默认重新渲染。可以通过pureComponent或者shouldComponentUpdate来进行优化。

- 响应式方面

  vue由于使用defineProperty或者proxy, 能对数据进行劫持。因此只要修改了响应式数据本身就能导致组件的重渲染。

  而在react中，并没有对数据本身进行劫持，需要手动调用setState才能触发组件的重渲染。并且react强调使用不可变数据，即每次更改状态时，新状态的引用必须和旧状态不同。如果说没有使用不可变数据并且又在组件内使用了pureComponent或者shouldComponentUpdate进行优化，可能会导致状态变化组件没有重新渲染。

- 高阶组件

  react中存在HOC(高阶组件)的概念，因为react中的每一个组件本质都是一个函数或者类，都是编写在js代码中。因此可以轻松的实现高阶组件来对组件进行扩展。而vue采用模板编译的方式编写组件，无法使用HOC, 通常通过mixin来扩展组件.

- 指令系统

  vue有一套强大的指令系统并且支持自定义指令来封装一些功能。

  react则更偏向底层，使用javascript原生代码进行封装功能。

  ## 说说vue3的composition api 和 react hook的区别？

  这个也算是预判到了, 当时想着如果问了vue和react的对比很有可能会问这个. 之前也做过总结:

  react:

    由于react没有实现真正的数据双向绑定即没有对数据进行劫持，react是依靠hook的调用顺序来知道重渲染时，本次的state对应于哪一个useState hook。因此在react中使用hook有如下要求:

  - 不能在循环/判断/嵌套函数内使用hook
  - 总是确保hook出现在函数组件的最顶部
  - 对于一些hook如useEffect, useMemo, useCallBack, 必须手动注册依赖项。

  而在vue中, 基于vue的响应式系统，composiiton api在调用时可以不用考虑顺序并且能使用在判断/循环/内部函数中。并且由于vue的响应式数据会自动收集依赖，因此使用一些composiiton api如computed以及watchEffect时无需手动注册依赖。

  

  后面基本是一些小的问题比如:

  - vue中的scoped style是如何实现作用域样式以及为什么vue不使用css module来实现作用域？
  - 为什么vue要将传递给子组件的属性分为props和$attrs?  (这个不会, 把props和$attrs的区别说了一下)
  - 说说最近学习的新技术？

  ​    我直接坦白了最近都在准备面试没有学新技术, 然后面试官问准备面试过程有哪些提升？

     我回答了对vue的响应式系统原理理解更深入了以及对http协议了解更多了, 然后面试官让我说说这些提升在具体中的项目的应用有哪些？

     说了this.$nextTick和vue的异步更新队列在项目中的应用。

  

  

  

## React和Vue diff算法的区别

vue与react都推崇组件式的开发理念，但是在设计的核心思想上有很大差别。

### vue

vue的整体思想仍然是拥抱经典的html(结构)+css(表现)+js(行为)的形式，vue鼓励开发者使用template模板，并提供指令供开发者使用(v-if、v-show、v-for等等)，因此在开发vue应用的时候会有一种在写经典web应用（结构、表现、行为分离）的感觉。另一方面，在针对组件数据上，vue2.0通过`Object.defineProperty`对数据做到了更细致的监听，精准实现组件级别的更新。

### react

react整体上是函数式的思想，组件使用jsx语法，all in js，将html与css全都融入javaScript，jsx语法相对来说更加灵活，我一开始刚转过来也不是很适应，感觉写react应用感觉就像是在写javaScript。当组件调用setState或props变化的时候，组件内部render会重新渲染，子组件也会随之重新渲染，可以通过`shouldComponentUpdate`或者`PureComponent`可以避免不必要的重新渲染（个人感觉这一点上不如vue做的

。

## 对框架的理解

因为我是vue2和react都学过, 在简历里面都写了，所以两个框架都问到了。

#### 说说vue和react的异同

早就预料到可能会问这个, 因此之前自己有总结过: 

相同点:

- 核心库都只关注ui层面的问题解决，路由/状态管理都由其他库处理。

- 都使用了虚拟dom来提高重渲染效率。

- 都采用了组件化思想，将应用中不同功能抽象成一个组件，提高了代码复用性。

- 都能进行跨平台，react使用react native，vue使用weex

- 都有自己的构建工具:

  vue: vue-cli

  react: create-react-app

不同点:

- 最大的不同是组件的编写方式

  vue推荐使用类似于常规html模板的方式来编写组件, 基于vue强大的指令系统来进行数据的绑定和添加事件监听。在vue中，一个组件就是一个.vue文件。

  而react中采用jsx语法，每一个jsx表达式都是一个react元素. 在react中，一个组件本质就是一个函数或者一个类。

- 虚拟dom渲染效率方面

  由于vue对数据进行了劫持，因此每一个响应式数据都能进行依赖跟踪。当组件重新渲染时，不必重新渲染它的整个子组件树，而是只渲染应该重渲染的子组件。

  在react中，一旦组件状态变化导致重渲染后，其整个子组件树都会默认重新渲染。可以通过pureComponent或者shouldComponentUpdate来进行优化。

- 响应式方面

  vue由于使用defineProperty或者proxy, 能对数据进行劫持。因此只要修改了响应式数据本身就能导致组件的重渲染。

  而在react中，并没有对数据本身进行劫持，需要手动调用setState才能触发组件的重渲染。并且react强调使用不可变数据，即每次更改状态时，新状态的引用必须和旧状态不同。如果说没有使用不可变数据并且又在组件内使用了pureComponent或者shouldComponentUpdate进行优化，可能会导致状态变化组件没有重新渲染。

- 高阶组件

  react中存在HOC(高阶组件)的概念，因为react中的每一个组件本质都是一个函数或者类，都是编写在js代码中。因此可以轻松的实现高阶组件来对组件进行扩展。而vue采用模板编译的方式编写组件，无法使用HOC, 通常通过mixin来扩展组件.

- 指令系统

  vue有一套强大的指令系统并且支持自定义指令来封装一些功能。

  react则更偏向底层，使用javascript原生代码进行封装功能。

### 说说vue3的composition api 和 react hook的区别？

这个也算是预判到了, 当时想着如果问了vue和react的对比很有可能会问这个. 之前也做过总结:

react:

  由于react没有实现真正的数据双向绑定即没有对数据进行劫持，react是依靠hook的调用顺序来知道重渲染时，本次的state对应于哪一个useState hook。因此在react中使用hook有如下要求:

- 不能在循环/判断/嵌套函数内使用hook
- 总是确保hook出现在函数组件的最顶部
- 对于一些hook如useEffect, useMemo, useCallBack, 必须手动注册依赖项。

而在vue中, 基于vue的响应式系统，composiiton api在调用时可以不用考虑顺序并且能使用在判断/循环/内部函数中。并且由于vue的响应式数据会自动收集依赖，因此使用一些composiiton api如computed以及watchEffect时无需手动注册依赖。

## 传统Diff算法

> 处理方案: 循环递归每一个节点

## 优化的Diff算法

vue和react的虚拟DOM的diff算法大致相同，其核心是基于两个简单的假设:

1. 两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构
2. 同一层级的一组节点，他们可以通过唯一的id进行区分



### React优化Diff算法

> 基于以上优化的diff三点策略，react分别进行以下算法优化

- tree diff
- component diff
- element diff

###### tree diff

react对树的算法进行了分层比较。react 通过 updateDepth对Virtual Dom树进行层级控制，只会对相同层级的节点进行比较，即同一个父节点下的所有子节点。当发现节点不存在，则该节点和其子节点都会被删除。这样是需要遍历一次dom树，就完成了整个dom树的对比

###### component diff

- 如果是同类型的组件，则直接对比virtual Dom tree
- 如果不是同类型的组件，会直接替换掉组件下的所有子组件
- 如果类型相同，但是可能virtual DOM 没有变化，这种情况下我们可以使用shouldComponentUpdate() 来判断是否需要进行diff

###### **element diff**

移动优化  
 在移动前，会将节点在新集合中的位置和在老集合中lastIndex进行比较，如果if (child._mountIndex < lastIndex) 进行移动操作，否则不进行移动操作。这是一种顺序移动优化。只有在新集合的位置 小于 在老集合中的位置 才进行移动。

如果遍历的过程中，发现在新集合中没有，但是在老集合中的节点，会进行删除操作

所以：element diff 通过唯一key 进行diff 优化。

### Vue优化Diff

差异就在于, diff的过程就是调用patch函数，就像打补丁一样修改真实dom

- patchVnode
- updateChildren
- updateChildren是vue diff的核心
  过程可以概括为：oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx>EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较

#### Vue 2.x vs Vue 3.x

Vue2的核心Diff算法采用了双端比较的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅

Vue3.x借鉴了 ivi算法和 inferno算法。在创建VNode时就确定其类型，以及在mount/patch的过程中采用位运算来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。(实际的实现可以结合Vue3.x源码看



下面的diff算法中会出现几个方法，在这里进行罗列，并说明其功能

-   `mount(vnode, parent, [refNode])`: 通过`vnode`生成真实的`DOM`节点。`parent`为其父级的真实DOM节点，`refNode`为真实的`DOM`节点，其父级节点为`parent`。如果`refNode`不为空，`vnode`生成的`DOM`节点就会插入到`refNode`之前；如果`refNode`为空，那么`vnode`生成的`DOM`节点就作为最后一个子节点插入到`parent`中

-   `patch(prevNode, nextNode, parent)`: 可以简单的理解为给当前`DOM`节点进行更新，并且调用`diff`算法对比自身的子节点;

## 一、React-Diff

React的思路是递增法。通过对比新的列表中的节点，在原本的列表中的位置是否是递增，来判断当前节点是否需要移动。

## 1\. 实现原理

来看这样一个例子。

![](https://s2.loli.net/2022/07/08/aTO4pknHGWEDZfy.webp)

`nextList`为新的列表，`prevList`为旧列表。这个例子我们一眼能看出来，新列表是不需要进行移动的。下面我用`react`的递增思想，解释一下为什么新列表中的节点不需要移动。

我们首先遍历`nextList`，并且找到每一个节点，在`prevList`中的位置。



找到位置以后，与上一个节点的位置进行对比，如果当前的位置大于上一个位置，说明当前节点不需要移动。因此我们要定义一个`lastIndex`来记录上一个节点的位置。



在上面的例子中，`nextList`每个节点在`prevList`的位置为`0 1 2 3`。每一项都要比前一项要大，所以不需要移动，这就是`react`的`diff`算法的原理。

## 2\. 找到需要移动的节点

在上一小节中，我们是通过对比值是否相等，查找的对应位置。但是在vdom中，每一个节点都是一个vNode，我们应该如何进行判断呢？

答案就是`key`，我们通过对每个节点的`key`进行赋值，并且让处于同一`children`数组下的`vnode`的`key`都不相同，以此来确定每个节点的唯一性，并进行新旧列表的对比。



## 3\. 移动节点

首先我们先明确一点，移动节点所指的节点是`DOM`节点。`vnode.el`指向该节点对应的真实`DOM`节点。`patch`方法会将更新过后的`DOM`节点，赋值给**新的**`vnode`的`el`属性。

> 为了画图方便，我们用`key`的值来表示`vnode`节点。为了行文方便，我们把`key`值为`a`的`vnode`简写为`vnode-a`，`vnode-a`对应的真实DOM节点为`DOM-A`

![](https://s2.loli.net/2022/07/08/3oelWi2CAM6jqbn.webp)

我们来将上图的例子代入`reactDiff`中执行。我们遍历**新列表**，并查找`vnode`在**旧列表**中的位置。当遍历到`vnode-d`时，之前遍历在**旧列表**的位置为`0 < 2 < 3`，说明`A C D`这三个节点都是不需要移动的。此时`lastIndex = 3`, 并进入下一次循环，发现`vnode-b`在**旧列表**的`index`为`1`，`1 < 3`，说明`DOM-B`要移动。

通过观察我们能发现，只需要把`DOM-B`移动到`DOM-D`之后就可以了。也就是**找到需要移动的VNode，我们称该VNode为α，将α对应的真实的DOM节点移动到，α在`新列表`中的前一个VNode对应的真实DOM的后面。**

![](https://s2.loli.net/2022/07/08/BdAimSnMgp1yYTZ.webp)

在上述的例子中，就是将`vnode-b`对应的真实DOM节点`DOM-B`, 移动到`vnode-b`在新列表中的前一个`VNode`——`vnode-d`对应的真实DOM节点`DOM-D`的后面。



为什么是这样移动的呢？首先我们列表是`从头到尾`遍历的。这就意味着对于当前`VNode`节点来说，该节点之前的所有节点都是排好序的，如果该节点需要移动，那么只需要将DOM节点移动到前一个`vnode`节点之后就可以，因为在**新列表**中`vnode`的顺序就是这样的。

## 4\. 添加节点

上一小节我们只讲了如何移动节点，但是忽略了另外一种情况，就是在**新列表**中有全新的`VNode`节点，在**旧列表**中找不到。遇到这种情况，我们需要根据新的`VNode`节点生成`DOM`节点，并插入`DOM`树中。

至此，我们面临两个问题：1.如何发现全新的节点、2. 生成的`DOM`节点插入到哪里

![](https://s2.loli.net/2022/07/08/VawfOq57BWxzGRp.webp)

我们先来解决第一个问题，找节点还是比较简单的，我们定义一个`find`变量值为`false`。如果在**旧列表**找到了`key` 相同的`vnode`，就将`find`的值改为`true`。当遍历结束后判断`find`值，如果为`false`，说明当前节点为新节点。



找到新节点后，下一步就是插入到哪里了，这里的逻辑其实是和移动节点的逻辑是一样的。我们观察上图可以发现，新的`vnode-c`是紧跟在`vnode-b`后面的，并且`vnode-b`的DOM节点——`DOM-B`是已经排好序的，所以我们只需要将`vnode-c`生成的DOM节点插入到`DOM-B`之后就可以了。

但是这里有一种特殊情况需要注意，就是新的节点位于**新列表**的第一个，这时候我们需要找到**旧列表**第一个节点，将新节点插入到原来第一个节点之前就可以了。



## 5\. 移除节点

有增就有减，当旧的节点不在**新列表**中时，我们就将其对应的DOM节点移除。

![](https://s2.loli.net/2022/07/08/G8PKdTWeE1LObyC.webp)



### 6.优化与不足

以上就是React的diff算法的思路。

目前的`reactDiff`的时间复杂度为`O(m*n)`，我们可以用空间换时间，把`key`与`index`的关系维护成一个`Map`，从而将时间复杂度降低为`O(n)`，具体的代码可以[查看此项目](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fsunyanzhe%2Fvirtual-dom%2Fblob%2Fmaster%2Fsrc%2Fdiff%2Freact-diff.js "https://github.com/sunyanzhe/virtual-dom/blob/master/src/diff/react-diff.js")。

我们接下来看这样一个例子

![](https://s2.loli.net/2022/07/08/51Tn8MEzkvwRYB9.webp)

根据`reactDiff`的思路，我们需要先将`DOM-A`移动到`DOM-C`之后，然后再将`DOM-B`移动到`DOM-A`之后，完成`Diff`。但是我们通过观察可以发现，只要将`DOM-C`移动到`DOM-A`之前就可以完成`Diff`。

这里是有可优化的空间的，接下来我们介绍`vue2.x`中的`diff`算法——`双端比较`，该算法解决了上述的问题

## 二、Vue2.X Diff —— 双端比较

所谓`双端比较`就是**新列表**和**旧列表**两个列表的头与尾互相对比，，在对比的过程中指针会逐渐向内靠拢，直到某一个列表的节点全部遍历过，对比停止。

## 1\. 实现原理

我们先用四个指针指向两个列表的头尾



我们根据四个指针找到四个节点，然后进行对比，那么如何对比呢？我们按照以下四个步骤进行对比

1.  使用**旧列表**的头一个节点`oldStartNode`与**新列表**的头一个节点`newStartNode`对比
2.  使用**旧列表**的最后一个节点`oldEndNode`与**新列表**的最后一个节点`newEndNode`对比
3.  使用**旧列表**的头一个节点`oldStartNode`与**新列表**的最后一个节点`newEndNode`对比
4.  使用**旧列表**的最后一个节点`oldEndNode`与**新列表**的头一个节点`newStartNode`对比

使用以上四步进行对比，去寻找`key`相同的可复用的节点，当在某一步中找到了则停止后面的寻找。具体对比顺序如下图

![](https://s2.loli.net/2022/07/08/a3wtouvTcAYqH5g.webp)

对比顺序代码结构如下:



当对比时找到了可复用的节点，我们还是先`patch`给元素打补丁，然后将指针进行`前/后移`一位指针。根据对比节点的不同，我们移动的**指针**和**方向**也不同，具体规则如下：

1.  当**旧列表**的头一个节点`oldStartNode`与**新列表**的头一个节点`newStartNode`对比时`key`相同。那么**旧列表**的头指针`oldStartIndex`与**新列表**的头指针`newStartIndex`同时向**后**移动一位。
2.  当**旧列表**的最后一个节点`oldEndNode`与**新列表**的最后一个节点`newEndNode`对比时`key`相同。那么**旧列表**的尾指针`oldEndIndex`与**新列表**的尾指针`newEndIndex`同时向**前**移动一位。
3.  当**旧列表**的头一个节点`oldStartNode`与**新列表**的最后一个节点`newEndNode`对比时`key`相同。那么**旧列表**的头指针`oldStartIndex`向**后**移动一位；**新列表**的尾指针`newEndIndex`向**前**移动一位。
4.  当**旧列表**的最后一个节点`oldEndNode`与**新列表**的头一个节点`newStartNode`对比时`key`相同。那么**旧列表**的尾指针`oldEndIndex`向**前**移动一位；**新列表**的头指针`newStartIndex`向**后**移动一位。



在小节的开头，提到了要让指针向内靠拢，所以我们需要循环。循环停止的条件是当其中一个列表的节点全部遍历完成，代码如下



至此整体的循环我们就全部完成了，下面我们需要考虑这样两个问题：

-   什么情况下`DOM`节点需要移动
-   `DOM`节点如何移动

我们来解决第一个问题：**什么情况下需要移动**，我们还是以上图为例。

![](https://s2.loli.net/2022/07/08/7pRIHhlN1bLPmnf.webp)

当我们在第一个循环时，在`第四步`发现**旧列表的尾节点**`oldEndNode`与**新列表的头节点**`newStartNode`的`key`相同，是可复用的`DOM`节点。通过观察我们可以发现，**原本在旧列表末尾的节点，却是新列表中的开头节点，没有人比他更靠前，因为他是第一个，所以我们只需要把当前的节点移动到原本旧列表中的第一个节点之前，让它成为第一个节点即可**。



![](https://s2.loli.net/2022/07/08/Rgapx1LK2n5NemX.webp)

然后我们进入第二次循环，我们在`第二步`发现，**旧列表的尾节点**`oldEndNode`和**新列表的尾节点**`newEndNode`为复用节点。**原本在旧列表中就是尾节点，在新列表中也是尾节点，说明该节点不需要移动**，所以我们什么都不需要做。

同理，如果是**旧列表的头节点**`oldStartNode`和**新列表的头节点**`newStartNode`为复用节点，我们也什么都不需要做。

![](https://s2.loli.net/2022/07/08/5va2NghAwlYHOEx.webp)

进入第三次循环，我们在`第三部`发现，**旧列表的头节点**`oldStartNode`和**新列表的尾节点**`newEndNode`为复用节点。到这一步聪明如你肯定就一眼可以看出来了，我们只要将`DOM-A`移动到`DOM-B`后面就可以了。

依照惯例我们还是解释一下，**原本旧列表中是头节点，然后在新列表中是尾节点。那么只要在旧列表中把当前的节点移动到原本尾节点的后面，就可以了**。



![](https://s2.loli.net/2022/07/08/vbMdFuBENUVCLYQ.webp)

OK，进入最后一个循环。在`第一步`**旧列表**头节点`oldStartNode`与**新列表**头节点`newStartNode`位置相同，所以啥也不用做。然后结束循环，这就是`Vue2 双端比较`的原理。

## 2\. 非理想情况

上一小节，我们讲了`双端比较`的原理，但是有一种特殊情况，当四次对比都**没找到**复用节点时，我们只能拿**新列表**的第一个节点去**旧列表**中找与其`key`相同的节点。

![](https://s2.loli.net/2022/07/08/IUDbXEwOingmRFt.webp)。



找节点的时候其实会有两种情况：一种在**旧列表**中找到了，另一种情况是没找到。我们先以上图为例，说一下找到的情况。

![](https://s2.loli.net/2022/07/08/5GPckZi9dN6V7rS.webp)

当我们在旧列表中找到对应的`VNode`，我们只需要将找到的节点的`DOM`元素，移动到开头就可以了。这里的逻辑其实和`第四步`的逻辑是一样的，只不过`第四步`是移动的尾节点，这里是移动找到的节点。`DOM`移动后，由我们将**旧列表**中的节点改为`undefined`，这是**至关重要**的一步，因为我们已经做了节点的移动了所以我们不需要进行再次的对比了。最后我们将头指针`newStartIndex`向后移一位。

```

```

如果在**旧列表**中没有找到复用节点呢？很简单，直接创建一个新的节点放到最前面就可以了，然后后移头指针`newStartIndex`。

![](https://s2.loli.net/2022/07/08/dsWxAEQwLHOZ5zV.webp)

```
function vue2Diff(prevChildren, nextChildren, parent) {
  //...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
    if (oldStartNode.key === newStartNode.key) {
    //...
    } else if (oldEndNode.key === newEndNode.key) {
    //...
    } else if (oldStartNode.key === newEndNode.key) {
    //...
    } else if (oldEndNode.key === newStartNode.key) {
    //...
    } else {
      // 在旧列表中找到 和新列表头节点key 相同的节点
      let newtKey = newStartNode.key,
        oldIndex = prevChildren.findIndex(child => child.key === newKey);
      
      if (oldIndex > -1) {
        let oldNode = prevChildren[oldIndex];
        patch(oldNode, newStartNode, parent)
        parent.insertBefore(oldNode.el, oldStartNode.el)
        prevChildren[oldIndex] = undefined
      } else {
      mount(newStartNode, parent, oldStartNode.el)
      }
      newStartNode = nextChildren[++newStartIndex]
    }
  }
}
```

最后当**旧列表**遍历到`undefind`时就跳过当前节点。

```
function vue2Diff(prevChildren, nextChildren, parent) {
  //...
  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {
    if (oldStartNode === undefind) {
    oldStartNode = prevChildren[++oldStartIndex]
    } else if (oldEndNode === undefind) {
    oldEndNode = prevChildren[--oldEndIndex]
    } else if (oldStartNode.key === newStartNode.key) {
    //...
    } else if (oldEndNode.key === newEndNode.key) {
    //...
    } else if (oldStartNode.key === newEndNode.key) {
    //...
    } else if (oldEndNode.key === newStartNode.key) {
    //...
    } else {
    // ...
    }
  }
}
```

## 3.添加节点

我们先来看一个例子

![](https://s2.loli.net/2022/07/08/RkDJpTy3ZzftCx7.webp)

这个例子非常简单，几次循环都是尾节点相同，尾指针一直向前移动，直到循环结束，如下图

![](https://s2.loli.net/2022/07/08/UyQFfXzxEV8ampB.webp)

此时`oldEndIndex`以及小于了`oldStartIndex`，但是**新列表**中还有剩余的节点，我们只需要将剩余的节点依次插入到`oldStartNode`的`DOM`之前就可以了。为什么是插入`oldStartNode`之前呢？原因是剩余的节点在**新列表**的位置是位于`oldStartNode`之前的，如果剩余节点是在`oldStartNode`之后，`oldStartNode`就会先行对比，这个需要思考一下，其实还是与`第四步`的思路一样。



## 4.移除节点

与上一小节的情况相反，当**新列表**的`newEndIndex`小于`newStartIndex`时，我们将**旧列表**剩余的节点删除即可。这里我们需要注意，**旧列表**的`undefind`。在第二小节中我们提到过，当头尾节点都不相同时，我们会去**旧列表**中找**新列表**的第一个节点，移动完DOM节点后，将**旧列表**的那个节点改为`undefind`。所以我们在最后的删除时，需要注意这些`undefind`，遇到的话跳过当前循环即可。



## 5.小结

至此`双端比较`全部完成，以下是全部代码。

```
function vue2diff(prevChildren, nextChildren, parent) {
  let oldStartIndex = 0,
    newStartIndex = 0,
    oldStartIndex = prevChildren.length - 1,
    newStartIndex = nextChildren.length - 1,
    oldStartNode = prevChildren[oldStartIndex],
    oldEndNode = prevChildren[oldStartIndex],
    newStartNode = nextChildren[newStartIndex],
    newEndNode = nextChildren[newStartIndex];
  while (oldStartIndex <= oldStartIndex && newStartIndex <= newStartIndex) {
    if (oldStartNode === undefined) {
      oldStartNode = prevChildren[++oldStartIndex]
    } else if (oldEndNode === undefined) {
      oldEndNode = prevChildren[--oldStartIndex]
    } else if (oldStartNode.key === newStartNode.key) {
      patch(oldStartNode, newStartNode, parent)

      oldStartIndex++
      newStartIndex++
      oldStartNode = prevChildren[oldStartIndex]
      newStartNode = nextChildren[newStartIndex]
    } else if (oldEndNode.key === newEndNode.key) {
      patch(oldEndNode, newEndNode, parent)

      oldStartIndex--
      newStartIndex--
      oldEndNode = prevChildren[oldStartIndex]
      newEndNode = nextChildren[newStartIndex]
    } else if (oldStartNode.key === newEndNode.key) {
      patch(oldStartNode, newEndNode, parent)
      parent.insertBefore(oldStartNode.el, oldEndNode.el.nextSibling)
      oldStartIndex++
      newStartIndex--
      oldStartNode = prevChildren[oldStartIndex]
      newEndNode = nextChildren[newStartIndex]
    } else if (oldEndNode.key === newStartNode.key) {
      patch(oldEndNode, newStartNode, parent)
      parent.insertBefore(oldEndNode.el, oldStartNode.el)
      oldStartIndex--
      newStartIndex++
      oldEndNode = prevChildren[oldStartIndex]
      newStartNode = nextChildren[newStartIndex]
    } else {
      let newKey = newStartNode.key,
        oldIndex = prevChildren.findIndex(child => child && (child.key === newKey));
      if (oldIndex === -1) {
        mount(newStartNode, parent, oldStartNode.el)
      } else {
        let prevNode = prevChildren[oldIndex]
        patch(prevNode, newStartNode, parent)
        parent.insertBefore(prevNode.el, oldStartNode.el)
        prevChildren[oldIndex] = undefined
      }
      newStartIndex++
      newStartNode = nextChildren[newStartIndex]
    }
  }
  if (newStartIndex > newStartIndex) {
    while (oldStartIndex <= oldStartIndex) {
      if (!prevChildren[oldStartIndex]) {
        oldStartIndex++
        continue
      }
      parent.removeChild(prevChildren[oldStartIndex++].el)
    }
  } else if (oldStartIndex > oldStartIndex) {
    while (newStartIndex <= newStartIndex) {
      mount(nextChildren[newStartIndex++], parent, oldStartNode.el)
    }
  }
}
```

## 三、 Vue3 Diff —— 最长递增子序列

`vue3`的`diff`借鉴于[inferno](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Finfernojs%2Finferno "https://github.com/infernojs/inferno")，该算法其中有两个理念。第一个是相同的前置与后置元素的预处理；第二个则是最长递增子序列，此思想与`React`的`diff`类似又不尽相同。下面我们来一一介绍。

## 1\. 前置与后置的预处理

我们看这两段文字

`Hello World`

`Hey World`

其实就简单的看一眼我们就能发现，这两段文字是有一部分是相同的，**这些文字是不需要修改也不需要移动的**，真正需要进行修改中间的几个字母，所以`diff`就变成以下部分

```
text1: 'llo'
text2: 'y'
```

接下来换成`vnode`，我们以下图为例。

![](https://s2.loli.net/2022/07/08/T5OehmxvEkRFM2b.webp)

图中的被绿色框起来的节点，他们是不需要移动的，只需要进行打补丁`patch`就可以了。我们把该逻辑写成代码。



这时候，我们就需要考虑边界情况了，这里有两种情况。一种是`j > prevEnd`；另一种是`j > nextEnd`。

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52779ed5f26a451d8098e945709132cf~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

我们以这张图为例，此时`j > prevEnd`且`j <= nextEnd`，我们只需要把**新列表**中`j`到`nextEnd`之间剩下的节点**插入**进去就可以了。相反， 如果`j > nextEnd`时，我们把**旧列表**中`j`到`prevEnd`之间的节点**删除**就可以了。



我们再继续思考，在我们`while`循环时，指针是从两端向内逐渐靠拢的，所以我们应该在循环中就应该去判断边界情况，我们使用`label`语法，当我们触发边界情况时，退出全部的循环，直接进入判断。代码如下：



## 2\. 判断是否需要移动

其实几个算法看下来，套路已经很明显了，就是找到移动的节点，然后给他移动到正确的位置。把该加的新节点添加好，把该删的旧节点删了，整个算法就结束了。这个算法也不例外，我们接下来看一下它是如何做的。

当`前/后置`的预处理结束后，我们进入真正的`diff`环节。首先，我们先根据**新列表**剩余的节点数量，创建一个`source`数组，并将数组填满`-1`。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75944ec3b6a245989a0eaf7e474ef174~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

我们先写这块逻辑。



那么这个`source`数组，是要做什么的呢？他就是来做新旧节点的对应关系的，我们将**新节点**在**旧列表**的位置存储在该数组中，我们在根据`source`计算出它的`最长递增子序列`用于移动DOM节点。为此，我们先建立一个对象存储当前**新列表**中的`节点`与`index`的关系，再去**旧列表**中去找位置。

在找节点时要注意，**如果旧节点在新列表中没有的话，直接删除就好**。除此之外，我们还需要一个数量表示记录我们已经`patch`过的节点，如果数量已经与**新列表**剩余的节点数量一样，那么剩下的`旧节点`我们就直接删除了就可以了



![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/01f5d145e4a84e3f922b4d39f80bcb6a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

找到位置后，我们观察这个重新赋值后的`source`，我们可以看出，如果是全新的节点的话，其在`source`数组中对应的值就是初始的`-1`，通过这一步我们可以区分出来哪个为全新的节点，哪个是可复用的。

其次，我们要判断是否需要移动。那么如何判断移动呢？很简单，和`React`一样我们用递增法，如果我们找到的`index`是一直递增的，说明不需要移动任何节点。我们通过设置一个变量来保存是否需要移动的状态。



## 3\. DOM如何移动

判断完是否需要移动后，我们就需要考虑如何移动了。一旦需要进行DOM移动，我们首先要做的就是找到`source`的**最长递增子序列**。

```
function vue3Diff(prevChildren, nextChildren, parent) {
  //...
  if (move) {
const seq = lis(source); // [0, 1]
  // 需要移动
  } else {

  //不需要移动
  }
}
```

> 什么是最长递增子序列：给定一个数值序列，找到它的一个子序列，并且子序列中的值是递增的，子序列中的元素在原序列中不一定连续。
>
> 例如给定数值序列为：\[ 0, 8, 4, 12 \]。
>
> 那么它的最长递增子序列就是：\[0, 8, 12\]。
>
> 当然答案可能有多种情况，例如：\[0, 4, 12\] 也是可以的。

> 我们在下一节单独讲解最长递增子序列

上面的代码中，我们调用`lis` 函数求出数组`source`的最长递增子序列为`[ 0, 1 ]`。我们知道 source 数组的值为 `[2, 3, 1, -1]`，很显然最长递增子序列应该是`[ 2, 3 ]`，但为什么计算出的结果是`[ 0, 1 ]`呢？其实`[ 0, 1 ]`代表的是最长递增子序列中的各个元素在`source`数组中的位置索引，如下图所示：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81c80851ea784e03b3c995234c70e9a3~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

我们根据`source`，对**新列表**进行重新编号，并找出了`最长递增子序列`。

我们从后向前进行遍历`source`每一项。此时会出现三种情况：

1.  当前的值为`-1`，这说明该节点是全新的节点，又由于我们是**从后向前**遍历，我们直接创建好DOM节点插入到队尾就可以了。
2.  当前的索引为`最长递增子序列`中的值，也就是`i === seq[j]`，这说说明该节点不需要移动
3.  当前的索引不是`最长递增子序列`中的值，那么说明该DOM节点需要移动，这里也很好理解，我们也是直接将DOM节点插入到队尾就可以了，因为队尾是排好序的。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6563127dd6cf4aa6b23ed5361a321a32~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)



说完了需要移动的情况，再说说不需要移动的情况。如果不需要移动的话，我们只需要判断是否有全新的节点给他添加进去就可以了。具体代码如下：



至此`vue3.0`的diff完成。

# 对微前端的看法?

**微前端：云时代的前端开发模式**

微前端（Micro-Frontends）概念是2016年底提出，距今已有五年多时间的沉淀，目前在前端领域也有较为广泛地应用。微前端（Micro-Frontends）是一种类似于微服务的架构，是一种由独立交付的多个前端应用组成整体的架构风格，将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的应用，而在用户看来仍然是内聚的单个产品。



# 购物车线上线下分离操作

[^目的：了解购物车两种状态下的操作逻辑，方便后续的开发理解。]: 



> ![1614324821761](https://s2.loli.net/2022/07/08/quaZ982ElhGkNid.png)

总结：

- 购物车的各种操作都会有两种状态的区分，但是不会在组件中去区分。
- 而是在封装在vuex中的actions中去区分，在组件上只需调用actions即可。
- 在actions中通过user信息去区分登录状态
  - 未登录，通过mutations修改vuex中的数据即可，vuex已经实现持久化，会同步保持在本地。
  - 已登录，通过api接口去服务端操作，响应成功后通过mutations修改vuex中的数据即可，它也会同步在本地。
- 不管何种操作何种状态返回一个promise，然后组件能够判断操作是否完毕是否成功，再而去做其他事情。

注意：

- 登录后，需要合并本地购物车到服务端。
- 退出后，清空vuex数据也会同步清空本地数据。

# vuex-持久化

[^目的：让在vuex中管理的状态数据同时存储在本地。可免去自己存储的环节。]: 

### 配置

vuex-persistedstate默认持久化所有state，指定需要持久化的state移步官网API：[vuex-persistedstate](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fvuex-persistedstate)

plugins提供三种方式存储 (localStorage、sessionStorage、cookie) 默认localStorage

可根据个人喜好配置plugins

> localStorage

```php
export default new Vuex.Store({
  modules: {
    user
  },
  strict: debug,
  plugins: [
    createPersistedState() // 默认localstorage
  ]
})
复制代码
```

> sessionStorage

```php
export default new Vuex.Store({
  modules: {
    user
  },
  strict: debug,
  plugins: [
    createPersistedState({
        storage: window.sessionStorage
    })
  ]
})
复制代码
```

> cookie

### 安装

```
npm install js-cookie
复制代码
```

### 引入

```javascript
import * as Cookies from 'js-cookie'
复制代码
```

### 具体写法

```vbnet
export default new Vuex.Store({
  modules: {
    user
  },
  strict: debug,
  plugins: [
    createPersistedState({
      storage: {
        getItem: key => Cookies.get(key),
        setItem: (key, value) => Cookies.set(key, value, { expires: 1 }),
        removeItem: key => Cookies.remove(key)
      }
    })
  ]
})
复制代码
```

### 附上完整代码

```javascript
import Vue from 'vue'
import Vuex from 'vuex'
import user from './modules/user'
import createPersistedState from 'vuex-persistedstate'
import * as Cookies from 'js-cookie'

Vue.use(Vuex)

const debug = process.env.NODE_ENV !== 'production'

export default new Vuex.Store({
  modules: {
    user
  },
  strict: debug,
  plugins: [
    createPersistedState({
      storage: {
        getItem: key => Cookies.get(key),
        setItem: (key, value) => Cookies.set(key, value, { expires: 1 }),
        removeItem: key => Cookies.remove(key)
      }
    })
  ]
})
复制代码
```

### 有没有大佬知道cookie方式为什么要这样写？

```vbnet
storage: {
        getItem: key => Cookies.get(key),
        setItem: (key, value) => Cookies.set(key, value, { expires: 1 }),
        removeItem: key => Cookies.remove(key)
      }
```



cookie之所以这样写是因为源码里需要用到getItem、setItem这些方法，当storage为cookie的时候没有这些默认api，所以需要手动补充

# less的自动化导入

**1）准备要用的变量和混入代码**

- 变量 `src/assets/styles/variables.less`

```less
// 主题
@xtxColor:#27BA9B;
// 辅助
@helpColor:#E26237;
// 成功
@sucColor:#1DC779;
// 警告
@warnColor:#FFB302;
// 价格
@priceColor:#CF4444;
```

- 混入 `src/assets/styles/mixins.less`

```less
// 鼠标经过上移阴影动画
.hoverShadow () {
  transition: all .5s;
  &:hover {
    transform: translate3d(0,-3px,0);
    box-shadow: 0 3px 8px rgba(0,0,0,0.2);
  }
}
```

less混入就是，申明一段css代码（选择器包裹的代码）或者函数，在其他css选择器调用，可复用包裹的代码。

**2）完成自动注入公用变量和混入**

**遇到问题：** 每次使用公用的变量和mixin的时候需要单独引入到文件中。

![1605606221089](https://s2.loli.net/2022/07/08/QcaAS8gNIBTWHrx.png)

**解决方法：** 使用vuecli的style-resoures-loader插件来完成自动注入到每个less文件或者vue组件中style标签中。

- 在当前项目下执行一下命令`vue add style-resources-loader`，添加一个vuecli的插件

![1605607316835](https://s2.loli.net/2022/07/08/zb9cYCwMOVSGoXj.png)

- 安装完毕后会在`vue.config.js`中自动添加配置，如下：

```js
module.exports = {
  pluginOptions: {
    'style-resources-loader': {
      preProcessor: 'less',
      patterns: []
    }
  }
}
```

- 把你需要注入的文件配置一下后，重启服务即可。

```diff
+const path = require('path')
module.exports = {
  pluginOptions: {
    'style-resources-loader': {
      preProcessor: 'less',
      patterns: [
+        path.join(__dirname, './src/assets/styles/variables.less'),
+        path.join(__dirname, './src/assets/styles/mixins.less')
      ]
    }
  }
}
```

**总结：** 知道如何定义less变量和混入代码并使用他们，通过vue-resources-loader完成代码注入再每个less文件和vue组件中。

辽宁，   

# 面包屑组件-高级

[^render 选项和 h 函数]: 

- 指定组件显示的内容：new Vue({选项})
  - el 选项，通过一个选择器找到容器，容器内容就是组件内容
  - template 选项，`<div>组件内容</div>` 作为组件内容
  - render选项，它是一个函数，函数回默认传人createElement的函数（h），这个函数用来创建结构，再render函数返回渲染为组件内容。它的优先级更高。

```
xtx-bread-item.vue
<template>
  <div class="xtx-bread-item">
    <RouterLink v-if="to" :to="to"><slot /></RouterLink>
    <span v-else><slot /></span>
-    <i class="iconfont icon-angle-right"></i>
  </div>
</template>
xtx-bread.vue
<script>
import { h } from 'vue'
export default {
  name: 'XtxBread',
  render () {
    // 用法
    // 1. template 标签去除，单文件组件
    // 2. 返回值就是组件内容
    // 3. vue2.0 的h函数传参进来的，vue3.0 的h函数导入进来
    // 4. h 第一个参数 标签名字  第二个参数 标签属性对象  第三个参数 子节点
    // 需求
    // 1. 创建xtx-bread父容器
    // 2. 获取默认插槽内容
    // 3. 去除xtx-bread-item组件的i标签，因该由render函数来组织
    // 4. 遍历插槽中的item，得到一个动态创建的节点，最后一个item不加i标签
    // 5. 把动态创建的节点渲染再xtx-bread标签中
    const items = this.$slots.default()
    const dymanicItems = []
    items.forEach((item, i) => {
      dymanicItems.push(item)
      if (i < (items.length - 1)) {
        dymanicItems.push(h('i', { class: 'iconfont icon-angle-right' }))
      }
    })
    return h('div', { class: 'xtx-bread' }, dymanicItems)
  }
}
</script>

<style lang='less'>
// 去除 scoped 属性，目的：然样式作用到xtx-bread-item组件
.xtx-bread{
  display: flex;
  padding: 25px 10px;
  // ul li:last-child {}
  // 先找到父元素，找到所有的子元素，找到最后一个，判断是不是LI，是就是选中，不是就是无效选择器
  // ul li:last-of-type {}
  // 先找到父元素，找到所有的类型为li的元素，选中最后一个
  &-item {
    a {
      color: #666;
      transition: all .4s;
      &:hover {
        color: @xtxColor;
      }
    }
  }
  i {
    font-size: 12px;
    margin-left: 5px;
    margin-right: 5px;
    line-height: 22px;
    // 样式的方式，不合理
    // &:last-child {
    //   display: none;
    // }
  }
}
</style>
```

- 使用代码

```vue
      <!-- 面包屑 -->
      <XtxBread>
        <XtxBreadItem to="/">首页</XtxBreadItem>
        <XtxBreadItem to="/category/1005000">电器</XtxBreadItem>
        <XtxBreadItem >空调</XtxBreadItem>
      </XtxBread>
```

- 总结，一下知识点
  - render 是vue提供的一个渲染函数，优先级大于el,template等选项，用来提供组件结构。
  - 注意：
    - vue2.0 render函数提供h（createElement）函数用来创建节点
    - vue3.0 h（createElement）函数有 vue 直接提供，需要按需导入
  - **this.$slots.default()** 获取默认插槽的node结构，按照要求拼接结构。
  - h函数的传参 tag 标签名|组件名称, props 标签属性|组件属性, node 子节点|多个节点
  - 具体参考 [render](https://zhoushugang.gitee.io/erabbit-client-pc-document/guide/[https:/vue-docs-next-zh-cn.netlify.app/guide/render-function.html#dom-树](https:/vue-docs-next-zh-cn.netlify.app/guide/render-function.html#dom-树))
- **注意：不要在 xtx-bread 组件插槽写注释，也会被解析。**

# 批量注册组件

[^自动的批量注册组件]: 

大致步骤：

- 使用 `require` 提供的函数 `context` 加载某一个目录下的所有 `.vue` 后缀的文件。

- 然后`context`函数会返回一个导入函数`importFn`

  - 它又一个属性 `keys()` 获取所有的文件路径

- 通过文件路径数组，通过遍历数组，再使用 `importFn` 根据路径导入组件对象

- 遍历的同时进行全局注册即可

- #### 其实就是vue插件，扩展vue功能，全局组件、指令、函数 （vue.30取消过滤器）

- ```js
  // 当你在mian.js导入，使用Vue.use()  (vue3.0 app)的时候就会执行install函数
  // import XtxSkeleton from './xtx-skeleton.vue'
  // import XtxCarousel from './xtx-carousel.vue'
  // import XtxMore from './xtx-more.vue'
  // import XtxBread from './xtx-bread.vue'
  // import XtxBreadItem from './xtx-bread-item.vue'
  
  // 导入library文件夹下的所有组件
  // 批量导入需要使用一个函数 require.context(dir,deep,matching)
  // 参数：1. 目录  2. 是否加载子目录  3. 加载的正则匹配
  const importFn = require.context('./', false, /\.vue$/)
  // console.dir(importFn.keys()) 文件名称数组
  
  export default {
    install (app) {
      // app.component(XtxSkeleton.name, XtxSkeleton)
      // app.component(XtxCarousel.name, XtxCarousel)
      // app.component(XtxMore.name, XtxMore)
      // app.component(XtxBread.name, XtxBread)
      // app.component(XtxBreadItem.name, XtxBreadItem)
  
      // 批量注册全局组件
      importFn.keys().forEach(key => {
        // 导入组件
        const component = importFn(key).default
        // 注册组件
        app.component(component.name, component)
      })
  
      // 定义指令
      defineDirective(app)
    }
  }
  
  const defineDirective = (app) => {
    // 图片懒加载指令 v-lazyload
    app.directive('lazyload', {
      // vue2.0 inserted函数，元素渲染后
      // vue3.0 mounted函数，元素渲染后
      mounted (el, binding) {
        // 元素插入后才能获取到dom元素，才能使用 intersectionobserve进行监听进入可视区
        // el 是图片元素  binding.value 图片地址
        const observe = new IntersectionObserver(([{ isIntersecting }]) => {
          if (isIntersecting) {
            el.src = binding.value
            // 取消观察
            observe.unobserve(el)
          }
        }, {
          threshold: 0.01
        })
        // 进行观察
        observe.observe(el)
      }
    })
  }
  ```







# 项目的难点

## SKU&SPU概念	

官方话术：

- SPU（Standard Product Unit）：标准化产品单元。是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性。通俗点讲，属性值、特性相同的商品就可以称为一个SPU。
- SKU（Stock Keeping Unit）库存量单位，即库存进出计量的单位， 可以是以件、盒、托盘等为单位。SKU是物理上不可分割的最小存货单元。在使用时要根据不同业态，不同管理模式来处理。

![1613878134510](https://s2.loli.net/2022/07/08/tw7YeTxfzBZnyPr.png)

​	总结一下：

- spu代表一个商品，拥有很多相同的属性。

- sku代表该商品可选规格的任意组合，他是库存单位的唯一标识。

  #### 禁用效果-思路分析

![1613887164658](https://s2.loli.net/2022/07/08/4qL7F3PENuyjTrI.png)

#### 大致步骤：

1. 根据后台返回的skus数据得到有效sku组合
2. 根据有效的sku组合得到所有的子集集合
3. 根据子集集合组合成一个路径字典，也就是对象。
4. 在组件初始化的时候去判断每个规格是否点击
5. 在点击规格的时候去判断其他规格是否可点击
6. 判断的依据是，拿着说有规格和现在已经选中的规则取搭配，得到可走路径。
   1. 如果可走路径在字典中，可点击
   2. 如果可走路径不在字典中，禁用

#### 路径字典

[^js算法库 https://github.com/trekhleb/javascript-algorithms]: 

- 幂集算法 https://raw.githubusercontent.com/trekhleb/javascript-algorithms/master/src/algorithms/sets/power-set/bwPowerSet.js

```js
import getPowerSet from '@/vender/power-set'
const spliter = '★'
// 根据skus数据得到路径字典对象
const getPathMap = (skus) => {
  const pathMap = {}
  skus.forEach(sku => {
    // 1. 过滤出有库存有效的sku
    if (sku.inventory) {
      // 2. 得到sku属性值数组
      const specs = sku.specs.map(spec => spec.valueName)
      // 3. 得到sku属性值数组的子集
      const powerSet = getPowerSet(specs)
      // 4. 设置给路径字典对象
      powerSet.forEach(set => {
        const key = set.join(spliter)
        if (pathMap[key]) {
          // 已经有key往数组追加
          pathMap[key].push(sku.id)
        } else {
          // 没有key设置一个数组
          pathMap[key] = [sku.id]
        }
      })
    }
  })
  return pathMap
}
```

```
src/views/goods/components/goods-sku.vue
// 得到当前选中规格集合
const getSelectedArr = (specs) => {
  const selectedArr = []
  specs.forEach(spec => {
    const selectedVal = spec.values.find(val => val.selected)
    selectedArr.push(selectedVal ? selectedVal.name : undefined)
  })
  return selectedArr
}
// 更新按钮的禁用状态
const updateDisabledStatus = (specs, pathMap) => {
  specs.forEach((spec, i) => {
    const selectedArr = getSelectedArr(specs)
    spec.values.forEach(val => {
      // 已经选中的按钮不用判断
      if (val.name === selectedArr[i]) return false
      // 未选中的替换对应的值
      selectedArr[i] = val.name
      // 过滤无效值得到key
      const key = selectedArr.filter(v => v).join(spliter)
      // 设置禁用状态
      val.disabled = !pathMap[key]
    })
  })
}
  setup (props) {
    const pathMap = getPathMap(props.goods.skus)
    // 组件初始化的时候更新禁用状态
+    updateDisabledStatus(props.goods.specs, pathMap)
    const clickSpecs = (item, val) => {
      // 如果是禁用状态不作为
+      if (val.disabled) return false
      // 1. 选中与取消选中逻辑
      if (val.selected) {
        val.selected = false
      } else {
        item.values.find(bv => { bv.selected = false })
        val.selected = true
      }
      // 点击的时候更新禁用状态
+      updateDisabledStatus(props.goods.specs, pathMap)
    }
    return { clickSpecs }
  }
```

## ★分页组件

[^封装一个统一的分页组件。]: 

- 分页基础布局，依赖数据分析 `src/components/library/xtx-pagination.vue`

```vue
<template>
  <div class="xtx-pagination">
    <a href="javascript:;" class="disabled">上一页</a>
    <span>...</span>
    <a href="javascript:;" class="active">3</a>
    <a href="javascript:;">4</a>
    <a href="javascript:;">5</a>
    <a href="javascript:;">6</a>
    <a href="javascript:;">7</a>
    <span>...</span>
    <a href="javascript:;">下一页</a>
  </div>
</template>
<script>
export default {
  name: 'XtxPagination'
}
</script>
<style scoped lang="less">
.xtx-pagination {
  display: flex;
  justify-content: center;
  padding: 30px;
  > a {
    display: inline-block;
    padding: 5px 10px;
    border: 1px solid #e4e4e4;
    border-radius: 4px;
    margin-right: 10px;
    &:hover {
      color: @xtxColor;
    }
    &.active {
      background: @xtxColor;
      color: #fff;
      border-color: @xtxColor;
    }
    &.disabled {
      cursor: not-allowed;
      opacity: 0.4;
      &:hover {
        color: #333
      }
    }
  }
  > span {
    margin-right: 10px;
  }
}
</style>
```

![1614245759420](https://s2.loli.net/2022/07/08/iRTGY1WFen5JZLS.png)

1）准备渲染数据

```js
  setup () {
    // 总条数
    const myTotal = ref(100)
    // 每页条数
    const myPageSize = ref(10)
    // 当前第几页
    const myCurrentPage = ref(1)
    // 按钮个数
    const btnCount = 5

    // 重点：根据上述数据得到（总页数，起始页码，结束页码，按钮数组）
    const pager = computed(() => {
      // 计算总页数
      const pageCount = Math.ceil(myTotal.value / myPageSize.value)
      // 计算起始页码和结束页码
      // 1. 理想情况根据当前页码，和按钮个数可得到
      let start = myCurrentPage.value - Math.floor(btnCount / 2)
      let end = start + btnCount - 1
      // 2.1 如果起始页码小于1了，需要重新计算
      if (start < 1) {
        start = 1
        end = (start + btnCount - 1) > pageCount ? pageCount : (start + btnCount - 1)
      }
      // 2.2 如果结束页码大于总页数，需要重新计算
      if (end > pageCount) {
        end = pageCount
        start = (end - btnCount + 1) < 1 ? 1 : (end - btnCount + 1)
      }
      // 处理完毕start和end得到按钮数组
      const btnArr = []
      for (let i = start; i <= end; i++) {
        btnArr.push(i)
      }
      return { pageCount, start, end, btnArr }
    })

    return { pager, myCurrentPage}
  }
```

2）进行渲染

```vue
    <a v-if="myCurrentPage<=1" href="javascript:;" class="disabled">上一页</a>
    <a v-else href="javascript:;">上一页</a>
    <span v-if="pager.start>1">...</span>
    <a href="javascript:;" :class="{active:i===myCurrentPage}" v-for="i in pager.btnArr" :key="i">{{i}}</a>
    <span v-if="pager.end<pager.pageCount">...</span>
    <a v-if="myCurrentPage>=pager.pageCount" href="javascript:;" class="disabled">下一页</a>
    <a v-else href="javascript:;">下一页</a>
```

3）切换效果

```diff
  <div class="xtx-pagination">
    <a v-if="myCurrentPage<=1" href="javascript:;" class="disabled">上一页</a>
+    <a @click="changePage(myCurrentPage-1)" v-else href="javascript:;">上一页</a>
    <span v-if="pager.start>1">...</span>
+    <a @click="changePage(i)" href="javascript:;" :class="{active:i===myCurrentPage}" v-for="i in pager.btnArr" :key="i">{{i}}</a>
    <span v-if="pager.end<pager.pageCount">...</span>
    <a v-if="myCurrentPage>=pager.pageCount" href="javascript:;" class="disabled">下一页</a>
+    <a @click="changePage(myCurrentPage+1)" v-else href="javascript:;">下一页</a>
  </div>
    // 改变页码
    const changePage = (newPage) => {
      myCurrentPage.value = newPage
    }

    return { pager, myCurrentPage, changePage }
```

- 接收外部数据，提供分页事件。

```js
  props: {
    total: {
      type: Number,
      default: 100
    },
    currentPage: {
      type: Number,
      default: 1
    },
    pageSize: {
      type: Number,
      default: 10
    }
  },
    // 监听传人的值改变
    watch(props, () => {
      myTotal.value = props.total
      myPageSize.value = props.pageSize
      myCurrentPage.value = props.currentPage
    }, { immediate: true })
    // 改变页码
    const changePage = (newPage) => {
      if (myCurrentPage.value !== newPage) {
        myCurrentPage.value = newPage
        // 通知父组件最新页码
        emit('current-change', newPage)
      }
    }
```

最后使用组件：

```diff
+   // 记录总条数
	const commentList = ref([])
+   const total = ref(0)
	watch(reqParams, async () => {
      const data = await findCommentListByGoods(props.goods.id, reqParams)
      commentList.value = data.result
+      total.value = data.result.counts
    }, { immediate: true })
	// 改变分页函数
    const changePager = (np) => {
      reqParams.page = np
    }
    return { commentInfo, currTagIndex, changeTag, reqParams, changeSort, commentList, total, changePager }
    <!-- 分页 -->
    <XtxPagination @current-change="changePager" :total="total" :current-page="reqParams.page"  />
```

筛选和排序改变后页码回到第一页：

```diff
    // 改变排序
    const changeSort = (type) => {
      reqParams.sortField = type
+      reqParams.page = 1
    }
    const changeTag = (i) => {
      currTagIndex.value = i
      // 设置有图和标签条件
      const currTag = commentInfo.value.tags[i]
      if (currTag.type === 'all') {
        reqParams.hasPicture = false
        reqParams.tag = null
      } else if (currTag.type === 'img') {
        reqParams.hasPicture = true
        reqParams.tag = null
      } else {
        reqParams.hasPicture = false
        reqParams.tag = currTag.title
      }
+      reqParams.page = 1
    }
```

优化：有条数才显示分页

- 

## 支付倒计时函数封装

```js
// 提供复用逻辑的函数（钩子）
import { useIntersectionObserver, useIntervalFn } from '@vueuse/core'
import { ref, onUnmounted } from 'vue'
import dayjs from 'dayjs'
/**
 * 支付倒计时函数
 */
export const usePayTime = () => {
  // 倒计时逻辑
  const time = ref(0)
  const timeText = ref('')
  const { pause, resume } = useIntervalFn(() => {
    time.value--
    timeText.value = dayjs.unix(time.value).format('mm分ss秒')
    if (time.value <= 0) {
      pause()
    }
  }, 1000, false)
  onUnmounted(() => {
    pause()
  })

  // 开启定时器 countdown 倒计时时间
  const start = (countdown) => {
    time.value = countdown
    timeText.value = dayjs.unix(time.value).format('mm分ss秒')
    resume()
  }

  return {
    start,
    timeText
  }
}
```

## mock.js 进行数据模拟

1. 安装

```bash
npm i mockjs
```

1. 配置 `src/mock/index.js`

```js
import Mock from 'mockjs'

// mock的配置
Mock.setup({
  // 随机延时500-1000毫秒
  timeout: '500-1000'
})
```

1. 使用 `src/main.js`

```diff
import 'normalize.css'
import '@/assets/styles/common.less'
+ import './mock'
```

1. 模拟接口，拦截请求

```js
// 拦截请求，
// 第一个参数：url，使用正则去匹配
// 第二个参数：请求方式
// 第三个参数： 生成数据的函数
Mock.mock(/\/my\/test/, 'get', () => {
  return { msg: '请求测试接口成功', result: [] }
})
```

1. 生成随机数据

```js
// 单个数据
Mock.mock('@integer(0,7)')
// 对象数据
Mock.mock({
    id: '@id',
    name: '@ctitle(2,4)'
})
```

## Teleport 

[^传送门]: 

出现的问题

在使用该组件进行传送的时候，由于不够熟练，疏忽了应该在public下的index.html进行挂载标签

```html
    <div id="app"></div>
    <div id="model"></div>
```

怎么解决：查看官方文档，找到它的具体使用方法，在根据自己的项目进行结合，找到问题所在







## 性能优化

### 1.懒加载

1.1图片懒加载

方法一

图片的加载是由`src`引起的，当对`src`赋值时，浏览器就会请求图片资源。根据这个原理，我们使用HTML5 的`data-xxx`属性来储存图片的路径，在需要加载图片的时候，将`data-xxx`中图片的路径赋值给`src`，这样就实现了图片的按需加载，即懒加载。

注意：`data-xxx` 中的`xxx`可以自定义，这里我们使用`data-src`来定义。

懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。

使用原生JavaScript实现懒加载：

**知识点：**

（1）`window.innerHeight` 是浏览器可视区的高度

（2）`document.body.scrollTop || document.documentElement.scrollTop` 是浏览器滚动的过的距离

（3）`imgs.offsetTop` 是元素顶部距离文档顶部的高度（包括滚动条的距离）

（4）图片加载条件：`img.offsetTop < window.innerHeight + document.body.scrollTop;

**代码实现：**

```
<div class="container">
     <img src="loading.gif"  data-src="pic.png">
     <img src="loading.gif"  data-src="pic.png">
     <img src="loading.gif"  data-src="pic.png">
     <img src="loading.gif"  data-src="pic.png">
     <img src="loading.gif"  data-src="pic.png">
     <img src="loading.gif"  data-src="pic.png">
</div>
<script>
var imgs = document.querySelectorAll('img');
function lozyLoad(){
var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
var winHeight= window.innerHeight;
for(var i=0;i < imgs.length;i++){
if(imgs[i].offsetTop < scrollTop + winHeight ){
imgs[i].src = imgs[i].getAttribute('data-src');
}
}
}
  window.onscroll = lozyLoad();
</script>
复制代码
```

方法二

可以使用一个api叫intersectionObserver（），

进入可视区的时候才加载

方法三

我们在项目中使用 Vue 的 vue-lazyload 插件：

（1）安装插件

```css
npm install vue-lazyload --save-dev
复制代码CopyErrorCopied
```

（2）在入口文件 man.js 中引入并使用

```javascript
import VueLazyload from 'vue-lazyload'
复制代码CopyErrorCopied
```

然后再 vue 中直接使用

```php
Vue.use(VueLazyload)
复制代码CopyErrorCopied
```

或者添加自定义选项

```vbnet
Vue.use(VueLazyload, {
preLoad: 1.3,
error: 'dist/error.png',
loading: 'dist/loading.gif',
attempt: 1
})
复制代码CopyErrorCopied
```

（3）在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示：

```ini
<img v-lazy="/static/img/1.png">
复制代码CopyErrorCopied
```

以上为 vue-lazyload 插件的简单使用，如果要看插件的更多参数选项，可以查看 vue-lazyload 的 [github 地址](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fhilongjw%2Fvue-lazyload)。

1.2路由懒加载

Vue 是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。

**路由懒加载：**

```go
const Foo = () => import('./Foo.vue')
const router = new VueRouter({
  routes: [
    { path: '/foo', component: Foo }
  ]
})
```

1.3组件懒加载

**大致步骤：**

- 理解 `useIntersectionObserver` 的使用，各个参数的含义
- 改造 home-new 组件成为数据懒加载，掌握 `useIntersectionObserver` 函数的用法
- 封装 `useLazyData` 函数，作为数据懒加载公用函数
- 把 `home-new` 和 `home-hot` 改造成懒加载方式

**落的代码：**

1. 先分析下这个`useLazyData` 函数：

```js
export const useLazyData = (apiFn) => {
  const result = ref([])
  const target = ref(null)
  // stop 停止观察
  const { stop } = useIntersectionObserver(
    // 监听的目标元素
    target,
    ([{ isIntersecting }], observerElement) => {
      // isIntersecting 是否进入可视区
      if (isIntersecting) {
        stop()
        // 调用API函数获取数据
        apiFn().then(data => {
          result.value = data.result
        })
      }
    },
    // 配置选项，相交的比例大于0就触发
    {
      threshold: 0
    }
  )
  return { result, target }
}CopyErrorCopied
```

1. 开始改造 `home-new` 组件：`rc/views/home/components/home-new.vue`

- 进入可视区后获取数据

```html
<div ref="box" style="position: relative;height: 406px;">
// 省略。。。
<script>
import HomePanel from './home-panel'
import HomeSkeleton from './home-skeleton'
import { findNew } from '@/api/home'
import { ref } from 'vue'
import { useIntersectionObserver } from '@vueuse/core'
export default {
  name: 'HomeNew',
  components: { HomePanel, HomeSkeleton },
  setup () {
    const goods = ref([])
    const box = ref(null)
    const { stop } = useIntersectionObserver(
      box,
      ([{ isIntersecting }]) => {
        if (isIntersecting) {
          stop()
          findNew().then(data => {
            goods.value = data.result
          })
        }
      }
    )
    return { goods, box }
  }
}
</script>CopyErrorCopied
```

1. 由于首页面板数据加载都需要实现懒数据加载，所以封装一个钩子函数，得到数据。

```
src/hooks/index.js
// hooks 封装逻辑，提供响应式数据。
import { useIntersectionObserver } from '@vueuse/core'
import { ref } from 'vue'
// 数据懒加载函数
export const useLazyData = (apiFn) => {
  // 需要
  // 1. 被观察的对象
  // 2. 不同的API函数
  const target = ref(null)
  const result = ref([])
  const { stop } = useIntersectionObserver(
    target,
    ([{ isIntersecting }], observerElement) => {
      if (isIntersecting) {
        stop()
        // 调用API获取数据
        apiFn().then(data => {
          result.value = data.result
        })
      }
    }
  )
  // 返回--->数据（dom,后台数据）
  return { target, result }
}CopyErrorCopied
```

1. 再次改造 `home-new` 组件：`rc/views/home/components/home-new.vue`

```diff
import { findNew } from '@/api/home'
+import { useLazyData } from '@/hooks'
export default {
  name: 'HomeNew',
  components: { HomePanel, HomeSkeleton },
  setup () {
+    const { target, result } = useLazyData(findNew)
+    return { goods: result, target }
  }
}
+ <div ref="target" style="position: relative;height: 426px;">CopyErrorCopied
```

1. 然后改造 `home-hot` 组件：`src/views/home/components/home-hot.vue`

```diff
+  <div ref="target" style="position: relative;height: 426px;">
import { findHot } from '@/api/home'
import HomePanel from './home-panel'
import HomeSkeleton from './home-skeleton'
+import { useLazyData } from '@/hooks'
export default {
  name: 'HomeHot',
  components: { HomePanel, HomeSkeleton },
  setup () {
+    const { target, result } = useLazyData(findHot)
+    return { target, list: result }
  }
}
```

## 节流与防抖

#### input组件里的搜索框进行防抖操作

### 1. 对节流与防抖的理解

- 函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。
- 函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。

**防抖函数的应用场景：**

- 按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次
- 服务端验证场景：表单验证需要服务端配合，只执⾏⼀段连续的输⼊事件的最后⼀次，还有搜索联想词功能类似⽣存环境请⽤lodash.debounce

**节流函数的适⽤场景：**

- 拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动
- 缩放场景：监控浏览器resize
- 动画场景：避免短时间内多次触发动画引起性能问题

### 2. 实现节流函数和防抖函数

**函数防抖的实现：**

```
function debounce(fn, wait) {
  var timer = null;

  return function() {
    var context = this,
      args = [...arguments];

    // 如果此时存在定时器的话，则取消之前的定时器重新记时
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }

    // 设置定时器，使事件间隔指定事件后执行
    timer = setTimeout(() => {
      fn.apply(context, args);
    }, wait);
  };
}
复制代码CopyErrorCopied
```

**函数节流的实现：**

```
// 时间戳版
function throttle(fn, delay) {
  var preTime = Date.now();

  return function() {
    var context = this,
      args = [...arguments],
      nowTime = Date.now();

    // 如果两次时间间隔超过了指定时间，则执行函数。
    if (nowTime - preTime >= delay) {
      preTime = Date.now();
      return fn.apply(context, args);
    }
  };
}

// 定时器版
function throttle (fun, wait){
  let timeout = null
  return function(){
    let context = this
    let args = [...arguments]
    if(!timeout){
      timeout = setTimeout(() => {
        fun.apply(context, args)
        timeout = null 
      }, wait)
    }
  }
}
复制代码
```

## 减少HTTP请求

减少 http 请求次数： CSS Sprites, JS、CSS 源码压缩、图片大小适当控制； 网页 Gzip，CDN 托管，data 缓存 ，图片服务器。 尽量减少内联样式 将脚本放在底部 少用全局变量、缓存 DOM 节点查找的结果 图片预加载 按需加载

## Webpack

### 1. 如何提⾼**webpack**的打包速度?

## （1）优化 Loader

对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，**转换代码越多，效率就越低**。当然了，这是可以优化的。

首先我们**优化 Loader 的文件搜索范围**

```
module.exports = {
  module: {
    rules: [
      {
        // js 文件才使用 babel
        test: /\.js$/,
        loader: 'babel-loader',
        // 只在 src 文件夹下查找
        include: [resolve('src')],
        // 不会去查找的路径
        exclude: /node_modules/
      }
    ]
  }
}
复制代码CopyErrorCopied
```

## （2）开启HMR

对于 Babel 来说，希望只作用在 JS 代码上的，然后 `node_modules` 中使用的代码都是编译过的，所以完全没有必要再去处理一遍。

当然这样做还不够，还可以将 Babel 编译过的文件**缓存**起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间

```
loader: 'babel-loader?cacheDirectory=true'
复制代码
```

开发时我们修改了其中一个模块代码，Webpack 默认会将所有模块全部重新打包编译，速度很慢。

所以我们需要做到修改某个模块代码，就只有这个模块代码需要重新打包编译，其他模块不变，这样打包速度就能很快。

HotModuleReplacement（HMR/热模块替换）：在程序运行中，替换、添加或删除模块，而无需重新加载整个页面。

配置

devServer中设置 hot:true

```
module.exports = {
  // 其他省略
  devServer: {
    host: "localhost", // 启动服务器域名
    port: "3000", // 启动服务器端口号
    open: true, // 是否自动打开浏览器
    hot: true, // 开启HMR功能（只能用于开发环境，生产环境不需要了）
  },
};CopyErrorCopied
```

## （3） Include/Exclude

开发时我们需要使用第三方的库或插件，所有文件都下载到 node_modules 中了。而这些文件是不需要编译可以直接使用的。

所以我们在对 js 文件处理时，要排除 node_modules 下面的文件

- include

包含，只处理 xxx 文件

- exclude

排除，除了 xxx 文件以外其他文件都处理

babel-loader中设置

```
{
            test: /\.js$/,
            // exclude: /node_modules/, // 排除node_modules代码不编译
            include: path.resolve(__dirname, "../src"), // 也可以用包含
            loader: "babel-loader",
          },CopyErrorCopied
```

ESLintWebpackPlugin设置

```
new ESLintWebpackPlugin({
      // 指定检查文件的根目录
      context: path.resolve(__dirname, "../src"),
      exclude: "node_modules", // 默认值
    }),
```

## （4）Cache

每次打包时 js 文件都要经过 Eslint 检查 和 Babel 编译，速度比较慢。

我们可以缓存之前的 Eslint 检查 和 Babel 编译结果，这样第二次打包时速度就会更快了

对 Eslint 检查 和 Babel 编译结果进行缓存

针对Babel

```
{
            test: /\.js$/,
            // exclude: /node_modules/, // 排除node_modules代码不编译
            include: path.resolve(__dirname, "../src"), // 也可以用包含
            loader: "babel-loader",
            options: {
              cacheDirectory: true, // 开启babel编译缓存
              cacheCompression: false, // 缓存文件不要压缩
            },
          },CopyErrorCopied
```

针对ESLintWebpackPlugin

```
new ESLintWebpackPlugin({
      // 指定检查文件的根目录
      context: path.resolve(__dirname, "../src"),
      exclude: "node_modules", // 默认值
      cache: true, // 开启缓存
      // 缓存目录
      cacheLocation: path.resolve(
        __dirname,
        "../node_modules/.cache/.eslintcache"
      ),
    }),
```

### 然后就是实习学到的一些优化

## （5）Thread

当项目越来越庞大时，打包速度越来越慢，甚至于需要一个下午才能打包出来代码。这个速度是比较慢的。

我们想要继续提升打包速度，其实就是要提升 js 的打包速度，因为其他文件都比较少。

而对 js 文件处理主要就是 eslint 、babel、Terser 三个工具，所以我们要提升它们的运行速度。

我们可以开启多进程同时处理 js 文件，这样速度就比之前的单进程打包更快了。

获取 CPU 的核数

我们启动进程的数量就是我们 CPU 的核数

```
const os = require("os");
const TerserPlugin = require("terser-webpack-plugin");
const threads = os.cpus().length;CopyErrorCopied
```

针对js

```
{
            test: /\.js$/,
            // exclude: /node_modules/, // 排除node_modules代码不编译
            include: path.resolve(__dirname, "../src"), // 也可以用包含
            use: [
              {
                loader: "thread-loader", // 开启多进程
                options: {
                  workers: threads, // 数量
                },
              },
              {
                loader: "babel-loader",
                options: {
                  cacheDirectory: true, // 开启babel编译缓存
                },
              },
            ],
          },
```

## （6）更快的  swc

## swc 是什么

在开始说`swc`之前，我们先来了解一下`Rust`这门编程语言。

![img](https://s2.loli.net/2022/08/01/AYFagmOVr4kpcD6.webp)

`Rust`是一种快速、可靠、内存高效的编程语言。它是 `C++` 或 `C` 等语言的现代替代品。 

`swc`的出现其实很大一部分原因是要替换掉工程中的`babel`，所以`babel`有的[功能](https://link.juejin.cn?target=https%3A%2F%2Fswc.rs%2Fdocs%2Fmigrating-from-babel%23comparison)他几乎都有。

与babel最大的区别可能就是： **swc is super-fast**

目前`Rust`被应用在前端工具链方面，如压缩（Terser）、编译（Babel）、格式化（Prettier）、打包（webpack）等场景中。而今天我们要讲的`swc`做的就是做的这样一件事。

swc官网中还有这样一句话，体现了他的速度:

![img](https://s2.loli.net/2022/08/01/BG4Dg9mzr8M2IiE.webp)

除了`swc`的官方宣传外，`Next.js`基于`swc`实现了一个`Rust`编译器，用来解析编译、打包代码。下面是`Next.js`结合`swc`之后给出的一个数据：

![img](https://s2.loli.net/2022/08/01/greTqm4ylnOdQUp.webp)

所以从上面这些数据也可以简单看出来`swc`的优势：**可以提高开发效率，提升开发体验**。

这也是目前很多工程选择接入它的原因。

## swc 怎么用

### 基本使用

1. 安装依赖：`npm i -D @swc/cli @swc/core`
2. 运行命令：`npx swc ./index.js -o output.js`（编译单个文件)

![img](https://s2.loli.net/2022/08/01/MJys67zgaUFtVlN.webp)

执行过命令之后会把结果打印在标准输出里，并没有生成文件之类的。

如果想要输出的文件中需要携带参数来完成`-o ouput.js`或者`-d dist`编译到dist目录下

### Bundling

1. 根目录下需要有一个配置文件`spack.config.js`

```js
const { config } = require('@swc/core/spack');

module.exports = config({
  entry: {
    web: './src/index.js',
    // 可以配置多入口
  },
  output: {
    path: './bundle/',
  },
  module: {},
  options:{},
});
复制代码
```

1. 运行命令`npx spack`进行打包

打包支持`tree-shaking`、`Commonjs`模块、提取公共模块等。

详细配置项：[swc.rs/docs/config…](https://link.juejin.cn?target=https%3A%2F%2Fswc.rs%2Fdocs%2Fconfiguration%2Fbundling)

### Plugin

`swc`的`plugin`其实就是将核心包中的一些`API`暴露出来，给开发者做一些自定义的操作。

看个例子，这个例子的作用就是将代码中的`console.log()`过滤掉，用`void 0`代替

用过Bable的同学看起来可能会简单一些。

```js
const Visitor = require('@swc/core/Visitor').default;
const { transformSync } = require('@swc/core');

module.exports = class ConsoleStripper extends Visitor {
  visitCallExpression(expression) {
    if (expression.callee.type !== 'MemberExpression') {
      return expression;
    }
    // 判断代码类型以及对应的value是否为console
    if (
      expression.callee.object.type === 'Identifier' &&
      expression.callee.object.value === 'console'
    ) {
      // 如果是就替换为`void 0`
      if (expression.callee.property.type === 'Identifier') {
        return {
          type: 'UnaryExpression',
          span: expression.span,
          operator: 'void',
          argument: {
            type: 'NumericLiteral',
            span: expression.span,
            value: 0,
          },
        };
      }
    }

    return expression;
  }
};

const out = transformSync(
  `
if (foo) {
    console.log("Foo")
} else {
    console.log("Bar")
}`,
  {
    plugin: (m) => new ConsoleStripper().visitProgram(m),
  }
);
复制代码
```

上面提到的是我认为可能比较常用的一些东西，当然除此之外`swc`还提供了像`Jest`、和`wasm`等工具，而且`swc`还提供了一个`loader`供开发者在`webpack`中使用。

### 然后我在实习项目中用到的就是swc-loader

在 `webpack` 中耗时最久的当属负责 AST 转换的 loader。

当 loader 进行编译时的 AST 操作均为 CPU 密集型任务，使用 Javascript 性能低下，此时可采用高性能语言 rust 编写的 `swc`。

比如 Javascript 转化由 `babel` 转化为更快的 [swc (opens new window)](https://swc.rs/)。

```js
module: {
  rules: [
    {
      test: /\.m?js$/,
      exclude: /(node_modules)/,
      use: {
        loader: "swc-loader",
      },
    },
  ];
}
```

### swc 为什么快

因为`JavaScript`本身就有点慢。

我们先来看一下`js`的执行流程：

![img](https://s2.loli.net/2022/08/01/hxZ6cW1d9CFDHEu.webp)

> 这其中转换为`AST`以及编译成字节码应该是最耗费性能的。

而`swc`是直接将代码根据不同平台来编译成对应的**二进制文件**，省略了前面最耗时的步骤。

接下来我们拿上面那个`Plugin`来看一下`swc`在代码转换过程中大概是怎么执行的

> 接下来的整个过程就是其实就是证实swc在编译代码的时候是直接由二进制文件中的代码来执行的。

引入这个库函数之后他会暴露一个transformSync函数

我将断点打在`transformSync`处，看一下此处的执行：

![img](https://s2.loli.net/2022/08/01/17EqGIVjB3SRn8o.webp)

来看一下比较重要的一部分代码：

```js
transformSync(src, options) {
  
        // ...
  
        const { plugin } = options, newOptions = __rest(options, ["plugin"]);
  	// 是否有plugin
        if (plugin) {
            const m = typeof src === "string" ? this.parseSync(src, (_c = options === null || options === void 0 ? void 0 : options.jsc) === null || _c === void 0 ? void 0 : _c.parser, options.filename) : src;
            return this.transformSync(plugin(m), newOptions);
        }
  	// 最终的输出都是bindings.transformSync
        return bindings.transformSync(isModule ? JSON.stringify(src) : src, isModule, toBuffer(newOptions));
    }
复制代码
```

大致执行流程：

![img](https://s2.loli.net/2022/08/01/pu4coKskib8rjyY.webp)

从上面的执行图中可以看出来，我们获取到的结果，最终都是由`bindings.transformSync`解析完成，然后输出的结果。

从源码中可以找到`bindings`的入口，我们在这里打个断点，从这里看一下`bindings`的执行流程

![img](https://s2.loli.net/2022/08/01/8S1yGtAcDFwjW3V.webp)

```js
function loadBinding(dirname, filename = 'index', packageName) {
   
    // 获取系统信息
    const triples = triples_1.platformArchTriples[PlatformName][ArchName];
    
    // 遍历系统信息
    for (const triple of triples) {
        if (packageName) {
            try {
                // 获取到需要加载的二进制文件路径
                // /Users/xx/swc-demo/node_modules/@swc/core-darwin-x64/swc.darwin-x64.node
                return require(
                  require.resolve(
                    `${packageName}-${triple.platformArchABI}`,
                    { paths: [dirname] }
                  ));
            }
            catch (e) {
               // ...
            }
        }
       // ...
}
复制代码
```

流程图：

![img](https://s2.loli.net/2022/08/01/A5D8ZLHunvC6VNT.webp)

我们最后得到的结果就是`require进来一个二进制文件`。

这个文件的路径大概是这样的：`/Users/xx/swc-demo/node_modules/@swc/core-darwin-x64/swc.darwin-x64.node`，当然这会根据不同电脑生成不同的路径~

来看一下，`swc`的包里这个文件：

![img](https://s2.loli.net/2022/08/01/2UVHx1JIAOYjlhN.webp)

为了证实它是一个二进制文件，我们可以点开看一下（这里是用了vscode的插件，才可以看到）

![img](https://s2.loli.net/2022/08/01/H29rLbDPFEhwUZi.webp)

打开之后是这样的，这里我们就不做过多解读了，有兴趣的可以逐行翻译一下![img](https://s2.loli.net/2022/08/01/2ui7kLjvX1tWO3D.webp)。

因为`JavaScript`本身就有点慢。

我们先来看一下`js`的执行流程：

![img](https://s2.loli.net/2022/08/01/hxZ6cW1d9CFDHEu.webp)

> 这其中转换为`AST`以及编译成字节码应该是最耗费性能的。

而`swc`是直接将代码根据不同平台来编译成对应的**二进制文件**，省略了前面最耗时的步骤。

## 移动端适配

### **为什么要移动端适配？**

一般情况下设计稿的设计师按照375的尺寸设计，然而，在现在移动终端（就是手机）快速更新的时代，每个品牌的手机都有着不同的物理分辨率，这样就会导致，每台设备的逻辑分辨率也不尽相同，此时375的设计稿，如果想要还原那基本是不可能了，因为如果一个左右布局，左边如果写死，右边自适应的话，每个设备的右边所展示的内容大小就不尽相同，这是移动端适配就显得尤其重要

要知道几个名词:物理像素/逻辑像素/像素dpr==》devicePixelRatio

###  先是用的rem进行移动端的适配

```
const setRem = () => {    const deviceWidth = document.documentElement.clientWidth;    // 获取相对UI稿，屏幕的缩放比例    const rem = (deviceWidth *100) / 750;    // 动态设置html的font-size    document.querySelector('html').style.fontSize =  rem + 'px';  };
```

查了一番资料才得知，rem方案是viewport的过渡方案，将设计稿除以100，等分为7.5份来实现移动端不同屏幕尺寸适配的原理，与viewport中vw单位的定义，设计思想与想要解决的问题，是相同的。当时浏览器对viewport的支持性不好，而现在已经是2022年了，可以看到，各大浏览器厂商，对viewport的支持率已经很高了。可以放心使用。



### 2. 相对于rem的优势

- 语义化更好, rem从本义上来说，是一种字体单位，不是用来做布局和各种屏幕尺寸大小适配的，如上面的示例，用rem做适配单位，计算根字体的时候，计算公式中的100这个参数让人感觉很费解，viewport词更达意。
- 可以直接在代码中书写px,借助postcss-px-to-viewport插件转换成vw单位，完美适配移动端各种屏幕尺寸。不用像之前那样，一是要在蓝湖上设置根字体基准尺寸，将设计稿标注的px单位转换成rem单位，然后摘抄到代码中。二是需要用js计算设置根字体大小。前端开发天然喜欢px单位，像rem,em,vw，vh这些单位，一般都不是UI设计稿标注的尺寸，开发时需要转换成本。不如直接在代码中写px直观高效。

### 3.postcss-px-to-viewport方案正确的使用姿势

看到网上的教程都是说要在项目中安装postcss-px-to-viewport工具包，然而安装和配置完postcss-px-to-viewport之后，运行项目，发现命令行出现如下报错：

```bash
postcss-px-to-viewport: postcss.plugin was deprecated. Migration guide: https://evilmartians.com/chronicles/postcss-8-plugin-migration
复制代码
```

说安装的postcss-px-to-viewport已经过时了，迁移指南参考[evilmartians.com/chronicles/…](https://link.juejin.cn?target=https%3A%2F%2Fevilmartians.com%2Fchronicles%2Fpostcss-8-plugin-migration)

点进入一看，根本找不到配置px转vw单位的方法。后面经过一番尝试之后，最终找到了正确的使用方法。

#### 3.1 安装postcss-px-to-viewport-8-plugin

```csharp
yarn add -D postcss-px-to-viewport-8-plugin
复制代码
```

#### 3.2 在项目下创建postcss.config.js

```js
module.exports = {
  plugins: {
    'postcss-px-to-viewport-8-plugin': {
      unitToConvert: 'px', // 需要转换的单位，默认为"px"
      viewportWidth: 750, // 设计稿的视口宽度
      unitPrecision: 5, // 单位转换后保留的精度
      propList: ['*','!font-size'], // 能转化为vw的属性列表,!font-size表示font-size后面的单位不会被转换
      viewportUnit: 'vw', // 希望使用的视口单位
      fontViewportUnit: 'vw', // 字体使用的视口单位
      // 需要忽略的CSS选择器，不会转为视口单位，使用原有的px等单位。
      // 下面配置表示类名中含有'keep-px'都不会被转换
      selectorBlackList: ['keep-px'], 
      minPixelValue: 1, // 设置最小的转换数值，如果为1的话，只有大于1的值会被转换
      mediaQuery: false, // 媒体查询里的单位是否需要转换单位
      replace: true, //  是否直接更换属性值，而不添加备用属性
      exclude: [/node_modules/], // 忽略某些文件夹下的文件或特定文件，例如 'node_modules' 下的文件
      include: [/src/], // 如果设置了include，那将只有匹配到的文件才会被转换
      landscape: false, // 是否添加根据 landscapeWidth 生成的媒体查询条件 @media (orientation: landscape)
      landscapeUnit: 'vw', // 横屏时使用的单位
      landscapeWidth: 1338, // 横屏时使用的视口宽度
    },
  },
};
```

需要注意的是：

- 1.postcss-px-to-viewport 对内联css样式，外联css样式，内嵌css样式有效，对js动态css无效。 所以要动态改变css展示效果的话，要使用静态的class定义变化样式，通过js改变dom元素的class实现样式变化。
- 2.vue模板中的px单位不会被转换，如需转换请使用[postcss-style-px-to-viewport](https://link.juejin.cn?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fpostcss-style-px-to-viewport)工具 

我又安装了这个工具

```
npm install postcss-style-px-to-viewport --save-dev
```

```
{
    test: /\.(vue|jsx?)$/,
    loader: 'postcss-style-px-to-viewport',
    options: {
       // ...
    }
}
```

然后又发现我用我的ipad这种宽屏的设备下显示的时候字体会变大，不能像rem那样直接在html上限制一个最大的font-size，viewpoint也不能用媒体查询限制大小，然后我就想那就字体用rem适配，然后其他的宽高这些用viewpoint的插件来适配就好。然后就解决了这些问题。

### 1px问题

核心思路:

**在web中，浏览器为我们提供了window.devicePixelRatio来帮助我们获取dpr。**

**在css中，可以使用媒体查询min-device-pixel-ratio，区分dpr**

我们根据这个像素比，来算出他对应应该有的大小,但是暴露个非常大的兼容问题

![img](https://s2.loli.net/2022/07/08/WXdUGtOoLSQma1B.png)

### 解决1px问题过程会出现什么问题呢?

![img](https://s2.loli.net/2022/07/08/ntawTeo6C7GAkp1.png)



### 说说什么是视口(viewport)

viewport 即视窗、视口，用于显示网页部分的区域，在 PC 端视口即是浏览器窗口区域，在移动端，为了让页面展示更多的内容，视窗的宽度默认不为设备的宽度，在移动端视窗有三个概念：布局视窗、视觉视窗、理想视窗

- 布局视窗：在浏览器窗口css的布局区域，布局视口的宽度限制css布局的宽。为了能在移动设备上正常显示那些为pc端浏览器设计的网站，移动设备上的浏览器都会把自己默认的 viewport 设为 980px 或其他值，一般都比移动端浏览器可视区域大很多，所以就会出现浏览器出现横向滚动条的情况
- ![img](https://s2.loli.net/2022/07/08/ISmQABkUvP49Vdc.png)
- 视觉视窗：终端设备显示网页的区域
- ![img](https://s2.loli.net/2022/07/08/tl1Ud3juF6ao7DB.png)
- 理想视窗：针对当前设备最理想的展示页面的视窗，不会出现横向滚动条，页面刚好全部展现在视窗内，理想视窗也就是终端屏幕的宽度。
- ![img](https://s2.loli.net/2022/07/08/KCBN4uQYXtEmF8I.png)

### 移动端视口配置怎么配的？

```
<meta name='viewport' content='width=device-width,initial-scale=1,user-scale=no' />
```

![img](https://s2.loli.net/2022/07/08/IBPvSC64MohRUmF.png)





### 移动端适配有哪些方案知道吗？

1、rem布局

2、vw、vh布局

3、媒体查询响应式布局

### 说说媒体查询吧?

通过媒体查询，可以针对不同的屏幕进行单独设置，但是针对所有的屏幕尺寸做适配显然是不合理的，但是可以用来处理极端情况（例如 IPad 大屏设备）或做简单的适配（隐藏元素或改变元素位置）

![img](https://s2.loli.net/2022/07/08/cAPEqYtlriRWkbZ.png)

### 说说rem适配吧

rem是CSS3新增的一个相对单位，这个单位引起了广泛关注。这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了IE8及更早版本外，所有浏览器均已支持rem。对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用rem设定的字体大小



### rem的具体适配方案知道吗?

**flexible.js适配**:阿里早期开源的一个移动端适配解决方案

## ![img](https://s2.loli.net/2022/07/08/3YjJDveGsNQlByO.png)

因为当年viewport在低版本安卓设备上还有兼容问题，而vw，vh还没能实现所有浏览器兼容，所以flexible方案用rem来模拟vmin来实现在不同设备等比缩放的“通用”方案，之所以说是通用方案,是因为他这个方案是根据设备大小去判断页面的展示空间大小即屏幕大小，然后根据屏幕大小去百分百还原设计稿，从而让人看到的效果(展示范围)是一样的，这样一来，苹果5 和苹果6p屏幕如果你按照设计稿还原的话，字体大小实际上不一样，而人们在一样的距离上希望看到的大小其实是一样的，本质上，**用户使用更大的屏幕，是想看到更多的内容，而不是更大的字**。



### rem的弊端知道吗

弊端之一：和根元素font-size值强耦合，系统字体放大或缩小时，会导致布局错乱

弊端之二：html文件头部需插入一段js代码

### 说说vw/vh适配

vh、vw方案即将视觉视口宽度 window.innerWidth和视觉视口高度 window.innerHeight 等分为 100 份

![img](https://s2.loli.net/2022/07/08/KiDTlZQbtaWBfGd.png)

### vw和vh有啥不足吗？

vw和vh的兼容性:

Android 4.4 之下和 iOS 8 以下的版本有一定的兼容性问题(但是目前这两版本已经很少有人使用了)

![img](https://s2.loli.net/2022/07/08/aMHeYJuB4wSUXD3.png)

rem的兼容性:

![img](https://s2.loli.net/2022/07/08/RmpknufEdD8SPaW.png)

### 当下主流的写法可以说说吗？

![img](https://s2.loli.net/2022/07/08/c86hADJOrX2MvEy.png)

## 组件库难点

我觉得组件库最难的就是开始的分析吧，

## 组件设计的基本原则

一个组件的复杂度，主要来源就是自身的状态；即组件自身需要维护多少个不依赖于外部输入的状态。

组件开发中，如何将数据和UI解耦，是最重要的工作。

组件开发过程中，时刻谨记、思考是否符合以下的原则，可以帮助你开发一个更完善的通用组件。

单一职责
你的组件是否符合只实现一个职责，并且只有一个改变状态的理由？

如fetch请求和渲染逻辑，应该分离。因为fetch请求时会造成组件重新渲染，渲染时的样式或数据格式变化，也会引起组件重新渲染。

单一职责可以保证组件是最细的粒度，且有利于复用。但太细的粒度有时又会造成组件的碎片化。

因此单一职责组件要建立在可复用的基础上，对于不可复用的单一职责组件，我们仅仅作为独立组件的内部组件即可。

通用性
组件开发要服务于业务，为了更好的复用，又要从业务中抽离。

先是代码结构

![image-20220705202051271](https://s2.loli.net/2022/07/08/2C6nFpDmtrYoAMS.png)

![image-20220705183613684](https://s2.loli.net/2022/07/08/9dkP4XT7VSI2KYU.png)

创建好项目之后，就进行样式的方案分析，因为react和vue不同，vue的样式可以直接卸载style里面，而react可以选择写成一个对象传给组件，也可以成一个文件进行import，选择的scss,然后准备一部分的色彩体系，进行不同组件之间的复用，色彩呢又分为两大体系，一个是系统色板（分为基础色板+中性色板），一个是产品色板（分为品牌色版+功能色板），然后自己定义了想要的品牌色和系统色板，放在一个_variables的文件里，emm然后定义了字体的系统，在字体上用rem，这样也能在移动端上进行一部分的适配，然后 运用normalize.css，它能提供通用的样式在不同的浏览器上，也可以优化css的可用性（@extends）

- **保护有用的浏览器默认样式**而不是完全去掉它们
- **一般化的样式**：为大部分HTML元素提供
- **修复浏览器自身的bug**并保证各浏览器的一致性
- **优化CSS可用性**：用一些小技巧
- **解释代码**：用注释和详细的文档来

![image-20220705210538880](https://s2.loli.net/2022/07/08/m9QdTZioPC3ye2n.png)

## CICD

**好处：**

功能分支提交后，通过 CICD 进行自动化测试、语法检查等，**如未通过 CICD，则无法 CodeReview，更无法合并到生产环境分支进行上线**

功能分支提交后，通过 CICD 检查 npm 库的风险、检查构建镜像容器的风险等

功能分支提交后，通过 CICD 对当前分支代码构建独立镜像并生成独立的分支环境地址进行测试，**如对每一个功能分支生成一个可供测试的地址，一般是 `<branch>.dev.shanyue.tech` 此种地址**

功能分支测试通过后，合并到主分支，自动构建镜像并部署到生成环境 (一般生成环境需要手动触发、自动部署)

`CICD` 集成于 CICD 工具及代码托管服务。CICD 有时也可理解为进行 CICD 的构建服务器，而提供 CICD 的服务，如以下产品，将会提供构建服务与 github/gitlab 集成在一起。

- `Travis CI

  创建.travis.yml文件

  ```
  language: node_js
  node_js:
  _"stable"
  cache:
    directories:
    - node_modules
  env:
   - CI=true
  ```

  注意如果有yarn.lock的话travis默认使用yarn.lock，travis应该使用package.json，所以删除yarn.lock

  这时使用 

  ```
  git add.
  git commit -m"test travis"
  git push
  ```

  就会自动进行打包、测试、语法检测和合并新的分支

  ![](https://s2.loli.net/2022/07/07/ELzoha6vUZqDtFX.png)

  ### 构建目标：拉取 github 代码

  点击 **新建 Item** 创建一个 `Freestyle Project`

  ### 构建目标：部署到本机

  部署前端项目肯定是离不开 `nginx` 的。 `yum install nginx`。

  安装完成后同样可以使用 `systemctl` 命令管理 `nginx` 服务。

  `nginx` 具体配置这里就不说了。本示例项目中，静态文件托管目录为 `/usr/share/nginx/html/dist`。

  接着来到 `Jenkins` 这里。想要部署前端项目还需要依赖一个 `Node` 环境，需要在 **Manage Jenkins -> Manage Plugins** 在可选插件中搜索 `nodejs` 选择对应插件进行安装，安装完成后需要重启才会生效。

  ### 构建目标：侦听 git 提交到指定分支进行构建

  - 来到 `Jenkins` 中选择 **系统管理 -> 系统配置** 找到 `Jenkins URL` 将其复制。
  - 随后在尾部添加 `github-webhook/` 尾部斜杠一定不要丢。 整体结构大致为 `http://192.168.0.1:8080/github-webhook/`
  - 登录 `github` 需要集成的项目中添加 `webhook`。在 `Payload URL` 中将上述内容填入。

  ## Pipline 构建

  上一章节中着重介绍了如何构建 `freestyle` 的任务，但是 `Jenkins` 远不止于此。在本章开始之前强烈建议[阅读文档](https://link.juejin.cn?target=https%3A%2F%2Fwww.jenkins.io%2Fzh%2Fdoc%2F)，重点关注流水线相关内容。

  **新建任务 -> 选择流水线** 其他内容可以都不用管，只关注**流水线** 有两种选择，演示就选择第一种。

  直接在 `Jenkins` 中书写配置。

  ![pipline1.jpg](https://s2.loli.net/2022/07/07/cjVHt8xDbIsiCLX.webp)

  在项目的 `Jenkinsfile` 配置文件中写配置。

  ![pipline2.jpg](https://s2.loli.net/2022/07/08/fel1P9FigAB4Yjy.webp)

  在正式开始之前应该了解 `Jenkins Pipline` 的基础概念。

  ```javascript
  pipeline {
      agent any // 在任何可用的代理上，执行流水线或它的任何阶段。
      stages {
          stage('Build') { // 定义 "Build" 阶段。
              steps {
                  // 执行与 "Build" 阶段相关的步骤。
              }
          }
          stage('Deploy') { // 定义 "Deploy" 阶段。
              steps {
                  // 执行与 "Deploy" 阶段相关的步骤。
              }
          }
      }
  }
  ```

  - `pipline`： 定义流水线整个结构，可以看做是根节点
  - `agent`：指示 `Jenkins` 为整个流水线分配一个执行器，比如可以配置 `Docker`
  - `stages`：对整个 `CI` 流的包裹，个人认为没多大用，还必须得有。
  - `stage`： 可以理解为是对某一个环节的描述。注意：参数就是描述内容，可以是任何内容。不要想歪了只能传递 `Build` `Deploy` 这些。
  - `steps`： 描述了 `stage` 中的步骤，可以存在多个。

  

  ## Pipline 复刻 freestyle

## 单元测试

### 1.前端单元测试是什么

   首先我们要明确测试是什么：

> ​    为检测特定的目标是否符合标准而采用专用的工具或者方法进行验证，并最终得出特定的结果。

​    对于前端开发过程来说，这里的特定目标就是指我们写的代码，而工具就是我们需要用到的测试框架(库)、测试用例等。检测处的结果就是展示测试是否通过或者给出测试报告，这样才能方便问题的排查和后期的修正。

​    基于测试“是什么”的说法，为便于刚从事前端开发的同行的进阶理解，那我们就列出单元测试它“不是什么”：

> 需要访问数据库的测试不是单元测试
>
> 需要访问网络的测试不是单元测试
>
> 需要访问文件系统的测试不是单元测试
>
> --- 修改代码的艺术

对于单元测试“不是什么”的引用解释，至此点到为止。鉴于篇幅限制，对于引用内容，我想前端开发的同行们看到后会初步有一个属于自己的理解。



### 2.单元测试的意义以及为什么需要单元测试

2. 1为什么需要单元测试
3. 首先是一个前端单元测试的根本性原由：JavaScript 是动态语言，缺少类型检查，编译期间无法定位到错误; JavaScript 宿主的兼容性问题。比如 DOM 操作在不同浏览器上的表现。
4. 正确性：测试可以验证代码的正确性，在上线前做到心里有底。
5. 自动化：当然手工也可以测试，通过console可以打印出内部信息，但是这是一次性的事情，下次测试还需要从头来过，效率不能得到保证。通过编写测试用例，可以做到一次编写，多次运行。
6. 解释性：测试用例用于测试接口、模块的重要性，那么在测试用例中就会涉及如何使用这些API。其他开发人员如果要使用这些API，那阅读测试用例是一种很好地途径，有时比文档说明更清晰。
7. 驱动开发，指导设计：代码被测试的前提是代码本身的可测试性，那么要保证代码的可测试性，就需要在开发中注意API的设计，TDD将测试前移就是起到这么一个作用。
8. 保证重构：互联网行业产品迭代速度很快，迭代后必然存在代码重构的过程，那怎么才能保证重构后代码的质量呢？有测试用例做后盾，就可以大胆的进行重构。

## 难点：如何优化单元测试的时间

### 开发中的痛点

将分支从基分支切出来进行开发完后，需要merge进目标分支，merge之前有一个CI的过程，这个过程包括lint检查、单元测试覆盖率检查等等。

随着项目体积越来越大，这个CI所需要的时间就会越来越多，每次大概花费20-30分钟，即使只修改了一个文件，而lint和单测是需要跑全量的，这就是对时间的严重浪费。

而单测又因为是一个文件一个文件的check，所以如果最后跑的那个文件单测出了问题，那么之前的时间全部就浪费掉了，又或者最后的覆盖率不通过，那么还需要重新对文件进行更改，在重跑。

以上流程对于开发人员来说就是心理上的严重折磨，开发效率严重降低。

### 之前所想的优化思路

之前曾经想过通过Jest提供的接口，在本地代码开发完后、push代码之前在本地强行进行单测检查，但是这样会存在以下问题：

- 开发过程中有一个紧急bug需要修复，需要切换分支，而我已经写完的代码为了不和git stack中的存储混乱，所以不能使用git stash，只能将代码先push进远端分支，强行进行检查需要等待时间。
- 需求尚未明确，组件开发只是先完成部分功能，为了节省时间，一般都会在组件全部完成后再写单测。而开发完一个页面组件之后将代码push到远端，又需要进行单测检查，这种情况由于单测没有写，除非忽略，否则单测肯定不通过。
- 每次push跑单测和统一跑单测，时间会差出来不少。

所以通过Jest提供的API来完成那是不可能的了。

### 后续的优化思路

因为我们团队中所使用的代码仓库是github，CI所使用的action也是github所提供的action，所以就想在action中是否有一个插件，能够拿到pr中所更改的所有文件呢？

还真有！`jitterbit/get-changed-files@v1`这个插件就能在action中获取到所更改的文件！

拿到了所更改的文件之后，在action中run nodejs脚本，将这些文件路径通过脚本参数传入到我们所写的脚本中，就可以单独针对这些文件做单测检查。

coverge对于文件间的测试是相互隔离、相互独立的，所以若只改动了一个文件，只需要run修改的文件对应的单元测试文件就足够。而对于只修改一些配置文件，甚至可以不用跑coverage。

前端单元测试coverage主要对三个方面进行检测：逻辑、快照和覆盖率。

逻辑和快照由于单测组件的隔离性，所以是不用考虑的。而覆盖率分为两个方面：单个文件的覆盖率和整体的覆盖率。

**Jest对于单个文件的覆盖率没有特别要求，而对于整体有一个百分比的限制，jest计算总体覆盖率（branch、functions、lines、statements）的方法将所有文件的覆盖行数进行求和**。

既然是求和，那么每次改动，只有变化的文件覆盖率有可能发生变化，所以，我们可以将本次修改的单个文件的覆盖率和上次这个文件的覆盖率作对比，就能得出整体的覆盖率的变化。对于新增的文件，可以将新增的总代码行数算到之前的总代码行数中，再将新增的覆盖代码行数算进之前的覆盖代码行数中，得出一个新增后的覆盖率，与之前作对比。

### 具体步骤

1. 在master最新的分支上coverage，得出的

   ```
   coverage-final.json
   ```

   文件是覆盖率的另一种表达方式（在jest.config.json文件中coverageReporters配置项新增“json”可以得到），利用

   ```
   nyc
   ```

   这个脚本可以将其解析成total和单个文件的覆盖率json文件，拿到这个json将其push到master分支上。

   ```json
   {
     "total": {
       "lines": {
         "total": 46851,
         "covered": 33931,
         "skipped": 0,
         "pct": 72.42
       },
       "statements": {
         "total": 56223,
         "covered": 40519,
         "skipped": 0,
         "pct": 72.07
       },
       "functions": {
         "total": 10412,
         "covered": 6544,
         "skipped": 0,
         "pct": 62.85
       },
       "branches": {
         "total": 26517,
         "covered": 12924,
         "skipped": 0,
         "pct": 48.74
       }
     },
     "/src/common/image.ts": {
       "lines": {
         "total": 8,
         "covered": 8,
         "skipped": 0,
         "pct": 100
       },
       "functions": {
         "total": 0,
         "covered": 0,
         "skipped": 0,
         "pct": 100
       },
       "statements": {
         "total": 8,
         "covered": 8,
         "skipped": 0,
         "pct": 100
       },
       "branches": {
         "total": 0,
         "covered": 0,
         "skipped": 0,
         "pct": 100
       }
     },
   }
   复制代码
   ```

2. 修改项目中yml配置文件，通过`jitterbit/get-changed-files@v1`这个github action插件获取到此次pr修改的所有文件，并通过script参数带入到新增的脚本文件中。

3. 在新增的脚本文件内，我们对改动的文件做筛选（没有写单测文件的、忽略单测文件的以及各种不需要单测文件的配置文件），将筛选出来的文件npm run covergae，会得到这些文件覆盖率，在通过nyc解析，拿到它们的结果。

4. 若是修改的文件，将修改后的覆盖率和之前的作对比，若是新增的文件，将其算到总数中求覆盖率，和之前的总覆盖率进行对比。就能得到此次改动对覆盖率是增加、不变还是减少。

通过以上步骤，单元测试的时间从**20min -> 3min**，大大提升了效率。

## 难点 动态路由 

### 管理权限



#### 动态路由组件权限管理

表述：一开始想到 如果自己开发的时候就一次配置好所有的路由映射 展示的时候  对应的页面不展示   但是会出现问题  虽然没显示 但是可以在浏览器地址栏直接进行输入 然后进行跳转  这是个安全问题

前端这里，为不同的角色设置好不同的映射关系（映射数组），请求数据用户的角色是什么，再把该角色的数组加入到 mainjs 对应的 children 内。 引发问题： 若后端又有新的角色出现，那么前端这边也要跟着进行修改，重新进行部署

在前端创建好所有路径对应的组件，但是根据后端返回的菜单数据，进行动态的生成路由。后端在**返回对应的路径信息**时，在**前端就设置好路径和组件之间的映射关系**，在**前端根据传过来的路径进行查找**，查找到就找到了该路径和组件的映射关系。

方法一：不管什么角色登陆，在开发的时候，在前端都全部配置好路由的映射关系，只是在展示的时候，对应路由的跳转不展现出来。 引发的问题： 虽然页面没有展示，但是可以通过浏览器的地址栏进行 “套”，就会显示对应映射的组件，但组件上可能是没有什么东西的，虽然这样但也不好，会不安全。

方法二：在前端这里，为不同的角色设置好不同的映射关系（映射数组），请求数据用户的角色是什么，再把该角色的数组加入到 main 对应的 children 内。 引发问题： 若后端又有新的角色出现，那么前端这边也要跟着进行修改，重新进行部署。

方法三：在前端创建好所有路径对应的组件，但是根据后端返回的菜单数据，进行动态的生成路由。后端在返回对应的路径信息时，也要把该路径映射组件的路径一起返回。但是也要后端要增加一个字段，来放置组件的位置。

方法四：在前端创建好所有路径对应的组件，但是根据后端返回的菜单数据，进行动态的生成路由。后端在返回对应的路径信息时，在前端就设置好路径和组件之间的映射关系，在前端根据传过来的路径进行查找，查找到就找到了该路径和组件的映射关系。

### 大致步骤：

前端在本地写好路由表，以及每个路由对应的角色，也就是哪些角色可以看到这个菜单 / 路由。

登录的时候，向后端请求得到登录用户的角色（管理者，普通用户）

利用路由守卫者(`router.beforeEach`)，根据取到的用户角色，跟本地的路由表进行对比，过滤出用户对应的路由，并利用路由进行菜单渲染

先执行异步请求，确保路由过滤和路径补全已完成。先把`routes`传入递归函数（`filterASyncRoutes`），用于做路径的补全和`Layout`的判断并赋值,并且当`routes`存在`children(子级路由)`的时候，路由需要再次回调递归函数（`filterASyncRoutes`），最后并把处理好的路由栈，返回给路由过滤函数

根据异步请求返回的`routes`，进行路由的排序，毕竟当用户动态处理了路由后，展示出来的顺序跟处理时的顺序不一致，那就不太好了。

路由都处理完成后，把路由循环，并动态添加进`router.options.routes`里面，而且`路由router`里面，要使用`addRoute(item)`，把路由一点点添加进路由表里。

最后执行路由跳转，跳回当前需要跳转的页面

## transition group

| 组件                                                         | 说明             |
| ------------------------------------------------------------ | ---------------- |
| [Transition](https://link.juejin.cn/?target=http%3A%2F%2Freactcommunity.org%2Freact-transition-group%2Ftransition) | 过渡组件         |
| [CSSTransition](https://link.juejin.cn/?target=http%3A%2F%2Freactcommunity.org%2Freact-transition-group%2Fcss-transition) | 动画进入出入组件 |
| [SwitchTransition](https://link.juejin.cn/?target=http%3A%2F%2Freactcommunity.org%2Freact-transition-group%2Fswitch-transition) | 动画却换组件     |
| [TransitionGroup](https://link.juejin.cn/?target=http%3A%2F%2Freactcommunity.org%2Freact-transition-group%2Ftransition-group) | 列表动画组件     |

这些组件包裹一下需要的内容就行

```
<CSSTransition>
<button>
</CSSTransition>
```

![image-20220705200631997](https://s2.loli.net/2022/07/08/sKqx2bi9fCy7dNU.png)

起初先是这样想的，但是没有动画效果，状态太过于生硬，于是就找到了这个库

![image-20220705200754143](https://s2.loli.net/2022/07/08/xKbtD9vI3NZT8PV.png)

## react-docgen

react-docgen 是一个 CLI 和工具箱，可帮助从 React 组件中提取信息并从中生成文档。它使用 ast 类型和@ babel / parser 将源解析为 AST，并提供处理此 AST 的方法以提取所需的信息。输出/返回值是一个 JSON blob / JavaScript 对象。**简单来说就是：它能提取组件的相关信息**

关于react-docgen提取的信息中，解释下下面几个参数

- `displayName` 组件名称
- `description` 组件的类注释
- `methods` 组件定义的方法
- `props` 组件的属性参数

其中这里的`props`是我们组件文档的核心内容，在提取的内容中，已经涵盖了属性的 **属性名、属性描述、类型、默认值、是否必传**。这些内容满足我们阅读组件文档所需要的属性信息。

然后转换成markdown文件

上面的转换markdown的代码其实做的事情比较少，主要是以下几个步骤

1. 遍历`props`对象中的每个属性，
2. 解析属性`prop`，提取`属性名`、`类型`、`默认值`、`必填`、`描述`、生成对应的markdown表格行。
3. 生成markdown内容，通过`prettier`美化markdown代码。

经过转换后最终生成我们这个markdown的文件

## 二维码登录 

PC端向服务端发起请求，告诉服务端，我要生成用户登录的二维码，并且把PC端设备信息也传递给服务端

服务端收到请求后，它生成二维码ID，并将二维码ID与PC端设备信息进行绑定

然后把二维码ID返回给PC端

PC端收到二维码ID后，生成二维码(二维码中肯定包含了ID)

为了及时知道二维码的状态，客户端在展现二维码后，PC端不断的轮询服务端，比如每隔一秒就轮询一次，请求服务端告诉当前二维码的状态及相关信息

![7777.jpg](https://s2.loli.net/2022/07/08/52L17jRsWGrwTQk.webp)

用户用手机去扫描PC端的二维码，通过二维码内容取到其中的二维码ID

再调用服务端API将移动端的身份信息与二维码ID一起发送给服务端

服务端接收到后，它可以将身份信息与二维码ID进行绑定，生成临时token。然后返回给手机端

因为PC端一直在轮询二维码状态，所以这时候二维码状态发生了改变，它就可以在界面上把二维码状态更新为已扫描

![3333333332.jpg](https://s2.loli.net/2022/07/08/sRkpwI8xGdBib1e.webp)手机端在接收到临时token后会弹出确认登录界面，用户点击确认时，手机端携带临时token用来调用服务端的接口，告诉服务端，我已经确认

服务端收到确认后，根据二维码ID绑定的设备信息与账号信息，生成用户PC端登录的token

这时候PC端的轮询接口，它就可以得知二维码的状态已经变成了"已确认"。并且从服务端可以获取到用户登录的token

到这里，登录就成功了，后端PC端就可以用token去访问服务端的资源了





**那么为什么需要返回给手机端一个临时token呢？**

临时token与token一样，它也是一种身份凭证，不同的地方在于它只能用一次，用过就失效。在第三步骤中返回临时token，为的就是手机端在下一步操作时，可以用它作为凭证。以此确保扫码，登录两步操作是同一部手机端发出的，

大致的步骤

- 打开pc端显示登录二维码(`pc端未登录的前提下`)

> 这个时候请求服务端生成一个登陆二维码 服务端生成二维码，该二维码包含了这个pc端的唯一标识，比如sessionId，或者是新生成一个uuid跟这个sessionId关联

- pc端同时开启轮询(`有长连接等其他实现，这里以轮询方式介绍`)

> 获取二维码之后，pc端开启定时轮询，轮询二维码的状态，主要有如下状态：NEW,SCANED,CONFIRMED,REFUSED,EXPIRED

- 手机端扫描二维码

> 手机端已经登录的情况下，扫描网页二维码，二维码状态变为已扫描，然后手机端跳转到确认页面

- 手机端确认

> 手机端扫描二维码之后，点击确认，二维码状态变为确认

- pc端跳转成功/二维码过期/拒绝

> 二维码状态变为确认之后，跳转自动登录，完成PC端登录态建立 如果app端拒绝这次请求，则二维码状态变为被拒绝，不再轮询 如果二维码状态在一定时间没有变化，则显示二维码过期，不再轮询

### 在template中写入如下代码：

```
     <div  key="qrCode" style="text-align: center;">
        <div   id="qrcode" ref="qrcode"  class="scan-code">
            <div v-if="qrcodeCancel">
                <div style="margin-top: 27px;"><span class="qrcode-restart"> 二维码已失效</span></div>
                 <div style="margin-top: 27px;"> <el-button class="btn confirm " style="width: 101px ;height:25px;" @click="handleClickRestart" >点击刷新</el-button><br></div>
            </div>
        </div>
    </div>                           
```

### 在.vue script 脚本中：

- 下载模块：

  ```
     // @ts-ignore
   import QRCode from 'qrcodejs2'
  ```

- 生成QRCode 二维码对象；

  ```
     /**
    * @description； 扫码登录，生成二维码
    * */
   public genereateQrCode () {
       let qrcode = new QRCode('qrcode',{
           width: 127, // 设置宽度，单位像素
           height: 127, // 设置高度，单位像素
           text: this.qrcodeLink // 设置二维码内容或跳转地址
       })
   }
  ```

- 通过setInterval()轮询去检查二维码状态，来作出对应的交互；根据项目需要的场景;



#### 代码实现

在vuex中



构建一个方法  进行路由添加

```js
import { RouteRecordRaw } from 'vue-router'

export function mapMenusToRoutes(userMenus: any[]): RouteRecordRaw[] {
  const routes: RouteRecordRaw[] = []

  // 1.先去加载默认所有的routes
  const allRoutes: RouteRecordRaw[] = []
  const routeFiles = require.context('../router/main', true, /\.ts/)
  routeFiles.keys().forEach((key) => {
    const route = require('../router/main' + key.split('.')[1])
    allRoutes.push(route.default)
  })

  // 2.根据菜单获取需要添加的routes
  // userMenus:
  // type === 1 -> children -> type === 1
  // type === 2 -> url -> route
  const _recurseGetRoute = (menus: any[]) => {
    for (const menu of menus) {
      if (menu.type === 2) {
        const route = allRoutes.find((route) => route.path === menu.url)
        if (route) routes.push(route)
      } else {
        _recurseGetRoute(menu.children)
      }
    }
  }

  _recurseGetRoute(userMenus)

  return routes
}
```

store/login.ts里面

mutations

```js
changeUserMenus(state, userMenus: any) {
      state.userMenus = userMenus

      console.log('注册动态路由')

      // userMenus => routes
      const routes = mapMenusToRoutes(userMenus)

      // 将routes => router.main.children
      routes.forEach((route) => {
        router.addRoute('main', route)
      })
    }
```



 actions

```typescript
const userMenusResult = await requestUserMenusByRoleId(userInfo.role.id)
      const userMenus = userMenusResult.data
      commit('changeUserMenus', userMenus)
      localCache.setCache('userMenus', userMenus)
```





### 基本功能

#### 登录的逻辑业务

localStorage 的封装

```typescript
class LocalCache {
  setCache(key: string, value: any) {
    window.localStorage.setItem(key, JSON.stringify(value));
  }
  getCache(key: string) {
    const value = window.localStorage.getItem(key);
    if (value) {
      return JSON.parse(value);
    }
  }
  deleteCache(key: string) {
    window.localStorage.removeItem(key);
  }
  clearCache() {
    window.localStorage.clear();
  }
}

export default new LocalCache();
```

对网络请求的数据用 Vuex 分模块进行存储，同时需要在本地缓存一份，因为有时已经登陆，在其他页面点击刷新按钮，vuex 内的数据是在内存里面的，那么刷新后数据就会消失，此时就可以从本地的缓存的数据进行重新加载。

登陆的逻辑步骤：

1、将账号密码进行验证，返回结果
2、获取用户的基本信息
3、获取主页的信息。(因为是管理系统，那么不同角色的主页面是不一致的)
4、数据的保存
5、页面跳转

如果同时在 login 组件内进行如此多的步骤，有些步骤是和本组件的关系是不相关的，其实这部分逻辑可以在 vuex 的 action 内进行。

#### token怎么做登录验证

![image.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/25/171103222de1a969~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

前后端完全分离的情况下，Vue项目中实现token验证大致思路如下：

1. 第一次登录的时候，前端调后端的登陆接口，发送用户名和密码
2. 后端收到请求，验证用户名和密码，验证成功，就给前端返回一个token
3. 前端拿到token，将token存储到localStorage和vuex中，并跳转路由页面
4. 前端每次跳转路由，就判断 localStroage 中有无 token ，没有就跳转到登录页面，有则跳转到对应路由页面
5. 每次调后端接口，都要在请求头中加token
6. 后端判断请求头中有无token，有token，就拿到token并验证token，验证成功就返回数据，验证失败（例如：token过期）就返回401，请求头中没有token也返回401
7. 如果前端拿到状态码为401，就清除token信息并跳转到登录页面
8. 调取登录接口成功，会在回调函数中将token存储到localStorage和vuex中

我把 Token 存在sessionStorage，检查有无 Token ，每次请求在 Axios 请求头上进行携带

#### 怎么进行判断处理

router/index.js文件

```js
//挂载路由导航守卫
router.beforeEach((to, from, next) => {
  if (to.path === '/login') return next();

  const tokenStr = window.sessionStorage.getItem('token')
  if (!tokenStr) return next('/login');
  next();
})
```

main.js文件里面

```js
//拦截器给header写入token
axios.interceptors.request.use(config=>{
  config.headers.Authorization=window.sessionStorage.getItem('token');
  return config;
});

Vue.prototype.$http=axios
```



使用 router.beforeEach 注册一个全局前置守卫，判断用户是否登陆

token有自己的过期时限，并且是在后台实现，前台虚无考虑那么多，具体前台的步骤分为三部

1. 在登陆的时候后台会给一个token码，前台将其存储在cookie，localstroage或者localsession中即可

   请注意需要在tooken的前边拼接字符串'Bearer '+，固定格式

   ```js
    login(){
        axios.post('/user/login',this.user).then((res)=>{
            localStorage.setItem('token',"Bearer "+res.data.res.token)
        })
    }
   
   ```

2. 在router中设置守卫导航

判断token是否存在，如果存在将携带token进行下一簇的操作，如果不存在，则返回登陆

```js
    router.beforeEach((to,from,next)=>{
        if(to.matched.some((route)=>route.meta.Auth)){
            if(localStorage.getItem('token')){
                next()
            }else{
              next({
                 path:'/login',
                    query:{
                     returnURL:to.path
                }
                })
            }
           
     }else{
             next()
        }
    })

```

1. 在axios的请求拦截器中携带tooken进行请求

   **config.headers.Authorization**

   ```
    axios.interceptors.request.use(config=>{
        const token=localStorage.getItem('token')
        // if(token){
            token?config.headers.Authorization=token:null;
        // }
        return config
    })
   ```

每次请求时都会携带token，后台验证不验证token就是后台的问题了

设置token的回复拦截器，对回执码错误的进行操作处理

```js
    axios.interceptors.response.use(res=>{
        if(res.data.res_code=== 401){
            router.replace('/login');
            localStorage.removeItem('token')
        }
        return res
    })
```

token的基本原理

![img](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65b5e67305f84e9391de2d5b436600e7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

access token 用来访问业务接口，由于有效期足够短，盗用风险小，也可以使请求方式更宽松灵活

refresh token 用来获取 access token，有效期可以长一些，通过独立服务和严格的请求方式增加安全性；由于不常验证，也可以如前面的 session 一样处理

#### Acesss Token

- **访问资源接口（API）时所需要的资源凭证**
- **简单 token 的组成：** uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）
- 特点：
  - **服务端无状态化、可扩展性好**
  - **支持移动端设备**
  - 安全
  - 支持跨程序调用
- **token 的身份验证流程：**



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/29/16f523a04d9c745f~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)



1. 客户端使用用户名跟密码请求登录
2. 服务端收到请求，去验证用户名与密码
3. 验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端
4. 客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里
5. 客户端每次向服务端请求资源的时候需要带着服务端签发的 token
6. 服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据

- **每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里**
- **基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库**
- **token 完全由应用管理，所以它可以避开同源策略**

#### Refresh Token

- 另外一种 token——refresh token
- refresh token 是专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。



![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/29/16f523a04d1c887b~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)



- Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了。
- Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。

Session 是一种**记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息**。而 Token 是**令牌**，**访问资源接口（API）时所需要的资源凭证**。Token **使服务端无状态化，不会存储会话信息。**

Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。**如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。**

所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：**如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。**

#### Token 和 JWT 的区别  

**相同：**

- 都是访问资源的令牌
- 都可以记录用户的信息
- 都是使服务端无状态化
- 都是只有验证成功后，客户端才能访问服务端上受保护的资源

**区别：**

- Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。
- JWT： 将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。

## 第三方登录

![1608280341945](https://zhoushugang.gitee.io/erabbit-client-pc-document/assets/img/1608280341945.57fbfa34.png)

描述一下我们要做的事情：

- 在登录页面，QQ登录图片处，赋予其打开QQ登录页面功能。
- 回跳的页面得到QQ给的唯一标识openId，根据openId去后台查询是否已经绑定过账户。
  - 如果绑定过，完成登录。
  - 没有绑定过
    - 有账号的，绑定手机号，即为登录。
    - 没账号的，完善账户信息，即为登录。
- 登录成功后，跳转首页，或者来源页面。

## [#](https://zhoushugang.gitee.io/erabbit-client-pc-document/guide/06-login.html#_11-登录-qq登录-按钮处理)11-登录-QQ登录-按钮处理

第一步：参考文档：

- 准备工作（申请appid与appkey）

- 获取QQ互联SDK

- 总结一下：

  - 有一个网站，且已备案。网站需要有QQ登录的逻辑（登录页面，回跳页面）。
  - 然后在QQ互联上进行身份认证，审核通过。
  - 然后在QQ互联上创建应用，应用需要域名，备案号，回调地址。审核通过。
  - 得到：应用ID 应用key 回调地址。
  - 才能完成QQ登录。（以上四个步骤，工作后大概率由后台或运维完成）
  - 注意：id和uri都不能修改，否则无效。

  ```bash
  # 测试用appid 
  # 100556005
  # 测试用redirect_uri
  # http://www.corho.com:8080/#/login/callback
  ```

第二步：遇到问题：

- 由于域名是www.corho.com跳转不到localhost和localhost不一致无法回调页面，需要在本地修改hosts地址。

- 

- ```
  windows
  1. 找到 C:\Windows\System32\drivers\etc 下hosts文件
  2. 在文件中加入  127.0.0.1       www.corho.com映射
  3. 保存即可。
  # 如果提示没有权限
  1. 将hosts文件移到桌面，然后进行修改，确认保存。
  2. 将桌面hosts文件替换c盘文件
  ```

- 这时vue cli 还不允许使用ip域名的方式访问，所以用www.corho.com 访问的话没有作用

- 需要开启IP或域名访问webpack服务器权限，在vue.config.js中

```json
  // 这个是给webpack-dev-server开启可IP和域名访问权限。
  chainWebpack: config => {
    config.devServer.disableHostCheck(true)
  }
```

第三步：处理QQ登录按钮：

1. 在index.html添加一个script标签

```html
<script src="http://connect.qq.com/qc_jssdk.js" data-appid="100556005" data-redirecturi="http://www.corho.com:8080/#/login/callback"></script>

```

引入这个js之后会有一个全局的变量QC，然后可以通过import  QC调用方法，但是这时候会报错，因为模块在打包的时候没有QC，就像引入CDN一样，需要webpack进行exclude排除QC的打包

```json
  # 这个是设置外部扩展，模块为qc变量名为QC，导入qc将不做打包。
  configureWebpack: {
    externals: {
      qc: 'QC'
    }
  },
```

引入了QC之后可以直接使用一个span 然后id设置为qqLoginBtn就能够生成QQ登录的按钮

```html
<span id="qqLoginBtn"></span>
```

因为点击QQ登录按钮登录之后是新开一个页面，所以就通过审查元素，找到跳转连接，自己将跳转链接放在一个a标签里，然后配置后面的路由

```html
          <a href="https://graph.qq.com/oauth2.0/authorize?client_id=100556005&response_type=token&scope=all&redirect_uri=http%3A%2F%2Fwww.corho.com%3A8080%2F%23%2Flogin%2Fcallback">
            <img src="https://qzonestyle.gtimg.cn/qzone/vas/opensns/res/img/Connect_logo_7.png" alt="">
          </a>
```

## 12-登录-QQ登录-回跳页面

> 目的：完成QQ登录成功后的页面

主要有三个逻辑：

- 已注册，已绑定，登录成功，跳转首页，或者来源页面
- 已注册，未绑定，绑定手机号，登录成功，跳转首页，或者来源页面
- 未注册，补充完善账户信息，，登录成功，跳转首页，或者来源页面

## 13-登录-QQ登录-已注册已绑定

> 目的：已注册已绑定，完成QQ登录。

大致思路：

- 回跳组件初始化的时候获取openId
- 根据openId去后台进行登录
- 如果成功，就代表已注册已绑定，记录返回的用户信息，跳转到首页或者来源页面。
- 再做上述事件需要网络请求，所以加上一个loading状态。

## 14-登录-QQ登录-未绑定有账号

大致思路：

- 获取QQ用户的头像和昵称展示
- 进行表单校验
- 进行短信验证码发送
- 进行绑定，完成后为登录状态，跳转到首页或者来源页面。

## 15-登录-QQ登录-未绑定没账号

大致思路：

- 完成表单校验，需要加两个校验规则，用户名和确认密码。
- 需要短信验证码功能，使用注册时候的接口
- 进行完善，完成后为登录状态，跳转到首页或者来源页面
